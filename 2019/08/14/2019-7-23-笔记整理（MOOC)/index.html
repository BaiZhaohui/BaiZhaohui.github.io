<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="当我们调用一个函数的时候，会在内存中建立起一块特殊区域，称为“程序栈（program stack）”。程序栈提供了每个函数参数的储存空间。它也提供函数所定义的每个对象的内存空间——我们将这些对象称为 local object（局部对象）。一旦函数完成，这块内存就会被释放掉，或者说从程序堆栈中被pop出来。当我们将vec[ix]这样的对象传入函数时，默认情形下其值会被复制一份，成为参数的局部性定义（">
<meta property="og:type" content="article">
<meta property="og:title" content="Mist">
<meta property="og:url" content="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（MOOC)/index.html">
<meta property="og:site_name" content="Mist">
<meta property="og:description" content="当我们调用一个函数的时候，会在内存中建立起一块特殊区域，称为“程序栈（program stack）”。程序栈提供了每个函数参数的储存空间。它也提供函数所定义的每个对象的内存空间——我们将这些对象称为 local object（局部对象）。一旦函数完成，这块内存就会被释放掉，或者说从程序堆栈中被pop出来。当我们将vec[ix]这样的对象传入函数时，默认情形下其值会被复制一份，成为参数的局部性定义（">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-11T11:52:17.299Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mist">
<meta name="twitter:description" content="当我们调用一个函数的时候，会在内存中建立起一块特殊区域，称为“程序栈（program stack）”。程序栈提供了每个函数参数的储存空间。它也提供函数所定义的每个对象的内存空间——我们将这些对象称为 local object（局部对象）。一旦函数完成，这块内存就会被释放掉，或者说从程序堆栈中被pop出来。当我们将vec[ix]这样的对象传入函数时，默认情形下其值会被复制一份，成为参数的局部性定义（">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（MOOC)/">





  <title> | Mist</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mist</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（MOOC)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>当我们调用一个函数的时候，会在内存中建立起一块特殊区域，称为“程序栈（program stack）”。程序栈提供了每个函数参数的储存空间。它也提供函数所定义的每个对象的内存空间——我们将这些对象称为 local object（局部对象）。一旦函数完成，这块内存就会被释放掉，或者说从程序堆栈中被pop出来。<br>当我们将vec[ix]这样的对象传入函数时，默认情形下其值会被复制一份，成为参数的局部性定义（local definition）。这种方式称为pass by value（传值）。我们在bubble_sort()内传给swap()的对象，和我们在swap()内操作的对象，其实是没有任何关联的两组对象。为了让程序正确运行，必须通过某种方法，令swap()的参数和传入的实际对象产生关联。即所谓的pass by reference （传址）。最简单的做法便是将参数声明为一个reference：在型别名称和reference名称之间插入&amp;符号，便声明了一个reference。<br>C++不允许改变references所代表的对象，他们必须从一而终。面对reference的所有操作都像面对“reference”所代表之对象所进行的操作一般无二。以reference作为函数参数时，亦复如此。<br>以by reference 方法传递对象当作函数参数，对象本身并不会复制出另一份——复制的是对象的地址。函数中对该对象进行的任何操作，都相当于是对传入的对象进行间接操作。将参数声明为reference的另一个理由是降低复制大型对象的负担。</p>
<p>也可以将vector以pointer形式传递。这和以reference传递的效果作用相同：传递的是对象地址，而不是整个对象的复制品。唯一的差别在于reference和pointer的用法不同。</p>
<p>pointer 参数和reference 参数更重要的差异是：pointer可能（也可能不）指向某个实际对象。当我们提领pointer时，一定要先确定其值非0。而reference则必定会代表某个对象，所以无需做此检查。reference不可以置为0。</p>
<p>一般来说，除非希望在函数内更改参数值，否则在传递内建型别时，不要使用传址方式，传址机制主要是作为传递 class object 之用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(size&lt;=<span class="number">0</span> || size&gt;<span class="number">1024</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">"Warning: fibon_seq():"</span></span><br><span class="line">    &lt;&lt; size &lt;&lt; <span class="string">"not supported -- resetting to 8\n"</span>;</span><br><span class="line">    size = <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; elems(size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ix=<span class="number">0</span>;ix&lt;size;++ix)</span><br><span class="line">      <span class="keyword">if</span> (ix ==<span class="number">0</span> || ix==<span class="number">1</span>)</span><br><span class="line">        elems[ix]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        elems[ix] = elems[ix<span class="number">-1</span>] + elems[ix<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论以pointer或reference形式将elems返回，都不正确，因为elems在fibon_seq()执行完毕时已不复存在。如果将elems以传值方式返回，便不会产生任何问题；因为返回的乃是对象的复制品，它在函数之外依然存在。</p>
<p>为对象配置的内存，其存活期称为储存期（storage duration） 或范围（extent）。每次fibon_seq()执行起来，都会为elems配置内存，每当fibon_seq()终了便会加以释放。我们称此对象具有局部性范围（local extent）。函数参数便有局部性范围。</p>
<p>对象在程序中存活区域称为该对象的 scope（生存空间）。size 和 elems 在fibon_seq()函数内拥有local scope。若某个对象仅具有local scope（局部性生存空间），其名称在local scope之外便不可视。<br>对象如果在函数之外声明，则具有 file scope。对象如果拥有file scope，则从其声明点至文件尾端都是可视的。file scope内的对象亦具备所谓的 static scope，意谓该对象的内存在main()开始执行之前便已经配置好了，可以一直存在至程序结束为止。</p>
<p>内建型别的对象，如果定义在file scope之内，必定被初始化为0。但如果它们被定义于local scope之内，那么除非程序员指定其初值，否则不会被初始化。<br>file scope 对象会打乱不同函数间的独立性，使它们难以理解。</p>
<h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><p>不论local scope 或者是file extent，都由系统自动管理。第三种存储期形式称为 dynamic extent（动态范围）。其内存由程序的自由空间（free store）配置而来，有时也称为heap memory（堆内存）。此种内存必须由程序员自行管理，其配置是通过new 表达式来达成的，释放通过delete表达式完成。</p>
<p>new Type:<br>Type 可以为任意内建型别，也可以是程序知道的class型别。new 表达式亦可写为：<br>new Type(initial_value);<br>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

<p>先由heap 配置出一个型别为int 的对象，再将其地址赋值给pi。默认情形下，由heap配置而来的对象，皆为经过初始化。new表达式的另一种形式允许我们指定初值，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>同样是先由heap配置出一个类型为int的对象，再将其地址赋值给pi，但这个对象的值会被初始化为1024.<br>从heap中配置数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">24</span>];</span><br></pre></td></tr></table></figure>

<p>从heap中配置一数目组，拥有24个整数。pia会被初始化为数组第一个元素的地址。数组中的每个元素都未经过初始化。C++ 没有提供任何语法让我们得以从heap配置数组的同时为其元素设定初值。<br>从heap配置而来的对象，被称为具有dynamic extent，因为它们是在执行期通过 new 表达式配置来的，因此可以持续存活，直到以 delete 表达式加以释放为止。下面的 delete 表达式会释放Pi所指的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete pi;</span><br></pre></td></tr></table></figure>

<p>如果要删除数组中的所有对象，必须在数组指针和delete表达式之间，加上一个空的下标运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<p>注意，无需检验pi是否非零：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (pi!=0) // 多此一举——编译器会提我们检查</span><br><span class="line">  delete pi;</span><br></pre></td></tr></table></figure>

<p>以“参数传递”作为函数间的沟通方式，比“直接将对象定义于file scope”更适当。理由之一是，函数如果过度依赖定义于file scope内的对象，就比较难以在其他环境中被重复使用，也比较难以修改——我们不仅需要了解该函数的运行逻辑，也必须了解定义于file scope中的那些个对象的运行逻辑。</p>
<p>通常将参数默认值置于函数声明处。</p>
<h4 id="局部静态对象（Local-Static-Objects）"><a href="#局部静态对象（Local-Static-Objects）" class="headerlink" title="局部静态对象（Local Static Objects）"></a>局部静态对象（Local Static Objects）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *</span><br><span class="line">fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elems;</span><br><span class="line">	<span class="comment">// 函数的运行逻辑置于此处</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此刻的elems被定义为fibon_seq()中的局部静态对象。局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在。elems 的内容不再像以前一样地于fibon_seq()每次被调用时就被破坏又被重新建立。这也是为什么现在我们可以安全地将elems的地址返回的原因。<br>局部静态对象使我们可以定义一个含有Fibonacci数列的vector，每当调用fibon_seq()时，只需计算那些尚未被置入elems的元素即可。</p>
<p>将函数声明为 inline ，表示要求编译器在每个函数调用点上，将函数的内容展开。面对一个inline函数，编译器可将该函数的调用操作改以一份函数码副本取而代之。这使我们获得效率上的改善，其结果等于是把三个函数写入 fibon_elem()内，但依然维持3个独立的运算单元。</p>
<p>在函数前面加上关键词 inline ,便可将该函数声明为 inline 。将函数指定为inline，只是对编译器提出的一种要求，编译器是否执行这项请求，需视编译器而定。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>function overloading<br>参数表（parameter list）不相同（可能是参数型别不同，也可能是参数数目不同）的两个或多个函数，可以拥有相同的函数名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器将调用者提供的实际参数拿来和每个重载函数的参数比较，找出其中最适当的。这也就是为什么每个重载函数的参数必须和其它重载函数的参数表不同的原因。</p>
<p>编译器无法根据函数返回值类型来区分两个具有相同名称的函数，以下便是不正确的写法，会产生编译错误：<br>//错误：参数表（而非返回值的型别）必须不同。<br>ostream&amp; display_message(char ch);<br>bool display_message(char ch);<br>因为返回值型别无法保证提供我们一个足以区分不同重载函数的情境。</p>
<p>将一组实现代码不同但工作内容相似的函数加以重载，可以让函数用户更容易使用这些函数。如果没有重载机制，我们就得为每个函数提供不同的名称。</p>
<h4 id="定义并使用-Template-Functions（模板函数）"><a href="#定义并使用-Template-Functions（模板函数）" class="headerlink" title="定义并使用 Template Functions（模板函数）"></a>定义并使用 Template Functions（模板函数）</h4><p>将单一函数的内容与希望显示的各种vector型别捆绑（bind）起来。<br>function template 将参数表中指定的所有（或部分）参数的型别信息抽离出来。在display_message()例子中，我们希望将vector 所持元素的型别抽离出来，于是就可以定义出一份不需再有任何更改的模板（template）。不过，这样还不完整，因为我们遗漏了抽离出来的型别信息。这份型别信息由用户提供——当他决定采用 function template 的某个实体时提供。<br>function template 以关键词 template 开场，其后紧接着以成对尖括号（&lt;&gt;）包围起来的一个或多个识别名称，这些名称用以表示我们希望延缓决定的数据型别。每当用户利用模板（template）产生函数时，他就必须提供确实的型别信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;elemType&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ix =<span class="number">0</span>;ix&lt;vec.size();ix++)</span><br><span class="line">    &#123;</span><br><span class="line">      elemType t = vec[ix];</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; t &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键词 typename 表示，elemType 在display_message() 函数中乃是一个临时放置型别的代称。elemType 只是个任意名称，也可以用foobar 或 T 之类的名称。</p>
<p>在我们编译程序时，实际过程模板会被编译两次。 </p>
<ul>
<li>首先，对模板代码检查语法（如缺少分号）等语法错误。 </li>
<li>然后，实例化时，即调用模板函数时检查模板函数中的操作是否支持该类型。</li>
</ul>
<p>模板参数的个数可是任意个，但是不能为模板参数指定默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T1 <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a; </span><br><span class="line">&#125; </span><br><span class="line">… </span><br><span class="line">max(<span class="number">4</span>,<span class="number">4.2</span>)   <span class="comment">// OK, but type of first argument defines return type</span></span><br></pre></td></tr></table></figure>

<p>上面的例子看起来很好，但是有问题。首先，返回类型必须被声明。如果返回类型是其中的一个模板参数类型，另一个参数类型就可能被转换成返回的类型。另外一个问题，把第二个类型转换为第一个类型会产生局部临时对象，那么就不能使用引用的方式（by reference）传回结果。因此上面的例子中，返回的类型是T1 而不是 T const&amp;</p>
<p>由于调用参数（call parameters ）是由模板参数（template parameters）构造的，所以两者是相关的。我们把这种概念称为：函数模板参数推导。有了推导，就可以像调用普通函数那样调用函数模板。 </p>
<p>如之前的例子，调用时为函数模板显示指定类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// instantiate T as double</span></span><br></pre></td></tr></table></figure>

<p>当模板参数和调用参数没有直接关系，且编译器也无法推导出模板参数时，就需要明确的指定模板参数了。如，可以为max()指定第三个模板参数类型作为返回参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span><span class="params">(T1 <span class="keyword">const</span>&amp; a,T2 <span class="keyword">const</span>&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而，推导机制并不会对返回类型进行匹配，而且模板参数RT也不在调用参数中。因此，编译器无法推导出RT，调用时就必须显示指定类型，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// OK, but tedious</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，调用时要么不需要指定参数完全由编译器推导，要么就要把所有的参数多显示指定了。<br>当然，还有一种方法只明确的指定第一个模板参数，其它的参数由编译器自动推导。<br>如下：RT要放在第一个参数的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// OK: return type is double</span></span><br></pre></td></tr></table></figure>

<p>函数模板重载（Overloading Function Templates）<br>和普通的函数一样，函数模板也是可以重载的。<br>函数重载：不同的函数的定义可以有相同的函数名，当函数被调用的时候由编译器判断使用哪个函数。<br>如下，函数模板重载的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maximum of two int values</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span>&amp; a, <span class="keyword">int</span> <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maximum of two values of any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maximum of three values of any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b, T <span class="keyword">const</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> max(max(a, b), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	::max(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>);     <span class="comment">// calls the template for three arguments </span></span><br><span class="line">	::max(<span class="number">7.0</span>, <span class="number">42.0</span>);     <span class="comment">// calls max&lt;double&gt; (by argument deduction) </span></span><br><span class="line">	::max(<span class="string">'a'</span>, <span class="string">'b'</span>);      <span class="comment">// calls max&lt;char&gt; (by argument deduction) </span></span><br><span class="line">	::max(<span class="number">7</span>, <span class="number">42</span>);         <span class="comment">// calls the nontemplate for two ints </span></span><br><span class="line">	::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>);       <span class="comment">// calls max&lt;int&gt; (by argument deduction) </span></span><br><span class="line">	::max&lt;<span class="keyword">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argument deduction) </span></span><br><span class="line">	::max(<span class="string">'a'</span>, <span class="number">42.7</span>);     <span class="comment">// calls the nontemplate for two ints </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，非模板函数可以和同名的函数模板同时存在，也可以和相同类型的函数模板实例同时存在。当所有的条件都相同时，编译器会优先选择非模板函数。<br>因此上面的第四个调用的是非模板函数。</p>
<p>调用时可以使用空的模板参数列表”&lt;&gt;”,这种形式告诉编译器必须使用从函数模板的实例，且模板参数由调用参数自动推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>)    <span class="comment">// calls max&lt;int&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure>

<p>由于模板是不能进行自动类型转换的，而普通函数是可以自动类型转换，所有最后一个调用的是非模板函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="string">'a'</span>, <span class="number">42.7</span>)      <span class="comment">// only the nontemplate function allows different argument types</span></span><br></pre></td></tr></table></figure>

<p>如果表头文件和含入此文件的程序代码文件位于同一个驱动器目录下，我们便使用双引号。如果在不同的驱动器目录下，我们便使用尖括号。<br>如果此文件被认定为标准的、或项目专属的头文件，我们便以尖括号将文件名括住；编译器搜寻此文档时，会先在某些默认的驱动器目录中找寻，如果文件名由成对的双括号括住，此文件便被认为是一个用户自行提供的头文件；搜寻此文件时，会由含入此文件之文件所在的驱动器目录开始找起。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/14/2019-7-23-笔记整理（C++ADT)/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/14/2019-7-23-笔记整理（侯捷笔记3)/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaohui Bai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BaiZhaohui" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:isolatedislet@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态内存管理"><span class="nav-number">1.</span> <span class="nav-text">动态内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部静态对象（Local-Static-Objects）"><span class="nav-number">2.</span> <span class="nav-text">局部静态对象（Local Static Objects）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数重载"><span class="nav-number">3.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义并使用-Template-Functions（模板函数）"><span class="nav-number">4.</span> <span class="nav-text">定义并使用 Template Functions（模板函数）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaohui Bai</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

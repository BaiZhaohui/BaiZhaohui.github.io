<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Python 数据结构第一章编写新的函数函数定义函数头下方使用带有”””的字符串，这是一个文档字符串（docstring）。就像是函数中的注释，用户输入help(函数名)的时候，将显示这个字符串。当一个函数不包含return语句时，它在执行完最后一条语句时，会自动地返回一个None值。在模块中，可以按照任意顺序来定义函数，只要函数在被编译之前，不会真正地去执行函数即可。 1234567first(">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/08/14/2019-4-24-Python数据结构第一章/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Python 数据结构第一章编写新的函数函数定义函数头下方使用带有”””的字符串，这是一个文档字符串（docstring）。就像是函数中的注释，用户输入help(函数名)的时候，将显示这个字符串。当一个函数不包含return语句时，它在执行完最后一条语句时，会自动地返回一个None值。在模块中，可以按照任意顺序来定义函数，只要函数在被编译之前，不会真正地去执行函数即可。 1234567first(">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-08-11T11:52:17.299Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Python 数据结构第一章编写新的函数函数定义函数头下方使用带有”””的字符串，这是一个文档字符串（docstring）。就像是函数中的注释，用户输入help(函数名)的时候，将显示这个字符串。当一个函数不包含return语句时，它在执行完最后一条语句时，会自动地返回一个None值。在模块中，可以按照任意顺序来定义函数，只要函数在被编译之前，不会真正地去执行函数即可。 1234567first(">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/14/2019-4-24-Python数据结构第一章/">





  <title> | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-4-24-Python数据结构第一章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Python-数据结构第一章"><a href="#Python-数据结构第一章" class="headerlink" title="Python 数据结构第一章"></a>Python 数据结构第一章</h2><h3 id="编写新的函数"><a href="#编写新的函数" class="headerlink" title="编写新的函数"></a>编写新的函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数头下方使用带有”””的字符串，这是一个文档字符串（docstring）。就像是函数中的注释，用户输入help(函数名)的时候，将显示这个字符串。<br>当一个函数不包含return语句时，它在执行完最后一条语句时，会自动地返回一个None值。<br>在模块中，可以按照任意顺序来定义函数，只要函数在被编译之前，不会真正地去执行函数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first() # Raises a NameError(function undefined yet)</span><br><span class="line"></span><br><span class="line">def first():</span><br><span class="line">      second()  # Not an error, because not actually</span><br><span class="line">def second():</span><br><span class="line">      print(&quot;Calling second.&quot;)</span><br><span class="line">first() # Here is where the call should go.</span><br></pre></td></tr></table></figure>

<p>这个例子中，second函数似乎在定义它之前就调用了，但实际上知道调用函数first的时候，才真正调用了second，而这个时候，这两个函数都定义过了。<br>可以使用<parameter name> = <default value>的形式，带上为参数指定的默认值，从而将参数指定为可选的。在参数列表中，必需的参数（不带默认值的参数）必须要放在可选的参数之前。</default></parameter></p>
<h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><p>递归函数必须至少包含一条选择语句。这条语句检查base case，来判断是停止还是继续递归。<br>迭代算法转换为一个递归函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def displayRange(lower,upper):</span><br><span class="line">      &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;</span><br><span class="line">      while lower &lt;= upper:</span><br><span class="line">              print(lower)</span><br><span class="line">              lower = lower + 1</span><br></pre></td></tr></table></figure>

<p>如何转换？注意两点：</p>
<ul>
<li>当 lower  &lt;= upper 的时候，循环体继续执行：</li>
<li>当函数执行的时候，lower增加1，但是upper不变。<br>  等价的递归函数可以执行类似的基本操作，但是，用一条if语句替代了循环，用函数的递归替代了复制语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def displayRange(lower,upper):</span><br><span class="line">    &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;</span><br><span class="line">    if lower &lt;= upper:</span><br><span class="line">        print(lower)</span><br><span class="line">        displayRange(lower+1,upper)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>大多数递归函数都至少接受一个参数。这个数据值测试结束递归过程的基本条件。在每一个递归步骤之前，也会以某种方式修改这个值。每次对数据值的修改，都应该会产生一个新的数据值，以允许函数最终达到基本条件。上面例子中，在每一次递归调用之前，将参数lower的值增加1，以使得其最终能够超过参数upper的值。<br>例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ourSum(lower,upper):</span><br><span class="line">      &quot;&quot;&quot;Return the sum of the numbers from lower thru upper.&quot;&quot;&quot;</span><br><span class="line">      if lower &gt; upper:</span><br><span class="line">          return 0</span><br><span class="line">      else:</span><br><span class="line">          return lower + ourSum(lower+1, upper)</span><br></pre></td></tr></table></figure>

<p>跟踪其调用情况来更好地理解递归的工作方式：添加一个参数表示缩进的边距，并且添加输出语句来跟踪每次调用的时候两个参数的值和返回的值。每次调用的第一条语句会计算缩进的边距，然后在输出两个参数的时候使用它。在每次调用返回之前，也会使用该缩进把计算所得到的值输出出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def ourSum(lower,upper,margin=0):</span><br><span class="line">    &quot;&quot;&quot;Returns the sum of the numbers from lower to upper,</span><br><span class="line">    and outputs a trace of the arguments and return values</span><br><span class="line">    on each call.&quot;&quot;&quot;</span><br><span class="line">    blanks = &quot; &quot; * margin</span><br><span class="line">    print(blanks,lower,upper)</span><br><span class="line">    if lower &gt; upper:</span><br><span class="line">        print(blanks, 0)</span><br><span class="line">    else:</span><br><span class="line">        result = lower + ourSum(lower + 1,upper, margin + 4)</span><br><span class="line">        print(blanks, result)</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h4 id="嵌套的函数定义"><a href="#嵌套的函数定义" class="headerlink" title="嵌套的函数定义"></a>嵌套的函数定义</h4><p>可以在一个函数的语句序列之中，嵌套其他函数的定义。考虑递归函数factorial的如下两个定义，第一个定义使用了一个嵌套的辅助函数，来用必需的参数执行递归。第二个定义给定了第二个参数一个默认值，从而简化了设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># First definition</span><br><span class="line">def factorial(n):</span><br><span class="line">    &quot;&quot;&quot;Returns the factorial of n.&quot;&quot;&quot;</span><br><span class="line">    def recurse(n, product):</span><br><span class="line">        if n == 1:return product</span><br><span class="line">        else: return recurse(n-1, n * product)</span><br><span class="line">    recurse(n,1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Second definition</span><br><span class="line">def factorial(n,product = 1):</span><br><span class="line">    &quot;&quot;&quot;Returns the factorial of n.&quot;&quot;&quot;</span><br><span class="line">    if n == 1 : return product</span><br><span class="line">    else: return factorial(n - 1 ,n *product)</span><br></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>Python 函数都是第一类的数据对象。这意味着，可将函数赋值给变量，保存到数据结构中，作为参数传递给其他函数，以及当作其他函数的值返回。<br>高阶函数（high-order function）：接受另一个函数作为参数，并且以某种方式应用该函数。<br>Python包含了内建的高阶函数，如map和filter，它们对于处理可迭代的对象很有用。<br>map 函数接受一个函数和一个可迭代对象作为参数，并且返回另一个可迭代对象。后者是对第一个可迭代对象中的每一项应用参数函数而得到的另一个可迭代对象。简而言之，map实际上将一个可迭代对象中的每一项都转换了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建了包含字符串的可迭代对象</span><br><span class="line">map(str, oldList)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据上面的对象创建了一个新的列表</span><br><span class="line">newList = list(map(str,oldList))</span><br></pre></td></tr></table></figure>

<p>若想要从考试分数的一个列表中删除所有的0分，如下循环可以完成这个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">newList = []</span><br><span class="line">for number in oldList:</span><br><span class="line">    if number &gt; 0:</span><br><span class="line">        newList.append(number)</span><br></pre></td></tr></table></figure>

<p>或者可以使用filter函数，该函数接受一个布尔函数和一个可迭代对象作为参数。filter函数返回一个可迭代的对象，其中每一项都传递给这个布尔函数。如果该函数返回True，这一项保留在返回的可迭代对象中；否则的话，删除该项。简而言之，实际上filter函数让接受的这个可迭代对象的每一项都通过一个测试。</p>
<p>因此，假设已经有了这个布尔函数：isPositive,如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建了一个可迭代对象，其中包含了非零的得分</span><br><span class="line">filter(isPositive, oldList)</span><br><span class="line"># 根据该对象创建了一个新的列表</span><br><span class="line">newList = list(filter(isPositive,oldList))</span><br></pre></td></tr></table></figure>

<h4 id="使用lambda表达式创建匿名函数"><a href="#使用lambda表达式创建匿名函数" class="headerlink" title="使用lambda表达式创建匿名函数"></a>使用lambda表达式创建匿名函数</h4><p>可以临时性地创建一个匿名函数以传递给 map 或 filter，从而避免定义像 isPositive 这样的一次性的辅助函数。<br>lambda表达式形式： <code>lambda &lt;argument list&gt; : &lt;expression&gt;</code><br>注意，这个表达式不能像其他的Python函数那样包含一个语句序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个匿名的布尔函数来从分数的列表删除0分。</span><br><span class="line">newList = list(filter(lambda number : number &gt; 0,oldList))</span><br></pre></td></tr></table></figure>

<p>另一个高阶函数functools.reduce，通过应用带有两个参数的函数来将一个可迭代对象的项转换为单个的值，而该函数的两个参数是下一项和前一次应用该函数的结果。<br>因此，前面展示的计算一个数列的乘积的for循环，也可以写成如下的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个匿名的布尔函数来从分数的列表删除0分。</span><br><span class="line">newList = list(filter(lambda number : number &gt; 0,oldList))</span><br></pre></td></tr></table></figure>

<p>另一个高阶函数functools.reduce，通过应用带有两个参数的函数来将一个可迭代对象的项转换为单个的值，而该函数的两个参数是下一项和前一次应用该函数的结果。<br>因此，前面展示的计算一个数列的乘积的for循环，也可以写成如下的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">product = functools.reduce(lambda x, y : x*y, range(1,11))</span><br></pre></td></tr></table></figure>

<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>当 Python 虚拟机在程序执行的过程中遇到一个语义错误的时候，它抛出一个异常，停止程序并且给出一条错误消息。<br>Python 包含了一条try-except语句，它允许程序捕获异常并执行相应的恢复操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">except &lt;exception type&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br></pre></td></tr></table></figure>

<p>当运行这条语句的时候，try 子句中的语句将会执行。如果这些语句中的一条引发异常，执行将会立即传递到 except 子句。如果所引发的异常的类型和这条子句中的异常类型一致，将会执行其语句。否则，将执行传递到try-except语句的调用者，并且进一步沿着调用链向上传递，直到异常成功地得到处理，或者程序停止并产生一条错误消息。如果 try 子句中的语句没有引发异常，就会跳过except子句，并且执行继续直到try-except语句的末尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Author: Ken Lambert</span><br><span class="line">Demonstrates a function that traps number format errors during input.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def safeIntegerInput(prompt):</span><br><span class="line">    &quot;&quot;&quot;Prompts the user for an integer and returns the</span><br><span class="line">    integer if it is well-formed.Otherwise, prints an </span><br><span class="line">    error message and repeats this process.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    inputString = input(inputString)</span><br><span class="line">    try:</span><br><span class="line">        number = int(inputString)</span><br><span class="line">        return number</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&quot;Error in number format: &quot;inputString)</span><br><span class="line">        return safeIntegerInput(prompt)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    age = safeIntegerInput(&quot;Enter your age: &quot;)</span><br><span class="line">    print(&quot;Your age is &quot;, age)</span><br></pre></td></tr></table></figure>

<h4 id="文件及其操作"><a href="#文件及其操作" class="headerlink" title="文件及其操作"></a>文件及其操作</h4><h5 id="文本文件的输出"><a href="#文本文件的输出" class="headerlink" title="文本文件的输出"></a>文本文件的输出</h5><p>根据文本文件的格式和数据的用途，可以将文本文件中的数据看做是字符、单词、数字或者文本行。当把这些数据当作整数或浮点数的时候，必须用空白符（空格、制表符和换行符）将其分隔开。<br>文本文件的所有数据输出或数据输入都必须是字符串。<br>可以使用文件对象将数据输出到文本文件中。Python中的open函数接受文件的路径名称和模式字符串作为参数，它打开到磁盘上的文件的一个连接，并且返回文件对象。模式字符串’r’表示输入文件，’w’表示输出文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在文件名为&quot;myfile.txt&quot;的文件上打开一个文件对象以进行输出。</span><br><span class="line">f = open(&quot;myfile.txt&quot;,&apos;w&apos;)</span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，会使用给定的路径名称来创建它。如果文件已经存在，Python会打开它。当数据写入到文件并且文件关闭的时候，文件中之前存在的任何数据都会被擦除。<br>使用write方法和文件对象，将字符串数据写入（或输入）到一个文件之中。write方接受单个的字符串参数。如果想要输出文本并且以换行来结束，必须在字符串中包含转义字符’\n’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在文件名为&quot;myfile.txt&quot;的文件上打开一个文件对象以进行输出。</span><br><span class="line">f = open(&quot;myfile.txt&quot;,&apos;w&apos;)</span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，会使用给定的路径名称来创建它。如果文件已经存在，Python会打开它。当数据写入到文件并且文件关闭的时候，文件中之前存在的任何数据都会被擦除。<br>使用write方法和文件对象，将字符串数据写入（或输入）到一个文件之中。write方接受单个的字符串参数。如果想要输出文本并且以换行来结束，必须在字符串中包含转义字符’\n’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将两行文本写入到了文件中</span><br><span class="line">f.write(&quot;First line.\nSecond line.\n&quot;)</span><br><span class="line"># 当所有的输出完成后，应该使用close方法来关闭文件，如果没有成功地关闭输出的文件，将会导致数据丢失。</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="将数字写入到一个文本文件"><a href="#将数字写入到一个文本文件" class="headerlink" title="将数字写入到一个文本文件"></a>将数字写入到一个文本文件</h5><p>文件方法write接受字符串参数。因此，其他类型的数据，如整数或浮点数，必须先转换成为字符串，然后才能写入到输出文件中。在Python中大多数数据类型的值都可以使用str函数来转换字符串。然后，使用空格或换行作为分隔字符，将所得到的字符串写入到文件中。</p>
<h5 id="将数字写入到一个文本文件-1"><a href="#将数字写入到一个文本文件-1" class="headerlink" title="将数字写入到一个文本文件"></a>将数字写入到一个文本文件</h5><p>文件方法write接受字符串参数。因此，其他类型的数据，如整数或浮点数，必须先转换成为字符串，然后才能写入到输出文件中。在Python中大多数数据类型的值都可以使用str函数来转换字符串。然后，使用空格或换行作为分隔字符，将所得到的字符串写入到文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import random </span><br><span class="line">f = open(&quot;integers.txt&quot;,&apos;w&apos;)</span><br><span class="line">for count in range(500):</span><br><span class="line">    number = random.randint(1,500)</span><br><span class="line">    f.write(str(number) + &quot;\n&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="从文本文件读取文本"><a href="#从文本文件读取文本" class="headerlink" title="从文本文件读取文本"></a>从文本文件读取文本</h5><p>打开一个文件进行输入的方式，和打开一个文件进行输出的方式相同。唯一的变化在于模式字符串。在打开文件进行输入的情况下，使用’r’字符串。最简单的方法是使用文件方法read来将整个文件的内容作为一个单独的字符串输入。如果文件包含了多行文本的话，换行字符将会嵌入到这个字符串中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&quot;myfile.txt&quot;,&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; text = f.read()</span><br></pre></td></tr></table></figure>

<p>在输入完成后，再次调用read将会返回一个空的字符串，表明已经到达了文件的末尾。要重复输入，必须再次打开文件。这样的话就不需要关闭该文件了。<br>使用for循环可以让程序每次只读取和处理一行文本。for循环将一个文件对象当作是文本行的一个序列。在每次通过循环的时候，循环变量都跳到序列中的下一行文本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;integers.txt&apos;,&apos;r&apos;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<p>readline 方法只读取一行的输入并且返回该字符串，包括换行符。如果readline遇到了文件的末尾，它会返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;integers.txt&apos;,&apos;r&apos;)</span><br><span class="line">while True:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    if line == &quot;&quot;:</span><br><span class="line">        break</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<h5 id="从文件读取数字"><a href="#从文件读取数字" class="headerlink" title="从文件读取数字"></a>从文件读取数字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ingeger.txt 是用换行符隔开的随机数</span><br><span class="line">f = open(&quot;integers.txt&quot;,&apos;r&apos;)</span><br><span class="line">sum = 0</span><br><span class="line">for line in f:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    number = int(line)</span><br><span class="line">    sum += number</span><br><span class="line">print(&quot;The sum is: &quot;,sum)</span><br></pre></td></tr></table></figure>

<p>从用空格隔开的文本文件中获取数字，则要稍微难一点。一种处理方法是，在一个for循环中读取行，但每一行可能包含空格隔开的几个整数。可以使用字符串方法split来获取表示这些整数的字符串的一个列表，然后使用另一个for循环来处理这个列表中的每一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;integers.txt&quot;,&apos;r&apos;)</span><br><span class="line">sum = 0</span><br><span class="line">for line in f:</span><br><span class="line">    wordlist = line.split()</span><br><span class="line">    for word in wordlist:</span><br><span class="line">          number = int(word)</span><br><span class="line">          sum += number</span><br><span class="line">print(&quot;The sum is :&quot;,sum)</span><br></pre></td></tr></table></figure>

<p>现在文本不必再剔除换行符了，因为split会自动地负责此项工作。</p>
<h5 id="用pickle读写对象"><a href="#用pickle读写对象" class="headerlink" title="用pickle读写对象"></a>用pickle读写对象</h5><p>我们可以将任何对象转换为文本进行存储，但是将复杂的对象映射为文本再映射回来，这个过程很烦，并且会为维护带来难度。Python有个模块，允许程序员使用一个叫做封装（pickling）的工具来保存和加载对象。这个术语源自于把黄瓜变成腌菜以便再罐子里储存的过程。然而，在计算对象的时候，我们还会把腌菜变回为黄瓜。任何对象都可以被封装（pickled），然后再将其保存到文件中，然后，随着你将其从文件中加载到程序中，对它们进行“拆封（unpickled)”。Python自动负责所有的转换细节。<br>首先导入一个pickle模块。使用”rb”和”wb”标志（用于字节流）来打开文件以进行输入和输出，并且以常用的方式来关闭文件。要保存对象，就使用pickle.dump函数。它的第一个参数是要”转储“或者说要存储到文件中的对象，其第二个参数是一个文件对象。<br>例如，可以使用pickle模块将一个名为lyst列表中的对象保存到一个名为item.dat的文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">lyst = [60, &quot;A string object&quot;, 1977]</span><br><span class="line">fileObj = open(&quot;items.dat&quot;,&quot;wb&quot;)</span><br><span class="line">for item in lyst:</span><br><span class="line">        pickle.dump(item,fileObj)</span><br><span class="line">fileObj.close()</span><br></pre></td></tr></table></figure>

<p>这个示例中，也可以将整个列表写入到一个文件中，而不是将其每个对象写入到文件中。<br>可以使用pickle.load函数，将封装的对象从一个文件加载到一个程序中。如果到达了文件的末尾，这个函数会引发一个异常。这使得输入过程复杂化了，因为在引发异常之前，没有明确的方法来检查是否达到了文件末尾。但是使用try-except语句解决这一问题。<br>现在，可构建一个输入文件循环来持续地加载对象，直到达到文件的末尾，此时引发一个EOFError。随后，except子句将会关闭文件并且退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#从item.dat文件中将对象加载到一个新的、名为lyst的列表中：</span><br><span class="line">import pickle</span><br><span class="line">lyst = list()</span><br><span class="line">fileObj = open(&quot;items.dat&quot;,&quot;rb&quot;)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        item = pickle.load(fileObj)</span><br><span class="line">        lyst.append(item)</span><br><span class="line">    except EOFError:</span><br><span class="line">        fileObj.close()</span><br><span class="line">        break</span><br><span class="line">print(lyst)</span><br></pre></td></tr></table></figure>

<h5 id="创建新的类"><a href="#创建新的类" class="headerlink" title="创建新的类"></a>创建新的类</h5><p>类描述了数据和一组相关对象方法。类提供了一个蓝图，可以用来创建对象以及在这些对象上调用方法的时候所执行的代码。Python中所有的数据类型都是类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#定义Python类</span><br><span class="line">calss &lt;class name&gt;(&lt;prarent class name&gt;):</span><br><span class="line">    &lt;class variable assignments&gt;</span><br><span class="line">    &lt;instance method definitions&gt;</span><br></pre></td></tr></table></figure>

<p>按照惯例，类名是要大写的。类定义的代码通常放在模块中，该模块的文件名和类名一样，但是是小写的。相关的类也可以出现在同一个模块中。<br>父类名是可选的，在这种情况下，会假设它是object。所有的Python类都位于层级中，object在这个层级的根部，有几个方法如<strong>str</strong>和<strong>eq</strong>均定义于object中，并且是所有的子类都会自动继承的。<br>实例方法在类的对象之上运行，它们包含了访问或修改实例变量的代码。实例变量引用了单个对象所拥有的存储。<br>类变量引用了类的所有对象共同拥有的存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Counter(object):</span><br><span class="line">    &quot;&quot;&quot;Models a counter&quot;&quot;&quot;</span><br><span class="line">    # Class variable</span><br><span class="line">    instances = 0</span><br><span class="line"></span><br><span class="line">    # Constructor</span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot; Set up the counter.&quot;&quot;&quot;</span><br><span class="line">        Counter.instances += 1</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    # Mutator methods</span><br><span class="line">    def reset(self):</span><br><span class="line">        &quot;&quot;&quot;Sets the counter to 0.&quot;&quot;&quot;</span><br><span class="line">        self._value = 0</span><br><span class="line"></span><br><span class="line">    def increment(self, amount=1):</span><br><span class="line">        &quot;&quot;&quot; Add amount to the counter.&quot;&quot;&quot;</span><br><span class="line">        self._value += amount</span><br><span class="line"></span><br><span class="line">    def decrement(self, amount=1):</span><br><span class="line">        &quot;&quot;&quot; Subtracts amount from the counter.&quot;&quot;&quot;</span><br><span class="line">        self._value -= amount</span><br><span class="line"></span><br><span class="line">    # Acessor methods</span><br><span class="line">    def getValue(self):</span><br><span class="line">        &quot;&quot;&quot;Returns the counter&apos;s value.&quot;&quot;&quot;</span><br><span class="line">        return self._value</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        &quot;&quot;&quot;Returns the string representation of the counter.&quot;&quot;&quot;</span><br><span class="line">        return str(self._value)</span><br><span class="line"></span><br><span class="line">    def __eq__(self, other):</span><br><span class="line">        &quot;&quot;&quot;Returns True if self equals other</span><br><span class="line">        or False otherwise.&quot;&quot;&quot;</span><br><span class="line">        if self is other:</span><br><span class="line">            return True</span><br><span class="line">        if type(self) != type(other):</span><br><span class="line">            return False</span><br><span class="line">        return self._value == other._value</span><br></pre></td></tr></table></figure>

<p>Counter 是object的一个子类。<br>类变量instances记录了创建的Counter对象的数目。除了最初在通过赋值引入类变量的时候之外，在其他时候，类变量必须有一个类名作为其前缀。<br>定义实例的语法与定义函数的语法是相同的。然而有一个额外的self参数，它总是出现在参数列表的开始处。在一个方法定义的上下文中，self引用的是在其上运行该方法的对象。<br>实例化方法<strong>init</strong>也叫作构造方法，当创建Counter的实例的时候，会自动运行其构造方法。该方法初始化了实例变量，并且更新了类变量。<br>修改器（mutator）方法通过修改对象的实例变量，来修改或改变对象的内部状态。访问器（accessor)方法直接查看或使用对象的实例变量的值，而不会修改它们。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/14/2019-4-24-小球回弹/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/14/2019-4-16-Keras FAQ/" rel="prev" title="Keras FAQ">
                Keras FAQ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-数据结构第一章"><span class="nav-number">1.</span> <span class="nav-text">Python 数据结构第一章</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写新的函数"><span class="nav-number">1.1.</span> <span class="nav-text">编写新的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归函数"><span class="nav-number">1.1.2.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套的函数定义"><span class="nav-number">1.1.3.</span> <span class="nav-text">嵌套的函数定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高阶函数"><span class="nav-number">1.1.4.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用lambda表达式创建匿名函数"><span class="nav-number">1.1.5.</span> <span class="nav-text">使用lambda表达式创建匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获异常"><span class="nav-number">1.1.6.</span> <span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件及其操作"><span class="nav-number">1.1.7.</span> <span class="nav-text">文件及其操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文本文件的输出"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">文本文件的输出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将数字写入到一个文本文件"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">将数字写入到一个文本文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将数字写入到一个文本文件-1"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">将数字写入到一个文本文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从文本文件读取文本"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">从文本文件读取文本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从文件读取数字"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">从文件读取数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用pickle读写对象"><span class="nav-number">1.1.7.6.</span> <span class="nav-text">用pickle读写对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建新的类"><span class="nav-number">1.1.7.7.</span> <span class="nav-text">创建新的类</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

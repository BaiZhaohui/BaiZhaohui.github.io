<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Mist">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mist">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mist">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Mist</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mist</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（侯捷笔记3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（侯捷笔记3)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>静态数据只有一份。静态数据需要在类外做定义，给不给初值均可。<br>静态函数没有this指针，只能处理静态数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span>&#123;m_data = x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">9.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      Account::set_rate(<span class="number">5.0</span>);</span><br><span class="line">      </span><br><span class="line">      Account a;</span><br><span class="line">      a.set_rate(<span class="number">7.0</span>);<span class="comment">// a 的地址不会传入函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用静态函数有两种方式：1.通过类名调用。2.通过对象调用。</span></span><br></pre></td></tr></table></figure>

<h2 id="单例模式-把构造函数放在private区域"><a href="#单例模式-把构造函数放在private区域" class="headerlink" title="单例模式 把构造函数放在private区域"></a>单例模式 把构造函数放在private区域</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">static</span> A&amp; <span class="title">getInstance</span><span class="params">(<span class="keyword">return</span> a;)</span></span>;</span><br><span class="line">      setup() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      A();</span><br><span class="line">      A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">      <span class="keyword">static</span> A a ;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::getInstance().setup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改进：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      static A&amp; getInstance());</span><br><span class="line">      setup() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      A();</span><br><span class="line">      A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line">A&amp; A::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">static</span> A a ;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::getInstance().setup();</span><br></pre></td></tr></table></figure>

<h2 id="class-template，类模板"><a href="#class-template，类模板" class="headerlink" title="class template，类模板"></a>class template，类模板</h2><p><code>template&lt;typename T&gt;</code></p>
<h2 id="function-template，函数模板"><a href="#function-template，函数模板" class="headerlink" title="function template，函数模板"></a>function template，函数模板</h2><p><code>template&lt;class T&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（MOOC)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（MOOC)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们调用一个函数的时候，会在内存中建立起一块特殊区域，称为“程序栈（program stack）”。程序栈提供了每个函数参数的储存空间。它也提供函数所定义的每个对象的内存空间——我们将这些对象称为 local object（局部对象）。一旦函数完成，这块内存就会被释放掉，或者说从程序堆栈中被pop出来。<br>当我们将vec[ix]这样的对象传入函数时，默认情形下其值会被复制一份，成为参数的局部性定义（local definition）。这种方式称为pass by value（传值）。我们在bubble_sort()内传给swap()的对象，和我们在swap()内操作的对象，其实是没有任何关联的两组对象。为了让程序正确运行，必须通过某种方法，令swap()的参数和传入的实际对象产生关联。即所谓的pass by reference （传址）。最简单的做法便是将参数声明为一个reference：在型别名称和reference名称之间插入&amp;符号，便声明了一个reference。<br>C++不允许改变references所代表的对象，他们必须从一而终。面对reference的所有操作都像面对“reference”所代表之对象所进行的操作一般无二。以reference作为函数参数时，亦复如此。<br>以by reference 方法传递对象当作函数参数，对象本身并不会复制出另一份——复制的是对象的地址。函数中对该对象进行的任何操作，都相当于是对传入的对象进行间接操作。将参数声明为reference的另一个理由是降低复制大型对象的负担。</p>
<p>也可以将vector以pointer形式传递。这和以reference传递的效果作用相同：传递的是对象地址，而不是整个对象的复制品。唯一的差别在于reference和pointer的用法不同。</p>
<p>pointer 参数和reference 参数更重要的差异是：pointer可能（也可能不）指向某个实际对象。当我们提领pointer时，一定要先确定其值非0。而reference则必定会代表某个对象，所以无需做此检查。reference不可以置为0。</p>
<p>一般来说，除非希望在函数内更改参数值，否则在传递内建型别时，不要使用传址方式，传址机制主要是作为传递 class object 之用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(size&lt;=<span class="number">0</span> || size&gt;<span class="number">1024</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">"Warning: fibon_seq():"</span></span><br><span class="line">    &lt;&lt; size &lt;&lt; <span class="string">"not supported -- resetting to 8\n"</span>;</span><br><span class="line">    size = <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; elems(size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ix=<span class="number">0</span>;ix&lt;size;++ix)</span><br><span class="line">      <span class="keyword">if</span> (ix ==<span class="number">0</span> || ix==<span class="number">1</span>)</span><br><span class="line">        elems[ix]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        elems[ix] = elems[ix<span class="number">-1</span>] + elems[ix<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论以pointer或reference形式将elems返回，都不正确，因为elems在fibon_seq()执行完毕时已不复存在。如果将elems以传值方式返回，便不会产生任何问题；因为返回的乃是对象的复制品，它在函数之外依然存在。</p>
<p>为对象配置的内存，其存活期称为储存期（storage duration） 或范围（extent）。每次fibon_seq()执行起来，都会为elems配置内存，每当fibon_seq()终了便会加以释放。我们称此对象具有局部性范围（local extent）。函数参数便有局部性范围。</p>
<p>对象在程序中存活区域称为该对象的 scope（生存空间）。size 和 elems 在fibon_seq()函数内拥有local scope。若某个对象仅具有local scope（局部性生存空间），其名称在local scope之外便不可视。<br>对象如果在函数之外声明，则具有 file scope。对象如果拥有file scope，则从其声明点至文件尾端都是可视的。file scope内的对象亦具备所谓的 static scope，意谓该对象的内存在main()开始执行之前便已经配置好了，可以一直存在至程序结束为止。</p>
<p>内建型别的对象，如果定义在file scope之内，必定被初始化为0。但如果它们被定义于local scope之内，那么除非程序员指定其初值，否则不会被初始化。<br>file scope 对象会打乱不同函数间的独立性，使它们难以理解。</p>
<h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><p>不论local scope 或者是file extent，都由系统自动管理。第三种存储期形式称为 dynamic extent（动态范围）。其内存由程序的自由空间（free store）配置而来，有时也称为heap memory（堆内存）。此种内存必须由程序员自行管理，其配置是通过new 表达式来达成的，释放通过delete表达式完成。</p>
<p>new Type:<br>Type 可以为任意内建型别，也可以是程序知道的class型别。new 表达式亦可写为：<br>new Type(initial_value);<br>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

<p>先由heap 配置出一个型别为int 的对象，再将其地址赋值给pi。默认情形下，由heap配置而来的对象，皆为经过初始化。new表达式的另一种形式允许我们指定初值，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>同样是先由heap配置出一个类型为int的对象，再将其地址赋值给pi，但这个对象的值会被初始化为1024.<br>从heap中配置数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">24</span>];</span><br></pre></td></tr></table></figure>

<p>从heap中配置一数目组，拥有24个整数。pia会被初始化为数组第一个元素的地址。数组中的每个元素都未经过初始化。C++ 没有提供任何语法让我们得以从heap配置数组的同时为其元素设定初值。<br>从heap配置而来的对象，被称为具有dynamic extent，因为它们是在执行期通过 new 表达式配置来的，因此可以持续存活，直到以 delete 表达式加以释放为止。下面的 delete 表达式会释放Pi所指的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete pi;</span><br></pre></td></tr></table></figure>

<p>如果要删除数组中的所有对象，必须在数组指针和delete表达式之间，加上一个空的下标运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<p>注意，无需检验pi是否非零：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (pi!=0) // 多此一举——编译器会提我们检查</span><br><span class="line">  delete pi;</span><br></pre></td></tr></table></figure>

<p>以“参数传递”作为函数间的沟通方式，比“直接将对象定义于file scope”更适当。理由之一是，函数如果过度依赖定义于file scope内的对象，就比较难以在其他环境中被重复使用，也比较难以修改——我们不仅需要了解该函数的运行逻辑，也必须了解定义于file scope中的那些个对象的运行逻辑。</p>
<p>通常将参数默认值置于函数声明处。</p>
<h4 id="局部静态对象（Local-Static-Objects）"><a href="#局部静态对象（Local-Static-Objects）" class="headerlink" title="局部静态对象（Local Static Objects）"></a>局部静态对象（Local Static Objects）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *</span><br><span class="line">fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elems;</span><br><span class="line">	<span class="comment">// 函数的运行逻辑置于此处</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此刻的elems被定义为fibon_seq()中的局部静态对象。局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在。elems 的内容不再像以前一样地于fibon_seq()每次被调用时就被破坏又被重新建立。这也是为什么现在我们可以安全地将elems的地址返回的原因。<br>局部静态对象使我们可以定义一个含有Fibonacci数列的vector，每当调用fibon_seq()时，只需计算那些尚未被置入elems的元素即可。</p>
<p>将函数声明为 inline ，表示要求编译器在每个函数调用点上，将函数的内容展开。面对一个inline函数，编译器可将该函数的调用操作改以一份函数码副本取而代之。这使我们获得效率上的改善，其结果等于是把三个函数写入 fibon_elem()内，但依然维持3个独立的运算单元。</p>
<p>在函数前面加上关键词 inline ,便可将该函数声明为 inline 。将函数指定为inline，只是对编译器提出的一种要求，编译器是否执行这项请求，需视编译器而定。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>function overloading<br>参数表（parameter list）不相同（可能是参数型别不同，也可能是参数数目不同）的两个或多个函数，可以拥有相同的函数名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器将调用者提供的实际参数拿来和每个重载函数的参数比较，找出其中最适当的。这也就是为什么每个重载函数的参数必须和其它重载函数的参数表不同的原因。</p>
<p>编译器无法根据函数返回值类型来区分两个具有相同名称的函数，以下便是不正确的写法，会产生编译错误：<br>//错误：参数表（而非返回值的型别）必须不同。<br>ostream&amp; display_message(char ch);<br>bool display_message(char ch);<br>因为返回值型别无法保证提供我们一个足以区分不同重载函数的情境。</p>
<p>将一组实现代码不同但工作内容相似的函数加以重载，可以让函数用户更容易使用这些函数。如果没有重载机制，我们就得为每个函数提供不同的名称。</p>
<h4 id="定义并使用-Template-Functions（模板函数）"><a href="#定义并使用-Template-Functions（模板函数）" class="headerlink" title="定义并使用 Template Functions（模板函数）"></a>定义并使用 Template Functions（模板函数）</h4><p>将单一函数的内容与希望显示的各种vector型别捆绑（bind）起来。<br>function template 将参数表中指定的所有（或部分）参数的型别信息抽离出来。在display_message()例子中，我们希望将vector 所持元素的型别抽离出来，于是就可以定义出一份不需再有任何更改的模板（template）。不过，这样还不完整，因为我们遗漏了抽离出来的型别信息。这份型别信息由用户提供——当他决定采用 function template 的某个实体时提供。<br>function template 以关键词 template 开场，其后紧接着以成对尖括号（&lt;&gt;）包围起来的一个或多个识别名称，这些名称用以表示我们希望延缓决定的数据型别。每当用户利用模板（template）产生函数时，他就必须提供确实的型别信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;elemType&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ix =<span class="number">0</span>;ix&lt;vec.size();ix++)</span><br><span class="line">    &#123;</span><br><span class="line">      elemType t = vec[ix];</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; t &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键词 typename 表示，elemType 在display_message() 函数中乃是一个临时放置型别的代称。elemType 只是个任意名称，也可以用foobar 或 T 之类的名称。</p>
<p>在我们编译程序时，实际过程模板会被编译两次。 </p>
<ul>
<li>首先，对模板代码检查语法（如缺少分号）等语法错误。 </li>
<li>然后，实例化时，即调用模板函数时检查模板函数中的操作是否支持该类型。</li>
</ul>
<p>模板参数的个数可是任意个，但是不能为模板参数指定默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T1 <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a; </span><br><span class="line">&#125; </span><br><span class="line">… </span><br><span class="line">max(<span class="number">4</span>,<span class="number">4.2</span>)   <span class="comment">// OK, but type of first argument defines return type</span></span><br></pre></td></tr></table></figure>

<p>上面的例子看起来很好，但是有问题。首先，返回类型必须被声明。如果返回类型是其中的一个模板参数类型，另一个参数类型就可能被转换成返回的类型。另外一个问题，把第二个类型转换为第一个类型会产生局部临时对象，那么就不能使用引用的方式（by reference）传回结果。因此上面的例子中，返回的类型是T1 而不是 T const&amp;</p>
<p>由于调用参数（call parameters ）是由模板参数（template parameters）构造的，所以两者是相关的。我们把这种概念称为：函数模板参数推导。有了推导，就可以像调用普通函数那样调用函数模板。 </p>
<p>如之前的例子，调用时为函数模板显示指定类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// instantiate T as double</span></span><br></pre></td></tr></table></figure>

<p>当模板参数和调用参数没有直接关系，且编译器也无法推导出模板参数时，就需要明确的指定模板参数了。如，可以为max()指定第三个模板参数类型作为返回参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span><span class="params">(T1 <span class="keyword">const</span>&amp; a,T2 <span class="keyword">const</span>&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而，推导机制并不会对返回类型进行匹配，而且模板参数RT也不在调用参数中。因此，编译器无法推导出RT，调用时就必须显示指定类型，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// OK, but tedious</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，调用时要么不需要指定参数完全由编译器推导，要么就要把所有的参数多显示指定了。<br>当然，还有一种方法只明确的指定第一个模板参数，其它的参数由编译器自动推导。<br>如下：RT要放在第一个参数的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// OK: return type is double</span></span><br></pre></td></tr></table></figure>

<p>函数模板重载（Overloading Function Templates）<br>和普通的函数一样，函数模板也是可以重载的。<br>函数重载：不同的函数的定义可以有相同的函数名，当函数被调用的时候由编译器判断使用哪个函数。<br>如下，函数模板重载的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maximum of two int values</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span>&amp; a, <span class="keyword">int</span> <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maximum of two values of any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maximum of three values of any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b, T <span class="keyword">const</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> max(max(a, b), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	::max(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>);     <span class="comment">// calls the template for three arguments </span></span><br><span class="line">	::max(<span class="number">7.0</span>, <span class="number">42.0</span>);     <span class="comment">// calls max&lt;double&gt; (by argument deduction) </span></span><br><span class="line">	::max(<span class="string">'a'</span>, <span class="string">'b'</span>);      <span class="comment">// calls max&lt;char&gt; (by argument deduction) </span></span><br><span class="line">	::max(<span class="number">7</span>, <span class="number">42</span>);         <span class="comment">// calls the nontemplate for two ints </span></span><br><span class="line">	::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>);       <span class="comment">// calls max&lt;int&gt; (by argument deduction) </span></span><br><span class="line">	::max&lt;<span class="keyword">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argument deduction) </span></span><br><span class="line">	::max(<span class="string">'a'</span>, <span class="number">42.7</span>);     <span class="comment">// calls the nontemplate for two ints </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，非模板函数可以和同名的函数模板同时存在，也可以和相同类型的函数模板实例同时存在。当所有的条件都相同时，编译器会优先选择非模板函数。<br>因此上面的第四个调用的是非模板函数。</p>
<p>调用时可以使用空的模板参数列表”&lt;&gt;”,这种形式告诉编译器必须使用从函数模板的实例，且模板参数由调用参数自动推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>)    <span class="comment">// calls max&lt;int&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure>

<p>由于模板是不能进行自动类型转换的，而普通函数是可以自动类型转换，所有最后一个调用的是非模板函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="string">'a'</span>, <span class="number">42.7</span>)      <span class="comment">// only the nontemplate function allows different argument types</span></span><br></pre></td></tr></table></figure>

<p>如果表头文件和含入此文件的程序代码文件位于同一个驱动器目录下，我们便使用双引号。如果在不同的驱动器目录下，我们便使用尖括号。<br>如果此文件被认定为标准的、或项目专属的头文件，我们便以尖括号将文件名括住；编译器搜寻此文档时，会先在某些默认的驱动器目录中找寻，如果文件名由成对的双括号括住，此文件便被认为是一个用户自行提供的头文件；搜寻此文件时，会由含入此文件之文件所在的驱动器目录开始找起。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（C++ADT)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（C++ADT)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>编写程序前，需要清楚地了解如何通过程序来实现索要完成的任务。 编写代码前，应列出程序的提纲（项目越大，越复杂，提纲应越详细），包括其需求。</p>
<p>实现的细节，应该在一个项目的后期完成，实现阶段要用到的详细数据结构更不应该在一开始就指定。</p>
<p>在刚开始的时候，最重要的是每项任务的输入输出。开始阶段应该关心程序需要什么，而不是如何去做。程序的行为比实现程序的机制更重要。如某个项需要完成一些任务，那么应该指定在这个项上进行的操作，而不是指定这个项的内部结构。这些操作是基于这个项的。当明确这些操作之后，就可以开始实现这个程序了。实现决定应该使用哪种数据结构，从而达到更好的时间以及空间执行效率。指定了操作的项被称为抽象数据类型（ADT）。</p>
<p>抽象数据类型不是程序的一部分，因为程序需要定义数据结构，而不只是数据结构上执行的操作。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>OOP以对象为中心，而对象是用类来定义的。类是一个模板，对象根据类来创建。类是软件的一部分，包括数据的说明以及对数据执行的操作，还可能包含对其他类数据的操作。<br>类中定义的函数称为方法，或者成员函数或者函数成员，类中使用的变量称为数据成员。<br>数据及其相关操作的结合称为数据封装。<br>对象是类的实例，是用类定义创建的实体。  </p>
<p>与非面向对象语言中的函数比，对象使数据和成员函数之间的结合更加紧密，更有意义。在非面向对象编程语言中，数据的声明和函数定义分散在整个程序中，只有程序文档才能说明它们之间存在联系。而OOL中，联系在一开始就建立起来了；事实上，这种联系是程序的基础。对象是由相互关联的数据和操作定义的，同一个程序中可能会有很多对象，对象通过传递消息来相互通信，为了更为充分的通信，需要泄露对象一些内部细节。基于对象的结构化编程可以完成多个目标。</p>
<p>首先，数据与操作之间的强耦合关系在实际的建模过程中非常有用，软件工程尤其强调这一点。<br>其次，对象便于查找错误，因为操作都只限于它们的对象。即使有副作用也容易跟踪。<br>第三，对象可以对其他对象隐藏某些操作细节。从而使得这些操作不会受到其他对象的影响，这就是所谓的信息隐藏原则。</p>
<p>对象就像是一个黑盒子，其行为有明确的定义，我们使用对象是因为知道其功能，而不是因为了解其内部运行机制。对象的这种不透明性对于保持其独立性是非常有用的。如果恰当的定义了对象之间的通信管道，那么只有当对象中的改变影响到通信管道时，才会影响其他对象。在了解了对象发出和收到的信息之后，可以方便地用某个在特殊情况下更为合适的对象取代当前对象。</p>
<p>信息隐藏往往容易模糊数据和操作的界限。</p>
<p>C++能够在类声明中使用类型参数来声明通用类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class genType&gt;</span><br><span class="line">class genClass&#123;</span><br><span class="line">  genType storage[50];</span><br><span class="line">  ..............</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>  此后才会决定如何初始化genType:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">genClass&lt;int&gt; intObject;</span><br><span class="line">genClass&lt;float&gt; floatObject;</span><br></pre></td></tr></table></figure></p>
<p>这个通用类是生成两个新类（int类型的genClass和float类型的genClass）的基础，然后使用这两个类创建了两个对象intObject和floatObject。通过这种方式，通用类可以根据特定的声明以各种不同的形式出现，一个通用声明就足以使类具有不同的形式。</p>
<p>让storage数组大小可选：</p>
<pre><code>template&lt;class genType,int size = 50&gt;
class genClass{
  genType storage[size];
};

genClass&lt;int&gt; intObject1; // use the default size;
genClass&lt;int,100&gt; intObject2;
genClass&lt;float,123&gt; floatObject;</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（DSIPy)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（DSIPy)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><p>时间复杂度的几条基本计算规则</p>
<ol>
<li>基本操作，即只有常数项，认为其时间复杂度为O(1)。</li>
<li>顺序结构，时间复杂度按加法进行计算</li>
<li>循环结构，时间复杂度按乘法进行计算</li>
<li>分支结构，时间复杂度取最大值</li>
<li>判断一个算法的效率时，往往只需要关注操作数量的最高次项，其他次项和常数项可以忽略。</li>
<li>无特殊说明时，算法的时间复杂度均指最坏时间复杂度。</li>
</ol>
<p>常见时间复杂度的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</span><br></pre></td></tr></table></figure>

<h3 id="Python内置类型性能分析"><a href="#Python内置类型性能分析" class="headerlink" title="Python内置类型性能分析"></a>Python内置类型性能分析</h3><p>timeit 模块可以用来测试一小段Python代码的执行速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class timeit.Timer(stmt=&apos;pass&apos;,setup=&apos;pass&apos;,timer=&lt;timer function&gt;)</span><br></pre></td></tr></table></figure>

<p>Timer是测量小段代码执行速度的类；<br>stmt参数是要测试的代码语句（statement）；<br>setup参数是运行代码时需要的设置；<br>timer参数是一个定时器函数，与平台有关。</p>
<p>timeit.Timer.timeit(number=100000)<br>Timer类中测试语句执行速度的对象方法，number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p>
<p>数据结构静态描述了数据元素之间的关系。高效的程序需要在数据结构的基础上设计和选择算法。<br>程序 = 数据结构 + 算法<br>总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。</p>
<h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><p>抽象数据类型指一个数学模型以及定义在这个模型上的一组操作。即把数据类型和数据类型上的运算捆绑在一起，进行封装。引入ADT的目的是为了把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。</p>
<p>地址所占用的内存空间大小一致。</p>
<p>选择排序算法不具有稳定性（考虑升序，每次选最大的情况）。<br>冒泡排序具有稳定性。<br>插入排序具有稳定性。<br>希尔排序不具有稳定性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（侯捷笔记)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（侯捷笔记)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="侯捷1"><a href="#侯捷1" class="headerlink" title="侯捷1"></a>侯捷1</h1><ul>
<li>class without pointer members<ul>
<li>Complex</li>
</ul>
</li>
<li>class with pointer members<ul>
<li>String  </li>
</ul>
</li>
</ul>
<p>complex.h<br>防卫式声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__   </span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件布局</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__   </span></span><br><span class="line">________________________________________________</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span>                                                                <span class="title">forward</span> <span class="title">declarations</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">complex</span>                                                               前置声明</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">complex</span>&amp;</span></span><br><span class="line"><span class="class">    __<span class="title">doap1</span>(<span class="title">complex</span>* <span class="title">ths</span>,<span class="title">const</span> <span class="title">complex</span>&amp; <span class="title">r</span>);</span></span><br><span class="line">________________________________________________</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">________________________________________________</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">                                                                                    <span class="class"><span class="keyword">class</span> <span class="title">declarations</span></span></span><br><span class="line"><span class="class">........................................                                                    类-声明</span></span><br><span class="line"><span class="class">&#125;                                                               </span></span><br><span class="line"><span class="class">________________________________________________</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">________________________________________________</span></span><br><span class="line"><span class="class"><span class="title">complex</span> :</span>: function...                                                     <span class="class"><span class="keyword">class</span> <span class="title">definition</span> 类定义</span></span><br><span class="line"><span class="class">________________________________________________</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br></pre></td></tr></table></figure>

<p>不带指针的类，大多数情况不需要写析构函数。 </p>
<p>构造函数放在private区域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Singleton</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">  static A&amp; getInstance();</span><br><span class="line">  setup()&#123;...&#125;</span><br><span class="line">private:</span><br><span class="line">   A():</span><br><span class="line">   A(const A&amp; rhs);</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A&amp; A::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">  static A a;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同class的各个objects互为friends（友元）<br><img src=":storage%5Ce085efcd-aaff-4f6d-94a3-107cbd04e949%5C5194a5f0.png" alt="5194a5f0.png"></p>
<p>类定义：<br> 1.数据一定在private里。2.传参最好以传引用的方式。（注意加不加const）3.返回值也尽量以引用来传递。5.构造函数最好使用initialization list。</p>
<p>如果在一个函数内部创建了一个新的变量，并且将其引用返回，实际上达不到理想的效果，因为函数结束后，临时创建的新的变量就消失了，所以它的引用也没有了本来的意义。</p>
<h2 id="operator-overloading（操作符重载-1，成员函数）-this"><a href="#operator-overloading（操作符重载-1，成员函数）-this" class="headerlink" title="operator overloading（操作符重载-1，成员函数） this"></a>operator overloading（操作符重载-1，成员函数） this</h2><p>任何的成员函数都有一个隐藏的this指针。this指针指向调用者。</p>
<p>return by reference 语法分析<br>传递者无需知道接收者是以reference形式接收</p>
<h2 id="operator-overloading（操作符重载-2，非成员函数）-无this"><a href="#operator-overloading（操作符重载-2，非成员函数）-无this" class="headerlink" title="operator overloading（操作符重载-2，非成员函数） 无this"></a>operator overloading（操作符重载-2，非成员函数） 无this</h2><p>temp object（临时对象） typename();</p>
<p>String class<br>如果类里面带指针，拷贝构造函数一定要自己写。<br>big three: 拷贝构造，拷贝赋值，析构函数<br>class with pointer members 必须有 copy ctor 和 copy op=，否则可能造成内存泄漏 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（侯捷笔记2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（侯捷笔记2)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="所谓stack，所谓heap"><a href="#所谓stack，所谓heap" class="headerlink" title="所谓stack，所谓heap"></a>所谓stack，所谓heap</h1><p>Stack，是存在于某作用域（scope）的一块内存空间（memory space）。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。<br>在函数本体（function body）内声明的任何变量，其所使用的内存块都取自上述stack。</p>
<p>Heap，或称system heap，是指由操作系统提供的一块global内存空间，程序可动态分配（dynamic allocated）从其中获得若干区块（blocks）。<br>class Complex<br>…<br>{<br>  Complex c1(1,2);        // c1 所占用的空间来自stack<br>  Complex* p = new Complex(3);Complex（3）是个临时对象，其所占用的空间乃是以new的方式动态分配取得，并由p指向<br>  }</p>
<p>  stack object 的生命期<br>  c1 便是所谓stack object，其生命在作用域（scope）结束之际结束。这种作用域内的object，又称为auto object，因为它会被“自动”清理。</p>
<p>  static local objects 的生命期<br>  static Complex c2(1,2);  c2便是所谓static object，其生命在作用域（scope）结束之后仍然存在，直到整个程序结束。</p>
<p>  global objects 的生命期<br>  class Complex{}<br>  Complex c3(1,2);<br>  int main()<br>  {}</p>
<p>  c3 便是global object，其生命在整个程序结束之后才结束，可以将其视为一种static object，其作用域是“整个程序”。</p>
<p>  new: 先分配memory，再调用ctor</p>
<p>  Complex* pc = new Complex(1,2);<br>  编译器转化为：<br>  Complex *pc;</p>
<ol>
<li>void* mem = operator new(sizeof(Complex)); -&gt;其内部调用malloc(n)； // 分配内存</li>
<li>pc = static_cast&lt;Complex*&gt;（mem); // 转型</li>
<li>pc-&gt;Complex::Complex(1,2);// 构造函数 -&gt;Complex::Complex(pc,1,2);</li>
</ol>
<p>delete: 先调用dtor，再释放memory</p>
<p>String* ps = new String(“hello”);<br>…<br>delete ps;</p>
<p>编译器转化为：String::~String(ps);//析构函数<br>operator delete(ps); //释放内存 -&gt;其内部调用free(ps)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-19-Python Objects Types and Expressions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-19-Python Objects Types and Expressions/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="The-Python-environment"><a href="#The-Python-environment" class="headerlink" title="The Python environment"></a>The Python environment</h2><p>read-evaluate-loop</p>
<p>「读取-求值-输出」循环（英语：Read-Eval-Print<br>Loop，简称REPL）是一个简单的，交互式的编程环境。这个词常常用于指代一个Lisp的交互式开发环境，但也能指代命令行的模式和例如APL、BASIC、Clojure、F#、Haskell、J、Julia、Perl、PHP、Prolog、Python、R、Ruby、Scala、Smalltalk、Standard ML、Swift、Tcl、Javascript这样的程序语言所拥有的类似的编程环境。这也被称做交互式顶层构件（interactive toplevel）。</p>
<h2 id="Variables-and-expressions"><a href="#Variables-and-expressions" class="headerlink" title="Variables and expressions"></a>Variables and expressions</h2><p>To translate a real-world problem into one that can be solved by an algorithm,there are two interrelated tasks.</p>
<ul>
<li>Firstly.select the variables,-</li>
<li>and secondly,find the expressions that relate to these variables.</li>
</ul>
<p>Variables are labels attached to objects;they are not the object itself.</p>
<p>They are not containers for objects either.<br>A variable does not contain the object,rather it acts as a pointer or reference to an object.</p>
<p>Pyhton is a dynamically typed language.</p>
<p>Variable names can be bound to different values and types during program execution.</p>
<p>Variables, or more specifically the objects they point to, can change type depending on the values assigned to them.</p>
<h3 id="Variable-scope"><a href="#Variable-scope" class="headerlink" title="Variable scope"></a>Variable scope</h3><p>Each time a function executes,a new local namespace is created.This represents a local environment that contains the names of the parameters and variables that are assigned by the function.</p>
<p>To resolve a namespace when a function is called,the Python interpreter first searches the local namespace(that is ,the function itself) and if no match is found,it searches the global namespace.This global namespace is the module in which the function was defined.If the name is still not found,it searches the built-in namespace.Finally,if this fails then the interpreter raises a NameError ecception.</p>
<h3 id="Flow-control-and-iteration"><a href="#Flow-control-and-iteration" class="headerlink" title="Flow control and iteration"></a>Flow control and iteration</h3><h3 id="Overview-of-data-types-and-objects"><a href="#Overview-of-data-types-and-objects" class="headerlink" title="Overview of data types and objects"></a>Overview of data types and objects</h3><p><strong>Python contains 12 built-in data types.</strong></p>
<p>These include four numeric types(int,float,complex,bool),four sequence types(str,list,tuple,range),one mapping type(dict),and two set types.</p>
<p><strong>All data types in Python are objects.</strong></p>
<p>Each object in Python has a type,a value,and an identity.The identity of an object acts as a pointer to the object’s location in memory.</p>
<p>The type of an object,also known as the object’s class,describes the object’s internal representation as well as the methods and operations it supports.</p>
<p>Once an instance of an object is created,its identity and type cannot be changed.</p>
<p>We can get the identity of an object by using the built-in function id().This returns an identifying integer and on most systems this refers to its memory location, although you should not rely on this in any of your code.</p>
<p>Mutable object’s such as lists can have their values changed.They have methods,such as insert() or append(),that change an objects value.</p>
<p>Immutable objects,such as  strings,cannot have their values changeed,so when we run their methods,they simply return a value rather than change the value of an underlying objet.</p>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>Strings are immutable sequence objects,with each character representing an element in the sequence.</p>
<p>s.count(substring,[start,end])<br>Counts the occurrences of a substring with optional start and end parameters.</p>
<p>s.expandtabs([tabsize])<br>Replaces tabs with spaces.</p>
<p>s.find(substring,[start,end])<br>Returns the index of the first occurrence of a substring or returns -1 if the substring is not found.</p>
<p>s.isalnum()<br>Returns True if all characters are alphanumeric,returns False otherwise. # alphanumeric 字母</p>
<p>a.isalpha()<br>Returns True if all characters are alphabetic,returns False otherwise.</p>
<p>a.isdigit()<br>Returns True if all characters are digits,returns False otherwise.</p>
<p>s.join(t)<br>Joins the strings in sequence t.</p>
<p>s.replace(old,new [maxreplace])<br>Replaces old substring with new substring.</p>
<p>s.strip([characters])<br>Removes whitespace or optional characters.<br>Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）或字符序列。<br>注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。<br>1、strip() 处理的时候，如果不带参数，默认是清除两边的空白符，例如：/n, /r, /t, ‘ ‘)。<br>2、strip() 带有参数的时候，这个参数可以理解一个要删除的字符的列表，是否会删除的前提是从字符串最开头和最结尾是不是包含要删除的字符，如果有就会继续处理，没有的话是不会删除中间的字符的。</p>
<p>s.split([separator],[maxsplit])<br>Splites a string separated by whitespace or an optional separator.Returns  a list.</p>
<p>‘int’ object has no attribute ‘append’</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>list(s)<br>Returns a list of the sequence s.</p>
<p>s.append(s)<br>Appends element x to the end of s.</p>
<p>s.extend(x)<br>Appends the list x to s.</p>
<p>s.count(x)<br>Counts the occurrences of x in s.</p>
<p>s.index(x,[start],[stop])<br>Returns the smallest index,i,where s[i]==x.Can include optional start and stop index for the search.</p>
<p>s.insert(i,e)<br>Insert x at index i.</p>
<p>s.pop(i)<br>Returns the element i and removes it from the list</p>
<p>s.remove(x)<br>Removes x from s.</p>
<p>s.reverse()<br>Reverses the order of s.</p>
<p>s.sort(key,[reverse])<br>Sorts s with optional key and reverse</p>
<p>nested 嵌套的<br>bracket operator 括号运算符。</p>
<h3 id="Functions-as-first-class-objects"><a href="#Functions-as-first-class-objects" class="headerlink" title="Functions as first class objects"></a>Functions as first class objects</h3><p>In Python,it is not only data types that are treated as objects.Both functions and classes are what are known as first class objects,allowing them to be manipulated in the same ways as built-in data types.</p>
<p>By definition,first class objects are:</p>
<ul>
<li>Created at runtime</li>
<li>Assigned as a variable or in data structure</li>
<li>Passed as an argument to a function</li>
<li>Returned as the result of a function</li>
</ul>
<p>In Python,the term first class object is a bit of a misnomer since it implies some sort of hierarchy,whereas all Python objects are essentially first class.</p>
<p>Since user-defined functions are objects,we can do things such as include them in other objects,sunch as lists.</p>
<p>Functions can also be used as arguments for other functions.</p>
<h2 id="Higher-order-functions"><a href="#Higher-order-functions" class="headerlink" title="Higher order functions"></a>Higher order functions</h2><p>Functions that take other functions as arguments, or that return functions, are called higher order functions.</p>
<p>Python3 contains two built-in higher order functions,filter() and map().</p>
<p>In earlier versions of Python,these functions returned lists; in Python3,they return an iterator,making them much more efficient.</p>
<p>The map() funciton provides an easy way to transform each item into an iterable object.</p>
<p>Note that both map and filter perform the identical function as to what can be achieved by list comprehensions.</p>
<p>更推荐使用list comprehensions</p>
<p>Note the difference between the list.sort() method and the sorted built-in function.</p>
<p>list.sort(), a method of the list object,sorts the existing instance of a list <strong>without</strong> copying it.This method changes the target object and returns None. It is an important convention in Python that functions or methods that change the object return None to make it clear that no new object was created and that the object itself was changed.</p>
<p>On the other hand,the sorted built-in function returns a new list.It actually accepts any iterable object as an argument,but it will always retrun a list.Both list sort and sorted take two optional keyword arguments as key.</p>
<h2 id="Recursive-functions"><a href="#Recursive-functions" class="headerlink" title="Recursive functions"></a>Recursive functions</h2><p>In Python,we can implement a recursive function simply by calling it within its own function body.To stop a recursive function turning into an infinite loop, we need at least one argument that tests for a terminating case to end the recursion.This is sometimes called the base case.</p>
<p>It should be pointed out that recursion is different from iteration.</p>
<p>Although both involve repetition,iteration loops through a sequence of operations,whereas recursion repeatedly calls a function.Both need a selection statement to end.</p>
<p>Technically,recursion is a special case of iteration known as tail iteration,and it is usually always possible to convert an iterative function to a recursive function and vice versa.</p>
<p>The interesting thing about recursive functions is that they are able to describe an infinite object within a finite statement.</p>
<p>虽然两者都涉及重复，但迭代循环执行一系列操作，而递归重复调用一个函数。 两者都需要选择语句才能结束。 从技术上讲，递归是一种称为尾部迭代的迭代的特殊情况，通常总是可以将迭代函数转换为递归函数，反之亦然。 关于递归函数的有趣之处在于它们能够在有限语句中描述无限对象。</p>
<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration:"></a>Iteration:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def iterTest(low,high):</span><br><span class="line">    while low&lt;=high:</span><br><span class="line">        print(low)</span><br><span class="line">        low=low+1</span><br></pre></td></tr></table></figure>

<h3 id="recursion"><a href="#recursion" class="headerlink" title="recursion:"></a>recursion:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def recurTest(low,high):</span><br><span class="line">    if low&lt;high:</span><br><span class="line">        print(low)</span><br><span class="line">        recuTest(low+1,high)</span><br></pre></td></tr></table></figure>

<p>In general,iteration is more efficient;however,recursive functions are often easier to understand and write.Recursive functions are also useful for manipulating recursive data structures such as linked lists and trees,as we will see.</p>
<h2 id="Generators-and-co-routines"><a href="#Generators-and-co-routines" class="headerlink" title="Generators and co-routines"></a>Generators and co-routines</h2><p>We can create functions that do not just return one result,but rather an entire sequence of results,by using the <strong>yield</strong> statement.These functions are called generators.</p>
<p>Python contains generator functions, which are an easy way to create iterators and they are especially useful as a replacement for unworkably long lists. <strong>A generator yields items rather than build lists.</strong></p>
<p>Building a list to do this calculation takes significantly longer.The performance improvement as a result of using generators is because the values are <strong>generated on demand</strong>,rather than saved as a list in memory.<em>A calculation can begin before all the elements have been generated and elements are generated only when they are needed.</em></p>
<p>In the preceding example, the sum method loads each number into memory when it is needed for the calculation. This is achieved by the generator object repeatedly calling the <strong>next</strong>() special method. Generators never return a value other than None.</p>
<p>生成器永远不会返回除None之外的值。</p>
<p>Typically,generator objects are used in for loops.</p>
<p>We can also create a <strong>generator expression</strong>,which,apart from replacing square brackets with parentheses,uses the same syntax and carries out the same operation as list comprehensions.Generator expressions,however,do not create a list,they create a generator object.This object does not create the data,but rater creates that data on demand.This means that generator objects do not support sequence methods sunch as append() and insert().You can,however,change a generator into a list using the list() function.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [1,2,3,4]</span><br><span class="line">gen1 = (10**i for i in lst1)</span><br><span class="line">for x in gen1: print(x)</span><br><span class="line">100</span><br><span class="line">1000</span><br><span class="line">10000</span><br></pre></td></tr></table></figure>

<h2 id="Classes-and-object-programming"><a href="#Classes-and-object-programming" class="headerlink" title="Classes and object programming"></a>Classes and object programming</h2><p>Typically,classes are sets of funcitons,variables,and properties.</p>
<p>By organizing our programs around objects and data rather than actions and logic,we have a robust and flexible way to build complex applications.The actions and logic are still present of course,but by embodying them in objects,we have a way to encapsulate functionality,allowing objects to change in very specific ways.This makes our code less error-prone,easier to extend and maintain,and able to model real-world objects.</p>
<p>Classes are created in Python using the class statement.This defines a set of shared attributes associated with a collection of class instances.A class usually consists of a number of methods,class variables,and computed properties.It is important to understand that defining a class does not,by itself,create any instances of that class.To create an instance,a variable must be assined to a class.</p>
<p>The class body consists of a series of statements that execute during the class definition.</p>
<p>The functions defined inside a class are called instance methods.They apply some operations to the class instance by passing an instance of that class as the first argument.This argument is called self by convention,but it can be any legal identifier.</p>
<h2 id="Special-methods"><a href="#Special-methods" class="headerlink" title="Special methods"></a>Special methods</h2><p>The methods that begin and end with two underscores are called special methods.</p>
<p>Apart from the following exception,special method,are generally called by the Python interpreter rather than the programmer;</p>
<p>for example,when we use the + operator,we actually invoking a call to <strong>add</strong>().</p>
<p>For example,rather than using my_object.<strong>len</strong>() we can use len(my_object) using len() on a string object is actually much faster because it returns the value representing the object’s size in memory,rather than making a call to the object’s <strong>len</strong>method.</p>
<p>The only special method we actually call inour programs,as common practice,is the <strong><strong>init</strong></strong> method,to invoke the initializer of the superclass in our own class definitions.</p>
<p>It is strongly <strong>advised</strong> <em>not to use the double underscore syntax</em> for your own objects because of potential current or future conflicts with Python’s own special methods.</p>
<p>We may,however,want to implement special methods in custom objects,to give them some of the behavior of built-in types.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class my_class():</span><br><span class="line">    def __init__(self, greet):</span><br><span class="line">        self.greet = greet</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;a custom object (%r)&apos; % (self.greet)</span><br></pre></td></tr></table></figure>

<p>When we create an instance of this object and inspect it, we can see we get our customized string representation. Notice the use of the %r format placeholder to return the standard representation of the object. This is useful and best practice, because, in this case, it shows us that the greet object is a string indicated by the quotation marks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = my_class(&apos;giday&apos;)</span><br><span class="line">a</span><br><span class="line">a custom object(&apos;giday&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>It is possible to create a new class that modifies the behavior of an existing class through inheritance. This is done by passing the inherited class as an argument in the class definition. It is often used to modify the behavior of existing methods, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class specialEmployee(Employee):</span><br><span class="line">    def hours(self,numHours):</span><br><span class="line">        self.owed += numHours * self.rate*2</span><br><span class="line">        return(&quot;%.2f hours worked&quot; % numHours)</span><br></pre></td></tr></table></figure>

<p>For a subclass to define new class variables,it needs to define an <strong>init</strong>() method,as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class specialEmployee(Employee):</span><br><span class="line">    def __init__(self,name,rate,bonus):</span><br><span class="line">        Employee.__init__(self,name,rate)#calls the base classes</span><br><span class="line">        self.bonus = bonus</span><br><span class="line">    def hours(self,numHours):</span><br><span class="line">        self.owed += numHours * self.rate*2</span><br><span class="line">        return(&quot;%.2f hours worked&quot; % numHours)</span><br></pre></td></tr></table></figure>

<p>Notice that the methods of the base class are not automatically invoked and it is necessary for the derived class to call them.We can test for class membership using the built-in function <code>isintance(obj1,obj2)</code>.This returns true if <code>obj1</code> belongs to the class of <code>obj2</code> or any class derived from <code>obj2</code>.</p>
<p>Within a class definition,it is assumed that all methods operate on the instance,but this is not a requirement.There are,however,other types of methods:<code>static methods</code> and <code>class methods</code>.</p>
<p>A static method is just an ordinary function that just happens to be defined in a class.</p>
<p>It <em>does not</em> perform any operations on the instance and it is defined using the <code>@staticmethod</code> class decorator.Static methods cannot access the attributes of an instance,so their most common <strong>usage</strong> is as a convenience to group utility functions together.<br>Class methods operate on the class itself,not the instance,in the same way that class variables are associated with the classes rather than instances of that class.They are defined using the <code>@classmethod</code> decorator,and are distinguished from instance methods in that the class is passed as the first argument.This is named <code>cls</code> by convention.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Aexp(object):</span><br><span class="line">    base = 2</span><br><span class="line">    @classmethod</span><br><span class="line">    def exp(cls,x):</span><br><span class="line">        return(cls.base**x)</span><br><span class="line">class Bexp(Aexp):</span><br><span class="line">    base = 3</span><br></pre></td></tr></table></figure>

<p>The class Bexp inherits from the Aexp class and changes the base class variable to 3. We canrun the parent class’s exp() method as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bexp.exp(2)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>Because a subclass inherits all the same fetures of its parent there is the potential for it to break inherited methods.Using class methods is a way to define exactly what methods are run.</p>
<h2 id="Data-encapsulation-and-properties"><a href="#Data-encapsulation-and-properties" class="headerlink" title="Data encapsulation and properties"></a>Data encapsulation and properties</h2><p>Unless otherwise specified,all attributes and methods are accessible without restriction.This may cause problems when we are building object-oriented applications where we may want to hide the internal implementation of an object.This can lead to namespace conflicts between objects defined in derived classes with the base class.</p>
<p>To prevent this,the methods we define private attributes with <strong>have a double underscore</strong>,sunch as <code>__privateMethod()</code> .These method names are automatically changed <code>__Classname__privateMethod</code> to prevent name conflicts with methods defined in base classes.</p>
<p>Be aware that <strong>this does not strictly hide private attributes</strong>, rather it just provides a mechanism for <strong>preventing name conflicts</strong>.</p>
<p>It is recommended to use private attributes when using a class <strong>property</strong> to define mutable attributes.A property is a kind of attribute that rather than returning a stored value,computes its value when called.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bexp(Aexp):</span><br><span class="line">    __base = 3</span><br><span class="line">    def __exp(self):</span><br><span class="line">    return(x**cls.base)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-23-笔记整理（侯捷笔记4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-23-笔记整理（侯捷笔记4)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Object-Oriented-Programming-Object-Oriented-Design"><a href="#Object-Oriented-Programming-Object-Oriented-Design" class="headerlink" title="Object Oriented Programming,Object Oriented Design"></a>Object Oriented Programming,Object Oriented Design</h1><h2 id="OOP-OOD"><a href="#OOP-OOD" class="headerlink" title="OOP OOD"></a>OOP OOD</h2><h4 id="Inheritance（继承）"><a href="#Inheritance（继承）" class="headerlink" title="-Inheritance（继承）"></a>-Inheritance（继承）</h4><h4 id="Composition（复合）"><a href="#Composition（复合）" class="headerlink" title="-Composition（复合）"></a>-Composition（复合）</h4><h4 id="Delegation（委托）"><a href="#Delegation（委托）" class="headerlink" title="-Delegation（委托）"></a>-Delegation（委托）</h4><h2 id="Composition（复合），表示has-a"><a href="#Composition（复合），表示has-a" class="headerlink" title="Composition（复合），表示has-a"></a>Composition（复合），表示has-a</h2><p><code>Adapter</code><br>Composition（复合）关系下的构造和析构<br><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5Ce3c0bf05.png" alt="e3c0bf05.png"></p>
<h3 id="构造由内而外"><a href="#构造由内而外" class="headerlink" title="构造由内而外"></a>构造由内而外</h3><p>Container的构造函数首先调用Component的default构造函数，然后才执行自己。<br><code>Container::Container(...):Component(){...};</code></p>
<h3 id="构造由外而内"><a href="#构造由外而内" class="headerlink" title="构造由外而内"></a>构造由外而内</h3><p>Container的析构函数首先执行自己，然后才调用Component的析构函数。<br><code>Container::~Container(...){...~Component()};</code></p>
<h2 id="Delegation（委托）-Composition-by-reference"><a href="#Delegation（委托）-Composition-by-reference" class="headerlink" title="Delegation（委托）.Composition by reference."></a>Delegation（委托）.Composition by reference.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        String();</span><br><span class="line">        String(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">        String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">        ~String();</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        StringRep* rep;<span class="comment">//pimpl(Handle/Body)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"String.hpp"</span></span></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>;</span></span><br><span class="line">        StringRep(<span class="keyword">const</span> <span class="keyword">char</span>*s);</span><br><span class="line">        ~StringRep();</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">char</span>* rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; </span><br><span class="line">String::String()&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C0f52c2f8.png" alt="0f52c2f8.png"></p>
<h2 id="Inheritance（继承）-表示is-a"><a href="#Inheritance（继承）-表示is-a" class="headerlink" title="Inheritance（继承）,表示is-a"></a>Inheritance（继承）,表示is-a</h2><h3 id="Inheritance（继承）关系下的构造和析构"><a href="#Inheritance（继承）关系下的构造和析构" class="headerlink" title="Inheritance（继承）关系下的构造和析构"></a>Inheritance（继承）关系下的构造和析构</h3><p>base class 的构造函数必须是virtual，否则会出现undefined behavior<br><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C1053a33c.png" alt="1053a33c.png"></p>
<h4 id="构造由内而外-1"><a href="#构造由内而外-1" class="headerlink" title="构造由内而外"></a>构造由内而外</h4><p>Derived的构造函数首先调用base的default构造函数，然后才执行自己。<br><code>Derived::Derived(...):Base(){...};</code></p>
<h4 id="构造由外而内-1"><a href="#构造由外而内-1" class="headerlink" title="构造由外而内"></a>构造由外而内</h4><p>Derived的析构函数首先执行自己，然后才调用Base的析构函数。<br><code>Derived::~Derived(...){...~Base()};</code></p>
<h2 id="Inheritance（继承）with-virtual-functions（虚函数）"><a href="#Inheritance（继承）with-virtual-functions（虚函数）" class="headerlink" title="Inheritance（继承）with virtual functions（虚函数）"></a>Inheritance（继承）with virtual functions（虚函数）</h2><ul>
<li>non-virtual函数：你不希望derived class 重新定义（override，复写）它。</li>
<li>virtual函数：你希望derived class 重新定义（override，复写）它，且它已经有默认定义。</li>
<li>pure virtual函数：你希望derived class 一定要重新定义（override，复写）它，你对它没有默认定义。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// impure virtual</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// non-virtual</span></span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Template Method 设计模式</p>
<p><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C4856d28e.png" alt="4856d28e.png"></p>
<h4 id="Delegation（委托）-Inheritance（继承）"><a href="#Delegation（委托）-Inheritance（继承）" class="headerlink" title="Delegation（委托）+Inheritance（继承）"></a>Delegation（委托）+Inheritance（继承）</h4><p>  <img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5Cd9aa4c92.png" alt="d9aa4c92.png"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Component(<span class="keyword">int</span> val) &#123; value = val; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span> :</span><span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Primitive(<span class="keyword">int</span> val) :Component(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span><span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Component*&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Composite(<span class="keyword">int</span> val) :Component(val) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* elem)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c.push_back(elem);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C82ee2b56.png" alt="82ee2b56.png"><br>创建未来的class 名称<br>下面创建的原型要让上面看得到，放上去。<br>Prototype 原型<br>每一个子类有自己的一个个体，并且有一个构造函数把自己这个个体挂到上面去。<br>每一个子类有一个clone，让父类能够通过原型调用clone创建一个个副本，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-7-19-Python Data Types and Structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-7-19-Python Data Types and Structures/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Operations-and-expressions"><a href="#Operations-and-expressions" class="headerlink" title="Operations and expressions"></a>Operations and expressions</h2><p>There are number of operations that are common to all data types.For example, all data types, and generally all objects, can be tested for a truth value in some way.</p>
<h4 id="The-following-are-values-that-Python-considers-False"><a href="#The-following-are-values-that-Python-considers-False" class="headerlink" title="The following are values that Python considers False:"></a>The following are values that Python considers <code>False</code>:</h4><ul>
<li>The None type</li>
<li>False</li>
<li>An integer, float, or complex zero</li>
<li>An empty sequence or mapping</li>
<li>An instance of a user-defined class that defines a <strong>len</strong>() or <strong>bool</strong>() method that returns zero or False</li>
</ul>
<p>All other values are considered <code>True</code>.</p>
<h2 id="Boolean-operations"><a href="#Boolean-operations" class="headerlink" title="Boolean operations"></a>Boolean operations</h2><p>Both the <code>and</code> operator and the <code>or</code> operator use “short-circuiting” when evaluating an expression.This means Python will only evaluate an operator if it needs to.</p>
<h2 id="Comparison-and-Arithmetic-operators"><a href="#Comparison-and-Arithmetic-operators" class="headerlink" title="Comparison and Arithmetic operators"></a>Comparison and Arithmetic operators</h2><p>For collection objects, these operators compare the number of elements and the equivalence operator <code>==</code>  returns True if each collection object is structurally equivalent, and the value of each element is identical.</p>
<h2 id="Membership-identity-and-logical-operations"><a href="#Membership-identity-and-logical-operations" class="headerlink" title="Membership, identity, and logical operations"></a>Membership, identity, and logical operations</h2><p>Membershi operators(<code>in</code>,<code>not in</code>) test for variables in sequences,such as lists or strings do what you would expect,x in y returns True if a variable x is found in y.</p>
<p>The <code>is</code> operator compares object identity.</p>
<p>For example, the following snippet shows contrast equivalence with object identity:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=[1,2,3];y=[1,2,3]</span><br><span class="line">x==y #equivalence</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">x is y #object identity</span><br><span class="line">False</span><br><span class="line">x = y # assignment</span><br><span class="line">x is y</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="Built-in-data-types"><a href="#Built-in-data-types" class="headerlink" title="Built-in data types"></a>Built-in data types</h2><p>Python data types can be divided into three categories:<strong>numeric</strong>,<strong>sequence</strong>,and <strong>mapping</strong>.</p>
<p>There is also the None object that represents a Null,or absence of a value.It should not be forgotten either that other objects such as classes,files,and exceptions can also properly be considered types;however,they will not be considered here.</p>
<p>Every value in Python has a data type. Unlike many programming languages, in Python you do not need to explicitly declare the type of a variable. Python keeps track of object types internally.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>None</td>
<td>The null object.</td>
</tr>
<tr>
<td>Sequences</td>
<td>str</td>
<td>string of characters.</td>
</tr>
<tr>
<td>Sequences</td>
<td>list</td>
<td>List of arbitrary objects.</td>
</tr>
<tr>
<td>Sequences</td>
<td>Tuple</td>
<td>Group of arbitrary items.</td>
</tr>
<tr>
<td>Sequences</td>
<td>range</td>
<td>Creates a range of integers.</td>
</tr>
<tr>
<td>Mapping</td>
<td>dict</td>
<td>Dictionary of key-value pairs.</td>
</tr>
<tr>
<td>Mapping</td>
<td>set</td>
<td>Mutable,unordered collection of unique items.</td>
</tr>
<tr>
<td>Mapping</td>
<td>frozenset</td>
<td>Immutable set</td>
</tr>
</tbody></table>
<h3 id="None-type"><a href="#None-type" class="headerlink" title="None type"></a>None type</h3><p>The None type is immutable and has one value, None. It is used to represent the absence of a value. It is returned by objects that do not explicitly return a value and evaluates to False in Boolean expressions. It is often used as the default value in optional arguments to allow the function to detect whether the caller has passed a value.</p>
<h3 id="Numeric-Types"><a href="#Numeric-Types" class="headerlink" title="Numeric Types"></a>Numeric Types</h3><p>All numeric types, apart from bool, are signed and they are all immutable.</p>
<p>The integer type, int, represents whole numbers of unlimited range. Floating point numbers are represented by the native double precision floating point representation of the machine.</p>
<p>Complex numbers are represented by two floating point numbers. They are assigned using the j operator to signify the imaginary part of the complex number, for example:<br><code>a = 2+3j</code><br> We can access the real and imaginary parts with <code>a.real</code> and <code>a.imag</code>, respectively.</p>
<h3 id="Representation-error"><a href="#Representation-error" class="headerlink" title="Representation error"></a>Representation error</h3><p>It should be noted that the native double precision representation of floating point numbers leads to some unexpected results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1-0.9</span><br><span class="line">0.09999999999999998</span><br><span class="line">&gt;&gt;&gt; 1-0.9==0.1</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>This is a result of the fact that <strong>most decimal fractions are not exactly representable as a binary fraction</strong>,which is how most uderlying hardware represents floating point numbers.</p>
<p>For algorithms or applications where this may be an issue,Python provides a <strong>decimal module</strong>.</p>
<p>This module allows for the exact representation of decimal numbers and facilitates greater control properties such as rounding behavior,number of sigificant digits,and precision.</p>
<p>It defines two objects,a Decimal type,representing decimal numbers,and a Context type,representing various computational parameters such as precision,rounding,and error handling.</p>
<p>In addition, Decimal objects also have several methods for mathematical operations, such as natural exponents, x.exp(), natural logarithms, x.ln(), and base 10 logarithms, x.log10().</p>
<h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p>Lists and tuples are sequences of arbitrary objects, strings are sequences of characters. String, tuple, and range objects are immutable.</p>
<p>Note that for the immutable types, any operation will only return a value rather than actually change the value.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>len(s)</td>
<td>Number of elements in s</td>
</tr>
<tr>
<td>min(s,[,default=obj,key=func])</td>
<td>The minimum value in s (alpabetically for strings)</td>
</tr>
<tr>
<td>max(s,[,default=obj,key=func])</td>
<td>Maximum value in s(alphabetically for strings)</td>
</tr>
<tr>
<td>sum(s,[,start=0])</td>
<td>The sum of elements (returns TypeError if s is not numeric)</td>
</tr>
<tr>
<td>all(s)</td>
<td>Returns True if all elements in <code>s</code> are True(that is,not <code>0</code>,<code>False</code>,or <code>Null</code>)</td>
</tr>
<tr>
<td>any(s)</td>
<td>Check whether any item in <code>s</code> is True</td>
</tr>
</tbody></table>
<p>In addition, all sequences support the following operations:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>s+r</td>
<td>Concatenates two sequences of the same type</td>
</tr>
<tr>
<td>s*n</td>
<td>Make n copies of s, where n is an integer</td>
</tr>
<tr>
<td>v1,v2,…,vn=s</td>
<td>Unpacks n variables from s to v1,v2,and so on</td>
</tr>
<tr>
<td>s[i]</td>
<td>Indexing-returns element i of s</td>
</tr>
<tr>
<td>s[i:j:stride]</td>
<td>Slicing returns elements between i and j with optional stride</td>
</tr>
<tr>
<td>x in s</td>
<td>Returns True if element x is in s</td>
</tr>
<tr>
<td>x not in s</td>
<td>Returns true if element x is not in s</td>
</tr>
</tbody></table>
<h2 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h2><p>Tuples are immutable sequences of arbitrary objects.They are indexed by integers greater than zero.Tuples are hashable,which means we can sort lists of them and they can be used as keys to dictionaries.</p>
<p>Syntactically,tuples are just a comma-separated sequence of values;however,it is common practice to enclose them in parentheses:<br><code>tpl= (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></p>
<p>It is important to remember to use a trailing comma when creating a tuple with one element, for example:<br>     <code>t = (&#39;a&#39;,)</code></p>
<p>Without the trailing comma, this would be interpreted as a string.</p>
<p>We can also create a tuple using the built-in function tuple(). With no argument, this creates an empty tuple. If the argument to tuple() is a sequence then this creates a tuple of elements of that sequence, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple(&apos;sequence&apos;)</span><br><span class="line">(&apos;s&apos;, &apos;e&apos;, &apos;q&apos;, &apos;u&apos;, &apos;e&apos;, &apos;n&apos;, &apos;c&apos;, &apos;e&apos;)</span><br></pre></td></tr></table></figure>

<p>Most operators, such as those for slicing and indexing, work as they do on lists. However, because tuples are immutable, trying to modify an element of a tuple will give you a TypeError. We can compare tuples in the same way that we compare other sequences, using the <code>==</code>, <code>&gt;</code> and <code>&lt;</code> operators.</p>
<p>An important use of tuples is to allow us to assign more than one variable at a time by placing a tuple on the left-hand side of an assignment,for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l=[&apos;one&apos;,&apos;two&apos;]</span><br><span class="line">&gt;&gt;&gt; x,y = l #assigns x and y to &apos;one&apos; and &apos;two&apos; respectively</span><br></pre></td></tr></table></figure>

<p>We can actually use this multiple assignment to swap values in a tuple, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y=y,x #x=&apos;two&apos; and y = &apos;one&apos;</span><br></pre></td></tr></table></figure>

<p>A ValueError will be thrown if the number of values on each side of the assignment are not the same.</p>
<h2 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h2><p>Dictionaries are arbitrary collections of objects indexed by numbers,strings,or other immutable objects.Dictionaries themselves are mutable;however,their index keys must be immutable.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>len(d)</td>
<td>Number of items in d.</td>
</tr>
<tr>
<td>d.clear()</td>
<td>Removes all items from d</td>
</tr>
<tr>
<td>d.fromkeys(s,[,value])</td>
<td>Returns a new dictionary with keys from sequence s and values set to value.</td>
</tr>
<tr>
<td>d.get(k,[,v])</td>
<td>Returns d[k] if found,or else returns v,or None if v is not given.</td>
</tr>
<tr>
<td>d.items()</td>
<td>Returns a sequence of key:value pairs in d.</td>
</tr>
<tr>
<td>d.keys()</td>
<td>Returns a sequence of keys in d.</td>
</tr>
<tr>
<td>d.pop(k [,default])</td>
<td>Returns d[k] and removes it from d. If d[k] is not found,it returns default or raises KeyError.</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>Removes a random key:value pair from d and returns it as a tuple.</td>
</tr>
<tr>
<td>d.setdefault(k [,v])</td>
<td>Returns d[k].If d[k] is not found,it returns v and sets d[k] to v.</td>
</tr>
<tr>
<td>d.update(b)</td>
<td>Adds all objects from b to d.</td>
</tr>
<tr>
<td>d.values()</td>
<td>Returns a sequence of values in d.</td>
</tr>
</tbody></table>
<p>The relationship between the time an algorithm takes to run compared to the size of its input is often referred to as its time complexity.<br>算法运行的时间与其输入的大小之间的关系通常被称为其时间复杂度。</p>
<p>In contrast to the list object, when the in operator is applied to dictionaries, it uses a <strong>hashing algorithm</strong> and this has the effect of the increase in time for each lookup almost independent of the size of the dictionary. This makes dictionaries extremely useful as a way to work with large amounts of indexed data.</p>
<p>Notice when we print out the key:value pairs of the dictionary it does so in no particular order.This is not a problem since we use specified keys to look up each dictionary value rather than an ordered sequence of integers as is the case for strings and lists.</p>
<h2 id="Sorting-dictionaries"><a href="#Sorting-dictionaries" class="headerlink" title="Sorting dictionaries"></a>Sorting dictionaries</h2><p>The sorted() method has two optional arguments that are of interest: key and reverse.</p>
<p>The key argument has nothing to do with the dictionary keys, but rather is a way of passing a function to the sort algorithm to determine the sort order.</p>
<p>We use the <code>__getitem__</code> special method to sort the dictionary keys according to the dictionary values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;a&apos;: 68, &apos;b&apos;: 1&#125;</span><br><span class="line">&gt;&gt;&gt; sorted(list(d),key=d.__getitem__)</span><br><span class="line">[&apos;b&apos;, &apos;a&apos;]</span><br></pre></td></tr></table></figure>

<p>Essentially,what the preceding code doing is for every key in d to use the corresponding value to sort.We can also sort the values according to the sorted order of the dictionary keys.However,since dictionaries do not have a method to return a key by using its value,the equivalent of the <code>list.index</code> method for lists,using the optional key argument to do this is a little tricky. An alternative approach is to use a list comprehension,as the following example demonstrates:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [value for (key,value) in sorted(d.items())]</span><br><span class="line">[68, 1]</span><br></pre></td></tr></table></figure>

<p>The sorted() method also has an optional reverse argument,and unsurprisingly,this does exactly what it says,reverses the order of the sorted list,for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(list(d),key=d.__getitem__,reverse=True)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure>

<h2 id="Dictionaries-for-text-analysis"><a href="#Dictionaries-for-text-analysis" class="headerlink" title="Dictionaries for text analysis"></a>Dictionaries for text analysis</h2><p>A common use of dictionaries is to count the occurrences of like items in a sequence; a typical example is counting the occurrences of words in a body of text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def wordcount(fname):</span><br><span class="line">    try:</span><br><span class="line">        fhand=open(fname)</span><br><span class="line">    except:</span><br><span class="line">        print(&apos;File cannot be opened&apos;)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    count=dict()</span><br><span class="line">    for line in fhand:</span><br><span class="line">        words=line.split()</span><br><span class="line">        for word in words:</span><br><span class="line">            if word not in count:</span><br><span class="line">                count[word]=1</span><br><span class="line">            else:</span><br><span class="line">                count[word]+=1</span><br><span class="line">    return(count)</span><br></pre></td></tr></table></figure>

<p>This will retrun a dictionary with an element for each unique word in the text file.<br>Dictionary comprehensions work in an identical way to the list comprehensions.</p>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>Sets are themselves mutable,we can add and remove items from them;however,the items themselves must be immutable.</p>
<p>An important distinction with sets is that they cannot contain duplicate items.</p>
<p>Sets are typically used to perform mathematical operations such as intersection, union, difference, and complement.</p>
<p>交并差补<br>intersection，union，difference，complement</p>
<p>Unlike sequence types,set types do not provide andy indexing or slicing operations.There are also no keys associated with values,as is the case with dictionaries.</p>
<p>There are two types of set objects in Python, the mutable set object and the immutable frozenset object. Sets are created using comma-separated values within curly braces.<br>By the way, we cannot create an empty set using a={}, because this will create a dictionary. To create an empty set, we write either a=set() or a=frozenset().<br>Method|Operators|Description<br>—|—|—<br>len(s)||Returns the number of elements in s.<br>s.copy()||Returns a shallow copy of s<br>s.difference(t)        |s-t-t2-…|Returns a set of all items in s but not in t<br>s.intersection(t)||Returns a set of all items in both t and s<br>s.isdisjoint(t)||Returns True if s and t have no items in common<br>s.issubset(t)|s&lt;=t s&lt;t(s!=t)|Returns True if all items in s are also in t<br>s.issuperset(t)| s&gt;=t s&gt;t(s!=t)|Returns True if all items in t are also in s<br>s.symmetric_difference(t)|s^t|Returns a set of all items that are in s or t,but not both<br>s.union(t)|s|t1|t2|..|Returns a set of all items in s or t</p>
<p>The parameter <code>t</code> can be any Python object that supports iteration and all methods are available to both set and frozenset objects.<br>It is important to be aware that the operator versions of these methods require their arguments to be sets, whereas the methods themselves can accept any iterable type. For example, <code>s - [1,2,3]</code>, for any set s, will generate an unsupported operand type. Using the equivalent <code>s.difference([1,2,3])</code> will return a result.</p>
<p>Mutable set objects have additional methods<br>Method|Description<br>—|—<br>s.add(item)|Adds item to s.Has no effect if item is already present.<br>s.clear()|Remove all items from s<br>s.difference_update(t)|Removes all items in s that are also in t<br>s.discard(item)|Removes item from s.<br>s.intersection_update(t)|Removes all items from s that are not in the intersection of s and t.<br>s.pop()|Returns and removes an arbitrary item from s<br>s.remove(item)|Removes item from s<br>s.symmetric_difference_update(t)|Removes all items from s that are not in the symmetric difference of s ant t.<br>s.update(t)|Adds all the items in an iterable object t to s.</p>
<p>Notice that the set object does not care that its members are not all of the same type,as long as they are all immutable.<br>Hashable types all have a hash value that does not change throughout the lifetimeof the instance.<strong>All built-in immutable types are  hashable</strong>.<strong>All built-in mutable types are not hashable</strong>,so they cannot be used as elements of sets or keys to dictionaries.</p>
<h2 id="Immutable-sets"><a href="#Immutable-sets" class="headerlink" title="Immutable sets"></a>Immutable sets</h2><p>Python has an immutable set type called frozenset.It works pretty much exactly like set apart from not allowing methods or operations that change values such as the <code>add()</code> or <code>clear()</code> methods.</p>
<p>There are several ways that this immutability can be useful. For example, since normal sets are mutable and therefore not hashable, they cannot be used as members of other sets. The frozenset, on the other hand, is immutable and therefore able to be used as a member of a set.<br>Also the immutable property of frozenset means we can use it for a key to a dictionary.</p>
<h2 id="Modules-for-data-structures-and-algorithms"><a href="#Modules-for-data-structures-and-algorithms" class="headerlink" title="Modules for data structures and algorithms"></a>Modules for data structures and algorithms</h2><p>So far, we have looked at the built-in datatypes of strings, lists, sets, and dictionaries as well as the decimal and fractions modules. They are often described by the term abstract data types (ADTs).ADTs can be considered as mathematical specifications for the set of operations that can be performed on data.</p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>The collections module provides more specialized,high,performance alternatives for the built-in data types as well as a utility function to create named tuples.</p>
<table>
<thead>
<tr>
<th>Datatype or operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>namedtuple()</td>
<td>Creates tuple subclasses with named fields.</td>
</tr>
<tr>
<td>deque</td>
<td>Lists with fast appends and pops either end.</td>
</tr>
<tr>
<td>ChainMap</td>
<td>Dictionary like class to create a single view of multiple mappings.</td>
</tr>
<tr>
<td>Counter</td>
<td>Dictionary subclass for counting hashable objects.</td>
</tr>
<tr>
<td>OrderedDict</td>
<td>Dictionary subclass that remembers the entry order.</td>
</tr>
<tr>
<td>defaultdict</td>
<td>Dictionary subclass that calls a function to supply missing vlaues.</td>
</tr>
<tr>
<td>UserDict <br> UserList<br>UserString</td>
<td>These three data types are simply wrappers for their underlying base classes.Their use has largely been supplanted by the ability to subclassses their respective base classes directly.Can be used to access the underlying object as an attribute.</td>
</tr>
</tbody></table>
<h2 id="Deques"><a href="#Deques" class="headerlink" title="Deques"></a>Deques</h2><p>Double-ended queues,or deques,are list-like objects that support thread-safe,memory-effcient appends.</p>
<p>Deques are mutable and support some of the operations of lists,such as indexing.Deques can be assigned by index.However,we cannot directly slice deques.</p>
<p>The major advantage of deques over lists is that inserting items at the beginning of a deque is much faster than inserting items at the beginning of a list,although inserting items at the end of a deques is very slightly slower than the equivalent operation on a list.</p>
<p>Deques are thread,safe and can be serialized using the pickle module.</p>
<p>We can also use the rotate(n) method to move and rotate all items of n steps to the right for positive values of the integer n,or left for negative values of n the left,using positive integers as the argument</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([&apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;])</span><br><span class="line">&gt;&gt;&gt; dq.rotate(2)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([&apos;f&apos;, &apos;g&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br><span class="line">&gt;&gt;&gt; dq.rotate(2)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([&apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>a simple way to return a slice of a deque, as a list, which can be done as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; list(itertools.islice(dq,3,9))</span><br><span class="line">[&apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>itertools.islice</code> method works in the same way that slice works on a list,except rather than taking a list for an argument,it takes an iterable and returns slelected values,by start and stop indices,as a list.</p>
<p><code>maxlen</code> a optional parameter that restricts the size of deque.<br>This makes  it ideally suited to a data structure known as a <em>circular buffer</em>.This is a fixed-size structure that is effectively connected end to end and they are typically used for buffering data streams.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dq2 = deque([],maxlen=3)</span><br><span class="line">&gt;&gt;&gt; for i in range(6):</span><br><span class="line">...     dq2.append(i)</span><br><span class="line">...     print(dq2)</span><br><span class="line">... </span><br><span class="line">deque([0], maxlen=3)</span><br><span class="line">deque([0, 1], maxlen=3)</span><br><span class="line">deque([0, 1, 2], maxlen=3)</span><br><span class="line">deque([1, 2, 3], maxlen=3)</span><br><span class="line">deque([2, 3, 4], maxlen=3)</span><br><span class="line">deque([3, 4, 5], maxlen=3)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>In this example,we are populating from the right and consuming from the left.Notice that once the buffer is full,the oldest values are consumed first,and values are replaced from the right.</p>
<h2 id="ChainMaps"><a href="#ChainMaps" class="headerlink" title="ChainMaps"></a>ChainMaps</h2><p><code>collection.chainmap</code> class provides a way to link a number of dictionaries,or other mappings,so that they can be treated as one object.</p>
<p>In addition,there is a maps attribute,a <code>new_child()</code> method,and a parents property.</p>
<p>The uderlying mappings for ChainMap objects are stored in a list and are accessible using the <code>maps[i]</code> attribute to retrieve <code>ith</code> dictionary.</p>
<p>ChainMaps are an ordered list of dictionaries.ChainMap is useful in applications where we are using a number of dictionaries containing related data.</p>
<p>The advantage of using ChainMaps, rather than just a dictionary, is that we <strong>retain previously set values</strong>. Adding a child context overrides values for the same key, but it does not remove it from the data structure. This can be useful for when we may need to keep a record of changes so that we can easily roll back to a previous setting.</p>
<p>We can retrieve and change any value in any of the dictionaries by providing the map() method with an appropriate index. This index represents a dictionary in the ChainMap. Also, we can retrieve the parent setting, that is, the default settings, by using the parents() method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from collections import ChainMap</span><br><span class="line">&gt;&gt;&gt; cm2.maps[0]=&#123;&apos;theme&apos;:&apos;desert&apos;,&apos;showIndex&apos;:False&#125;</span><br><span class="line">&gt;&gt;&gt; cm2</span><br><span class="line">ChainMap(&#123;&apos;theme&apos;: &apos;desert&apos;, &apos;showIndex&apos;: False&#125;, &#123;&apos;theme&apos;: &apos;Default&apos;, &apos;language&apos;: &apos;eng&apos;, &apos;showIndex&apos;: True, &apos;showFooter&apos;: True&#125;)</span><br><span class="line">&gt;&gt;&gt; cm2[&apos;showIndex&apos;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; cm2.parents</span><br><span class="line">ChainMap(&#123;&apos;theme&apos;: &apos;Default&apos;, &apos;language&apos;: &apos;eng&apos;, &apos;showIndex&apos;: True, &apos;showFooter&apos;: True&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Counter-objects"><a href="#Counter-objects" class="headerlink" title="Counter objects"></a>Counter objects</h2><p>Counter is a subclass of a dictionary where each dictionary <code>key</code> is a hashable object and the associated value is an integer count of that object.<br>There are three ways to initialize a counter.</p>
<p>We can pass it any sequence object,a dictionary of <code>key:value</code> pairs,or a tuple of the format(<code>object = value,...</code>),for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Counter</span><br><span class="line">&gt;&gt;&gt; c1 = Counter(&apos;anysequence&apos;)</span><br><span class="line">&gt;&gt;&gt; c2 = Counter(&#123;&apos;a&apos;:1,&apos;c&apos;:1,&apos;e&apos;:3&#125;)</span><br><span class="line">&gt;&gt;&gt; c1</span><br><span class="line">Counter(&#123;&apos;e&apos;: 3, &apos;n&apos;: 2, &apos;a&apos;: 1, &apos;y&apos;: 1, &apos;s&apos;: 1, &apos;q&apos;: 1, &apos;u&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; c2</span><br><span class="line">Counter(&#123;&apos;e&apos;: 3, &apos;a&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>We can also create an empty counter object and populate it by passing its update method an iterable or a dictionary, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ct = Counter()</span><br><span class="line">&gt;&gt;&gt; ct.update(&apos;abca&apos;)</span><br><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;&apos;a&apos;: 2, &apos;b&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; ct.update(&#123;&apos;a&apos;:3&#125;)</span><br><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;&apos;a&apos;: 5, &apos;b&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>Notice how the update method adds the counts rather than replacing them with new values. Once the counter is populated, we can access stored values in the same way we would for dictionaries, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;&apos;a&apos;: 5, &apos;b&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; for item in ct:</span><br><span class="line">...     print(&apos;%s:%d&apos;%(item,ct[item]))</span><br><span class="line">... </span><br><span class="line">a:5</span><br><span class="line">b:1</span><br><span class="line">c:1</span><br></pre></td></tr></table></figure>

<p>The most notable difference between counter objects and dictionaries is that counter objects return a zero count for missing items rather than raising a key error,for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ct[&apos;x&apos;]</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>We can create an iterator out of a Counter object by using its <code>elements()</code> method.This returns an iterator where counts below one are not included and the order is not guaranteed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ct.update(&#123;&apos;a&apos;:-3,&apos;b&apos;:-2,&apos;d&apos;:3,&apos;e&apos;:2&#125;)</span><br><span class="line">sorted(ct.elements())# returns a sorted list from the iterator</span><br><span class="line">[&apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;e&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure>

<p>Two other Counter methods worth mentioning are <code>most_common()</code> and <code>subtract()</code> . </p>
<p>The most common method takes a positive integer argument that determines the number of most common elements to return. Elements are returned as a list of (key ,value) tuples. The subtract method works exactly like update except instead of adding values, it subtracts them.</p>
<h2 id="Ordered-dictionaries"><a href="#Ordered-dictionaries" class="headerlink" title="Ordered dictionaries"></a>Ordered dictionaries</h2><p>When we test to see whether two dictionaries are equal, this equality is only based on their keys and values; however, with an OrderedDict , the insertion order is also considered An equality test between two <code>OrderedDicts</code> with the same keys and values but a different insertion order will return False :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import OrderedDict</span><br><span class="line">&gt;&gt;&gt; od1=OrderedDict()</span><br><span class="line">&gt;&gt;&gt; od1[&apos;one&apos;]=1</span><br><span class="line">&gt;&gt;&gt; od1[&apos;two&apos;]=2</span><br><span class="line">&gt;&gt;&gt; od2=OrderedDict()</span><br><span class="line">&gt;&gt;&gt; od2[&apos;two&apos;]=2</span><br><span class="line">&gt;&gt;&gt; od2[&apos;one&apos;]=1</span><br><span class="line">&gt;&gt;&gt; od1==od2</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>Similarly, when we add values from a list using update , the OrderedDict will retain the same order as the list. This is the order that is returned when we iterate the values, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kvs = [(&apos;three&apos;,3),(&apos;four&apos;,4),(&apos;five&apos;,5),(&apos;six&apos;,6)]</span><br><span class="line">&gt;&gt;&gt; od1.update(kvs)</span><br><span class="line">&gt;&gt;&gt; for k,v in od1.items():print(k,v)</span><br><span class="line">... </span><br><span class="line">one 1</span><br><span class="line">two 2</span><br><span class="line">three 3</span><br><span class="line">four 4</span><br><span class="line">five 5</span><br><span class="line">six 6</span><br></pre></td></tr></table></figure>

<p>The OrderedDict is often used in conjunction with the sorted method to create a sorted dictionary.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; od3 = OrderedDict(sorted(od1.items(),key = lambda t:(4*t[1])-t[1]**2))</span><br><span class="line">&gt;&gt;&gt; od3.values()</span><br><span class="line">odict_values([6, 5, 4, 1, 3, 2])</span><br><span class="line">&gt;&gt;&gt; od3</span><br><span class="line">OrderedDict([(&apos;six&apos;, 6), (&apos;five&apos;, 5), (&apos;four&apos;, 4), (&apos;one&apos;, 1), (&apos;three&apos;, 3), (&apos;two&apos;, 2)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>The defaultdict object is a subclass of dict and therefore they share methods and operations. It acts as a convenient way to initialize dictionaries. With a dict , Python will throw a KeyError when attempting to access a key that is not already in the dictionary. The defaultdict overrides one method, <strong>missing</strong>(key) , and creates a new instance variable, default_factory . With defaultdict , rather than throw an error, it will run the function, supplied as the default_factory argument, which will generate a value. A simple use of defaultdict is to set default_factory to int and use it to quickly tally the counts of items in the dictionary, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def isprimary(c):</span><br><span class="line">...     if(c==&apos;red&apos;) or (c==&apos;blue&apos;) or (c==&apos;green&apos;):</span><br><span class="line">...             return True</span><br><span class="line">...     else:</span><br><span class="line">...             return False</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd2=defaultdict(bool)</span><br><span class="line">&gt;&gt;&gt; dd2</span><br><span class="line">defaultdict(&lt;class &apos;bool&apos;&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; words=[&apos;blue&apos;,&apos;green&apos;,&apos;red&apos;,&apos;yellow&apos;]</span><br><span class="line">&gt;&gt;&gt; for word in words:dd2[word]=isprimary(word)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; dd2</span><br><span class="line">defaultdict(&lt;class &apos;bool&apos;&gt;, &#123;&apos;blue&apos;: True, &apos;green&apos;: True, &apos;red&apos;: True, &apos;yellow&apos;: False&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Named-tuples"><a href="#Named-tuples" class="headerlink" title="Named tuples"></a>Named tuples</h2><p>The namedtuple method returns a tuple-like object that has fields accessible with named indexes as well as the integer indexes of normal tuples.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import namedtuple</span><br><span class="line">&gt;&gt;&gt; space = namedtuple(&apos;space&apos;,&apos;x y z&apos;)</span><br><span class="line">&gt;&gt;&gt; space</span><br><span class="line">&lt;class &apos;__main__.space&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; s1 = space(x=2.0,y=4.0,z=10)#we can also use space(2.0,4.0,10)</span><br><span class="line">&gt;&gt;&gt; s1.x*s1.y*s1.z#calculates the volume</span><br><span class="line">80.0</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>The namedtuple method take two optional Boolean arguments, verbose and rename . When verbose is set to True then the class definition is printed when it is built. This argument is depreciated in favor of using the __source attribute. When the rename argument is set to True then any invalid field names will be automatically replaced with positional arguments. As an example, we attempt to use def as a field name. This would normally generate an error, but since we have assigned rename to True , the Python interpreter allows this. However, when we attempt to look up the def value, we get a syntax error, since def is a reserved keyword. The illegal field name has been replaced by a field name created by adding an underscore to the positional value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; space2 = namedtuple(&apos;space2&apos;,&apos;x def z&apos;,rename=True)</span><br><span class="line">&gt;&gt;&gt; s1 = space2(3,4,5)</span><br><span class="line">&gt;&gt;&gt; s.def</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    s.def</span><br><span class="line">        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">space2(x=3, _1=4, z=5)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>In addition to the inherited tuple methods, the named tuple also defines three methods of its own, _make() , asdict() , and _replace . These methods begin with an underscore to prevent potential conflicts with field names. The _make() method takes an iterable as an argument and turns it into a named tuple object, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sl=[4,5,6]</span><br><span class="line">&gt;&gt;&gt; space._make(sl)</span><br><span class="line">space(x=4, y=5, z=6)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>_asdict</code> method returns an OrderedDict with the field names mapped to index keys and the values mapped to the dictionary values, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1._asdict()</span><br><span class="line">OrderedDict([(&apos;x&apos;, 3), (&apos;_1&apos;, 4), (&apos;z&apos;, 5)])</span><br></pre></td></tr></table></figure>

<p>The _replace method returns a new instance of the tuple, replacing the specified values,<br>for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[82]: s1._replace(x=7, z=9)</span><br><span class="line">Out[82]: space2 (x=7, _l=4, z=9)</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>The array module defines a datatype array that is similar to the list datatype except for the constraint that their contents must be of a single type of the underlying representation, as is determined by the machine architecture or underlying C implementation.</p>
<p>The array objects support the following attributes and methods:<br>Attributed or method Description<br>Method|Description<br>—|—<br>a.typecode|The typecode character used to create the array.<br>a.itemsize|Size,in bytes of items stored in the array.<br>a.append(x)|Appends item x to the end of the array.<br>a.buffer_info()|Returns the memory location and length of the buffer userd to store the array.<br>a.byteswap()|Swaps the byte order of each item.Used for writing to a machine or file with a different byte order.<br>a.count(x)|Returns the number of occurrences of x in a .<br>a.extend(b)|Appends any iterable, b , to the end of array a .<br>a.frombytes(s)|Appends items from a string, s , as an array of machine values.<br>a.fromfile(f, n)|Reads n items, as machine values, from a file object, f , and appends them to a . Raises an EOFError if there are fewer than n items in n .<br>a.fromlist(l)|Appends items from list l .<br>a.fromunicode(s)|Extends a with unicode string s . Array a must be of type u or else ValueError is raised.<br>index(x)|Returns the first (smallest) index of item x.<br>a.insert(i, x)|Inserts item x before index i.<br>a.pop([i])|Removes and returns items with index i . Defaults to the last item (i = -1) if not specified.<br>a.remove(x)|Removes the first occurrence of item x .<br>a.reverse()|Reverses the order of items.<br>a.tobytes()|Convert the array to machine values and returns the bytes representation.<br>a.tofile(f)|Writes all items, as machine values, to file object f.<br>a.tolist()|Converts the array to a list.<br>a.tounicode()|Convert an array to unicode string. The array type must be ‘u’ or else a ValueError is raised.</p>
<p>Array objects support all the normal sequence operations such as indexing, slicing, concatenation, and multiplication.</p>
<p>因为我们对节省空间感兴趣，也就是说，我们正在处理大型数据集和有限的内存大小，所以我们通常在数组上执行就地操作，并且只在需要时创建副本。 通常，枚举用于对每个元素执行操作。 在下面的代码片段中，我们执行向数组中的每个项添加一个的简单操作：<br>应该注意的是，当对创建列表的数组（例如列表推导）执行操作时，首先使用数组的内存效率增益将被否定。 当我们需要创建一个新的数据对象时，解决方案是使用生成器表达式来执行操作，例如：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/2019-6-19-直击招聘3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019-6-19-直击招聘3/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h1><p>通用算法是用来操作容器中的数据的模板函数。算法部分主要由头文件<algorithm>、<numeric>、<functional>组成。<br>STL中算法大致可以分为以下4类：</functional></numeric></algorithm></p>
<ul>
<li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li>
<li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li>
<li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li>
<li>数值算法：对容器内容进行数值计算</li>
</ul>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul>
<li>adjacent_find()：在iterator对指定的元素范围内查找一对相邻重复元素，若找到，返回指向这对元素的第一个元素的位置，否则返回last。</li>
<li>binary_search()：在有序序列中二分查找value，若找到，返回true</li>
<li>count()：利用等于运算符把指定范围内的元素与输入值相比较，返回相等元素的个数。</li>
<li>count_if()：利用给定的谓词对指定范围内的元素进行操作，返回结果为true的个数。</li>
<li>find()：利用底层元素的等于运算符对指定范围内的元素与输入值进行比较，当匹配时结束，返回该元素的一个位置。</li>
<li>find_if()：使用给定的谓词代替等于运算符执行find。</li>
<li>lower_bound()：返回一个迭代器，指向在有序序列范围内插入指定值而不破坏容器顺序的第一个位置。</li>
<li>upper_bound()：返回一个迭代器，指向在有序序列范围内插入指定值而不破坏容器顺序的最后一个位置，该位置是一个大于value的值。</li>
</ul>
<p>InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);<br>其中first和last是两个迭代器确定查找的序列范围；pred为谓词对象，用于执行某种动作或者操作，通常返回true或者false，像==比较运算符就是这样的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stud(<span class="keyword">int</span> n, <span class="built_in">string</span> na) :no(n), name(na) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; no &lt;&lt; <span class="string">","</span> &lt;&lt; name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">Getname</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> test;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cmp(<span class="built_in">string</span> str) :test(str) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Stud &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s.Getname() == test;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stud a[]&#123; Stud(<span class="number">2</span>,<span class="string">"Marry"</span>),Stud(<span class="number">1</span>,<span class="string">"John"</span>),Stud(<span class="number">3</span>,<span class="string">"Smith"</span>) &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">vector</span>&lt;Stud&gt;myv(a, a + n);</span><br><span class="line">	<span class="built_in">vector</span>&lt;Stud&gt;::iterator it;</span><br><span class="line">	it = find_if(myv.begin(), myv.end(), Cmp(<span class="string">"Marry"</span>));</span><br><span class="line">	it-&gt;Disp();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序中，Cmp是一个谓词对象类，执行find_if(myv.begin(),myv.end(),Cmp(“Marry”))语句时第3个实参Cmp(“Marry”)创建一个Cmp对象并赋值给形参pred。find_if()通过调用pred进行元素的查找，而Cmp中重载了函数调用()运算符，所以执行该重载运算符实现元素的查找，成功时返回其位置（即no为2）的元素。</p>
<h3 id="排序和通用算法"><a href="#排序和通用算法" class="headerlink" title="排序和通用算法"></a>排序和通用算法</h3><p>这类算法用于提供元素排序策略。</p>
<ul>
<li>merge()：合并两个有序序列，存放到另一个序列。</li>
<li>nth_element()：将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它的前面，大于它的出现在它的后面。</li>
<li>partial_sort()：对序列做部分排序，被排序的元素个数正好可以被放到范围内。</li>
<li>partition()：对指定范围内的元素重新排序，使用关系函数，把结果为true的元素放在结果为false的元素之前。</li>
<li>reverse()：将指定范围内的元素重新反序排序。</li>
<li>reverse_copy()：与reverse()类似，不过将结果写到另一个容器。</li>
<li>rotate()：将指定范围内的元素移到容器末尾，由middle指向的元素成为容器的第一个元素。例如，hissboo以元素’b’旋转后变为boohiss。</li>
<li>rotate_copy()</li>
<li>sort()：默认以升序重新排列</li>
<li>stable_sort()：采用稳定排序方法</li>
</ul>
<p>以partition()为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;myv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myv.begin(); it != myv.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Less0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myv(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myv: "</span>; Disp(myv);</span><br><span class="line">	partition(myv.begin(), myv.end(), Less0());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myv: "</span>; Disp(myv);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除和替换算法"><a href="#删除和替换算法" class="headerlink" title="删除和替换算法"></a>删除和替换算法</h3><ul>
<li>copy()：复制序列</li>
<li>copy_backward()：与copy()相同，不过元素是以相反的顺序被复制。</li>
<li>remove()：删除指定范围内所有等于指定元素的元素。注意，该函数不是真正的删除函数。内置数组不适合使用remove和remove_if函数。</li>
<li>remove_if()：删除指定范围内谓词结果为true的所有元素。</li>
<li>replace()：将指定范围内所有等于old_value的元素用new_value代替。</li>
<li>unique()：清除序列中的重复元素，和remove类似，它也不能真正地删除元素。</li>
<li>unique_copy()：与unique()类似，但是把结果输出到另一个容器。</li>
</ul>
<h3 id="排列组合算法"><a href="#排列组合算法" class="headerlink" title="排列组合算法"></a>排列组合算法</h3><p>这类算法提供计算给定集合按一定顺序的所有可能排列组合。</p>
<ul>
<li>next_permutation()：取出当前范围内的排列，并重新排列为下一个序列。</li>
<li>prev_permutation()：取出指定范围内的序列，并将它重新排序为上一个序列。</li>
</ul>
<h3 id="生成和异变算法"><a href="#生成和异变算法" class="headerlink" title="生成和异变算法"></a>生成和异变算法</h3><ul>
<li>fill()：将输入值赋给指定范围内的所有元素。</li>
<li>fill_n()：将输入值赋给first到first+n范围内的所有元素。</li>
<li>for_each()：用指定函数依次对指定范围内的所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;myv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>(*pf)(<span class="keyword">int</span>) = print;</span><br><span class="line">	for_each(myv.begin(), myv.end(), pf);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="关系算法"><a href="#关系算法" class="headerlink" title="关系算法"></a>关系算法</h3><ul>
<li>equal()</li>
<li>include()：判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;运算符，若成功返回true。</li>
<li>lexicographical_compare()：比较两个序列。</li>
<li>max()</li>
<li>max_element()</li>
<li>min()</li>
<li>min_element()</li>
</ul>
<h3 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h3><ul>
<li>set_union()：并集运算，构造一个有序序列，包含两个序列中所有的不重复元素</li>
<li>set_intersection()：交集运算，构造一个有序序列，其中元素在两个序列中都存在。</li>
<li>set_difference()：差集运算，构造一个有序序列，该序列仅保留第一个序列中存在的但第二个序列中不存在的元素。</li>
</ul>
<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><ul>
<li>make_heap()：将指定范围内的元素做成一个堆</li>
<li>pop_heap()：从堆中弹出一个元素</li>
<li>push_heap()：将一个元素插入堆中</li>
<li>sort_heap()：将指定范围的元素进行堆排序（假设初始序列是一个堆）。</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>string相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还包含了所有的序列容器的操作。字符串的常用操作包括增、删、查、改、比较、链接、输入、输出等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MatchFirstChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"S"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> s == str.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; myv;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it;</span><br><span class="line">	myv.push_back(<span class="string">"She"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Sea"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Shells"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"by"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"the"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Sea"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Shore"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myv: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (it = myv.begin(); it != myv.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> n = count_if(myv.begin(), myv.end(), MatchFirstChar);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"以 S 开头的元素个数："</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaohui Bai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BaiZhaohui" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:isolatedislet@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaohui Bai</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Mist">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mist">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mist">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Mist</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mist</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/Keras functional API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/Keras functional API/" itemprop="url">Keras functional API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T09:59:20+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="Keras-functional-API-是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。"><a href="#Keras-functional-API-是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。" class="headerlink" title="Keras functional API 是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。"></a>Keras functional API 是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。</h5><h4 id="例1：全连接网络"><a href="#例1：全连接网络" class="headerlink" title="例1：全连接网络"></a>例1：全连接网络</h4><p>其实对于实现全连接网络，<code>Sequential</code>模型是更好的选择。</p>
<ul>
<li>层的实例可以被调用（on a tensor)，并且返回一个tensor</li>
<li>使用输入输出张量来定义<code>Model</code></li>
<li>这种模型可以像<code>Sequential</code>模型一样训练。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Input,Dense</span><br><span class="line">from keras.models import Model</span><br><span class="line"># This returns a tensor</span><br><span class="line">inputs = Input(shape=(784,))</span><br><span class="line"></span><br><span class="line"># a layer instance is callable on a tensor, and returns a tensor</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(inputs)</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line">predictions = Dense(10,activation=&apos;softmax&apos;)(x)</span><br><span class="line"></span><br><span class="line"># This creates a model that includes</span><br><span class="line"># the Input layer and three Dense layers</span><br><span class="line">model = Model(inputs=inputs,outputs=predictions)</span><br><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,</span><br><span class="line">              loss=&apos;categorical_crossentropy&apos;,</span><br><span class="line">              metrics=[&apos;accuracy&apos;])</span><br><span class="line">model.fit(data,labels) # starts training</span><br></pre></td></tr></table></figure>

<h4 id="所有模型都可以像层一样调用"><a href="#所有模型都可以像层一样调用" class="headerlink" title="所有模型都可以像层一样调用"></a>所有模型都可以像层一样调用</h4><h5 id="使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。"><a href="#使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。" class="headerlink" title="使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。"></a>使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Input(shape=(784,))</span><br><span class="line"># This works, and returns the 10-way softmax we defined above.</span><br><span class="line">y = model(x)</span><br></pre></td></tr></table></figure>

<h5 id="这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。"><a href="#这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。" class="headerlink" title="这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。"></a>这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import TimeDistributed</span><br><span class="line"># Input tensor for sequences of 20 timesteps</span><br><span class="line"># each containing a 784-dimensional vector</span><br><span class="line">input_sequences =Input(shape=(20,784))</span><br><span class="line"></span><br><span class="line"># This applies our previous model to every timestep in the input sequences.</span><br><span class="line"># the output of the previous model was a 10-way softmax</span><br><span class="line"># so the output of the layer below will be a sequence of 20 vectors of size 10.</span><br><span class="line">processed_sequences = TimeDistributed(model)(input_sequences)</span><br></pre></td></tr></table></figure>

<h4 id="多输入和多输出模型"><a href="#多输入和多输出模型" class="headerlink" title="多输入和多输出模型"></a>多输入和多输出模型</h4><h5 id="functional-API-使操作大量交织在一起的数据流变得容易。"><a href="#functional-API-使操作大量交织在一起的数据流变得容易。" class="headerlink" title="functional API 使操作大量交织在一起的数据流变得容易。"></a>functional API 使操作大量交织在一起的数据流变得容易。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from keras.layres import Input,Embedding,LSTM,Dense</span><br><span class="line">from keras.models import Model</span><br><span class="line"></span><br><span class="line"># Headline input: meant to receive sequences of 100 integersm,between 1 and 10000.</span><br><span class="line"># Note that we can name any layer by passing it a &quot;name&quot; argument.</span><br><span class="line">main_input = Input(shape=(100,),dtype=&apos;int32&apos;,name=&apos;main_input&apos;)</span><br><span class="line"></span><br><span class="line"># This embedding layer will encode the input sequence</span><br><span class="line"># into a sequence of dense 512-dimensional vectors.</span><br><span class="line">x = Embedding(output_dim=512,input_dim=10000,input_length=100)(main_input)</span><br><span class="line"></span><br><span class="line"># A LSTM will transform the vector sequence into a single vector,</span><br><span class="line"># containing information about the entire sequence</span><br><span class="line">lstm_out = LSTM(32)(x)</span><br><span class="line">auxiliary_output = Dense(1,activation=&apos;sigmoid&apos;,name=&apos;aux_output&apos;)(lstm_out)</span><br><span class="line"></span><br><span class="line">auxiliary_input = Input(shape=(5,),name=&apos;aux_input&apos;)</span><br><span class="line">x = keras.layers.concatenate([lstm_out,auxiliary_input])</span><br><span class="line"></span><br><span class="line"># We stack a deep densely-connected network on top</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line"></span><br><span class="line"># And finally we add the main logistic regression layer</span><br><span class="line">main_output = Dense(1,activation=&apos;sigmoid&apos;,name=&apos;main_output&apos;)(x)</span><br></pre></td></tr></table></figure>

<h5 id="这定义了一个具有两个输入和两个输出的模型："><a href="#这定义了一个具有两个输入和两个输出的模型：" class="headerlink" title="这定义了一个具有两个输入和两个输出的模型："></a>这定义了一个具有两个输入和两个输出的模型：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Model(inputs=[main_input,auxiliary_input],outputs=[main_output,auxiliary_output])</span><br></pre></td></tr></table></figure>

<h5 id="我们编译模型并为辅助损失分配0-2的权重。要为不同的输出指定不同的loss-weights或loss，可以使用列表或字典。这里我们传递一个损失作为loss参数，因此所有输出都将使用相同的损失。"><a href="#我们编译模型并为辅助损失分配0-2的权重。要为不同的输出指定不同的loss-weights或loss，可以使用列表或字典。这里我们传递一个损失作为loss参数，因此所有输出都将使用相同的损失。" class="headerlink" title="我们编译模型并为辅助损失分配0.2的权重。要为不同的输出指定不同的loss_weights或loss，可以使用列表或字典。这里我们传递一个损失作为loss参数，因此所有输出都将使用相同的损失。"></a>我们编译模型并为辅助损失分配0.2的权重。要为不同的输出指定不同的loss_weights或loss，可以使用列表或字典。这里我们传递一个损失作为<code>loss参数</code>，因此所有输出都将使用相同的损失。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;binary_crossentropy&apos;,</span><br><span class="line">              loss_weights=[1.,0.2])</span><br></pre></td></tr></table></figure>

<h5 id="我们可以通过传递输入数组和目标数组的列表来训练模型："><a href="#我们可以通过传递输入数组和目标数组的列表来训练模型：" class="headerlink" title="我们可以通过传递输入数组和目标数组的列表来训练模型："></a>我们可以通过传递输入数组和目标数组的列表来训练模型：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.fit([heading_data,additional_data],[labels,labels],</span><br><span class="line">          epochs=50,batch_size=32)</span><br></pre></td></tr></table></figure>

<h5 id="由于我们的输入和输出被命名（我们传递了一个“name”参数），我们也可以通过以下方式编译模型："><a href="#由于我们的输入和输出被命名（我们传递了一个“name”参数），我们也可以通过以下方式编译模型：" class="headerlink" title="由于我们的输入和输出被命名（我们传递了一个“name”参数），我们也可以通过以下方式编译模型："></a>由于我们的输入和输出被命名（我们传递了一个“<code>name</code>”参数），我们也可以通过以下方式编译模型：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,</span><br><span class="line">              loss=&#123;&apos;main_output&apos;:&apos;binary_crossentropy&apos;,&apos;aux_output&apos;:&apos;binary_crossentropy&apos;&#125;,</span><br><span class="line">              loss_weight=&#123;&apos;main_output&apos;:1.,&apos;aux_output&apos;:0.2&#125;)</span><br><span class="line">              </span><br><span class="line"># And trained it via:</span><br><span class="line">model.fit(&#123;&apos;main_input&apos;:headline_data,&apos;aux_output&apos;:additional_data&#125;,</span><br><span class="line">          &#123;&apos;main_output&apos;:labels,&apos;aux_ouput&apos;:labels&#125;,</span><br><span class="line">          epochs=50,batch_size=32)</span><br></pre></td></tr></table></figure>

<h5 id="共享层"><a href="#共享层" class="headerlink" title="共享层"></a>共享层</h5><p>使用函数API的另一个好处是模型可以使用共享层。<br>例子：<br>建立一个模型来判断两条推特是不是同一个用户所发。（可以通过比较推文的相似性来确定）<br>将两条推文编码成两个向量并连接，添加逻辑回归层，这将输出两条推文来自同一用户的概率。使用来自同一用户的两条推文（正），不是同一用户所发的两条推文（负）来训练模型。<br>由于问题是对称的，编码第一条推文的机制（包括权重等）将被重用来编码第二条推文。这里使用LSTM层来编码推文。<br>使用函数式 API 来构建模型。首先我们将一条推特转换为一个尺寸为 (280, 256) 的矩阵，即每条推特 280 字符，每个字符为 256 维的 one-hot 编码向量 （取 256 个常用字符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import keras</span><br><span class="line">from keras.layers import Input,LSTM,Dense</span><br><span class="line">from keras.models import Model</span><br><span class="line"></span><br><span class="line">tweet_a = Input(shape=(280,256)</span><br><span class="line">tweet_b = Input(shape=(280,256)</span><br></pre></td></tr></table></figure>

<p>要在不同的输入上共享同一个层，只需实例化该层一次，然后根据需要传入你想要的输入即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># This layer can take as input a matrix</span><br><span class="line"># and will return a vector of size 64</span><br><span class="line">shared_lstm = LSTM(64)</span><br><span class="line"></span><br><span class="line"># When we reuse the same layer instance</span><br><span class="line"># multiple times,the weights of layer</span><br><span class="line"># are also being reused</span><br><span class="line"># (it is effectively *the same* layer)</span><br><span class="line">encoded_a = shared_lstm(tweet_a)</span><br><span class="line">encoded_b = shared_lstm(tweet_b)</span><br><span class="line"></span><br><span class="line"># We can then concatenate the two vectors:</span><br><span class="line">merged_vector = keras.layers.concatenate([encoded_a,encoded_b]),axis=-1)</span><br><span class="line"></span><br><span class="line"># And add a logistic regression on top</span><br><span class="line">predictions = Dense(1,activation=&apos;sigmoid&apos;)(merged_vector)</span><br><span class="line"></span><br><span class="line"># We defined a trainable model linking the</span><br><span class="line"># tweet inputs to the predictions</span><br><span class="line"># 定义一个连接推特输入和预测的可训练的模型</span><br><span class="line">model = Model(inputs=[tweet_a,tweet_b],outputs=predictions)</span><br><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,</span><br><span class="line">              loss=&apos;binary_crossentropy&apos;,</span><br><span class="line">              metrics=[&apos;accuracy&apos;])</span><br><span class="line">model.fit([data_a,data_b],labels,epochs=10)</span><br></pre></td></tr></table></figure>

<h5 id="如何读取共享层的输出或输出尺寸"><a href="#如何读取共享层的输出或输出尺寸" class="headerlink" title="如何读取共享层的输出或输出尺寸?"></a>如何读取共享层的输出或输出尺寸?</h5><h4 id="层节点（The-concept-of-layer-“node”）"><a href="#层节点（The-concept-of-layer-“node”）" class="headerlink" title="层节点（The concept of layer “node”）"></a>层节点（The concept of layer “node”）</h4><p>每当你在某个输入上调用一个层时，都将创建一个新的张量（层的输出），并且为该层添加一个「节点」，将输入张量连接到输出张量。当多次调用同一个图层时，该图层将拥有多个节点索引 (0, 1, 2…)。<br>在之前版本的 Keras 中，可以通过 <code>layer.get_output()</code> 来获得层实例的输出张量，或者通过 <code>layer.output_shape</code> 来获取其输出形状。现在你依然可以这么做（除了 <code>get_output()</code> 已经被 <code>output</code> 属性替代）。但是如果一个层与多个输入连接呢？</p>
<p>只要一个层仅仅连接到一个输入，就不会有困惑，<code>.output</code> 会返回层的唯一输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = Input(shape=(280,256))</span><br><span class="line">lstm = LSTM(32)</span><br><span class="line">encoded_a = lstm(a)</span><br><span class="line">assert lstm.output == encoded_a</span><br></pre></td></tr></table></figure>

<p>但是如果该层有多个输入，那就会出现问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = Input(shape=(280,256))</span><br><span class="line">b = Input(shape=(280,256))</span><br><span class="line"></span><br><span class="line">lstm = LSTM(32)</span><br><span class="line">encoded_a = lstm(a)</span><br><span class="line">encoded_b = lstm(b)</span><br><span class="line"></span><br><span class="line">lstm.output</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; AttributeError: Layer lstm_1 has multiple inbound nodes,</span><br><span class="line">hence the notion of &quot;layer output&quot; is ill-defined.</span><br><span class="line">Use `get_output_at(node_index)` instead.</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert lstm.get_output_at(0) == encoded_a</span><br><span class="line">assert lstm.get_output_at(1) == encoded_b</span><br></pre></td></tr></table></figure>

<p><code>input_shape</code> 和 <code>output_shape</code> 这两个属性也是如此：只要该层只有一个节点，或者只要所有节点具有相同的输入/输出尺寸，那么「层输出/输入尺寸」的概念就被很好地定义，并且将由 <code>layer.output_shape / layer.input_shape</code> 返回。但是比如说，如果将一个 <code>Conv2D</code> 层先应用于尺寸为 <code>(32，32，3)</code> 的输入，再应用于尺寸为 <code>(64, 64, 3)</code> 的输入，那么这个层就会有多个输入/输出尺寸，你将不得不通过指定它们所属节点的索引来获取它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = Input(shape=(32,32,3))</span><br><span class="line">b = Input(shape=(64,64,3))</span><br><span class="line"></span><br><span class="line">conv = Conv2D(16,(3,3),padding=&apos;same&apos;)</span><br><span class="line">conved_a = conv(a)</span><br><span class="line"></span><br><span class="line">#Only one input so far,the following will work:</span><br><span class="line">assert conv.input_shape == (None,32,32,3)</span><br><span class="line"></span><br><span class="line">conved_b = conv(b)</span><br><span class="line"># now the &apos;.input_shape&apos; property wouldn&apos;t work,but this does:</span><br><span class="line">assert conv.get_input_shape_at(0) == (None,32,32,3)</span><br><span class="line">assert conv.get_input_shape_at(1) == (None,64,64,3)</span><br></pre></td></tr></table></figure>

<h4 id="更多的例子"><a href="#更多的例子" class="headerlink" title="更多的例子"></a>更多的例子</h4><h5 id="Inception模型"><a href="#Inception模型" class="headerlink" title="Inception模型"></a>Inception模型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,MaxPooling2D,Input</span><br><span class="line"></span><br><span class="line">input_img = Input(shape=(256,256,3))</span><br><span class="line"></span><br><span class="line">tower_1 = Conv2D(64,(1,1),padding=&apos;same&apos;,activation=&apos;relu&apos;)(input_img)</span><br><span class="line">tower_1 = Conv2D(64,(3,3),padding=&apos;same&apos;,activation=&apos;relu&apos;)(tower_1)</span><br><span class="line"></span><br><span class="line">tower_2 = Conv2D(64,(1,1),padding=&apos;same&apos;,activation=&apos;relu&apos;)(input_img)</span><br><span class="line">tower_2 = Conv2D(64,(5,5),padding=&apos;same&apos;,activation=&apos;relu&apos;)(tower_2)</span><br><span class="line"></span><br><span class="line">tower_3 = MaxPooling2D((3,3),strides=(1,1),padding=&apos;same&apos;)(input_img)</span><br><span class="line">tower_3 = Conv2D(64,(1,1),padding=&apos;same&apos;,activation=&apos;relu&apos;)(tower_3)</span><br><span class="line"></span><br><span class="line">output = keras.layers.concatenate([tower_1,tower_2,tower_3],axis=1)</span><br></pre></td></tr></table></figure>

<h5 id="卷积层上的残差连接"><a href="#卷积层上的残差连接" class="headerlink" title="卷积层上的残差连接"></a>卷积层上的残差连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,Input</span><br><span class="line"># input tensor for a 3-channel 256x256 image</span><br><span class="line">x = Input(shape=(256,256,3))</span><br><span class="line"># 3x3 conv with 3 output channels (same as input channels)</span><br><span class="line">y = Conv2D(3,(3,3),padding=&apos;same&apos;)(x)</span><br><span class="line"># this returns x+y</span><br><span class="line">z = keras.layers.add([x,y])</span><br></pre></td></tr></table></figure>

<h5 id="共享视觉模型"><a href="#共享视觉模型" class="headerlink" title="共享视觉模型"></a>共享视觉模型</h5><p>该模型在两个输入上重复使用同一个图像处理模块，以判断两个 MNIST 数字是否为相同的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,MaxPooling2D,Input,Dense,Flatten</span><br><span class="line">from keras.models import Model</span><br><span class="line"></span><br><span class="line"># First,define the vision modules</span><br><span class="line">digit_input = Input(shape=(27,27,1))</span><br><span class="line">x = Conv2D(64,(3,3))(digit_input)</span><br><span class="line">x = Conv2D(64,(3,3))(x)</span><br><span class="line">x = MaxPooling2D((2,2))(x)</span><br><span class="line">out = Flatten()(x)</span><br><span class="line"></span><br><span class="line">vision_model = Model(digit_input,out)</span><br><span class="line"></span><br><span class="line"># Then define the tell-digits-apart model</span><br><span class="line">digit_a = Input(shape=(27,27,1))</span><br><span class="line">digit_b = Input(shape=(27,27,1))</span><br><span class="line"></span><br><span class="line"># The vision model will be shared,weights and all</span><br><span class="line">out_a = vision_model(digit_a)</span><br><span class="line">out_b = vision_model(digit_b)</span><br><span class="line"></span><br><span class="line">concatenated = keras.layers.concatenate([out_a,out_b])</span><br><span class="line">out = Dense(1,activation=&apos;sigmoid&apos;)(concatenated)</span><br><span class="line"></span><br><span class="line">classification_model = Model([digit_a,digit_b],out)</span><br></pre></td></tr></table></figure>

<h5 id="视觉问答模型"><a href="#视觉问答模型" class="headerlink" title="视觉问答模型"></a>视觉问答模型</h5><p>当被问及关于图片的自然语言问题时，该模型可以选择正确的单词作答。<br>它通过将问题和图像编码成向量，然后连接两者，在上面训练一个逻辑回归，来从词汇表中挑选一个可能的单词作答。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,MaxPooling2D,Flatten</span><br><span class="line">from keras.layers import Input,LSTM,Embedding,Dense</span><br><span class="line">from keras.models import Model,Sequential</span><br><span class="line"># First,let&apos;s define a vision model using a Sequential model</span><br><span class="line"># This model will encode an image into a vector</span><br><span class="line">vision_model = Sequential()</span><br><span class="line">vision_model.add(Conv2D(64,(3,3),activation=&apos;relu&apos;,padding=&apos;same&apos;,input_shape=(224,224,3)))</span><br><span class="line">vision_model.add(Conv2D(64,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(MaxPooling2D((2,2)))</span><br><span class="line">vision_model.add(Conv2D(128,(3,3),activation=&apos;relu&apos;,padding=&apos;same&apos;))</span><br><span class="line">vision_model.add(Conv2D(128,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(MaxPooling2D((2,2)))</span><br><span class="line">vision_model.add(Conv2D(256,(3,3),activation=&apos;relu&apos;,padding=&apos;same&apos;))</span><br><span class="line">vision_model.add(Conv2D(256,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(Conv2D(256,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(MaxPooling2D((2,2)))</span><br><span class="line">vision_model.add(Flatten())</span><br><span class="line"></span><br><span class="line"># Now let&apos;s get a tensor with the output of our vision model:</span><br><span class="line">image_input = Input(shape=(224,224,3))</span><br><span class="line">encoded_image = vision_model(image_input)</span><br><span class="line"></span><br><span class="line"># Next,let&apos;s define a language model to encode the question into a vector.</span><br><span class="line"># Each question will be at most 100 word long,</span><br><span class="line"># and we will index words as integers from 1 to 9999</span><br><span class="line">question_input = Input(shape=(100,),dtype=&apos;int32&apos;)</span><br><span class="line">embedded_question = Embedding(input_dim=10000,output_dim=256,input_length=100)(question_input)</span><br><span class="line">encoded_question = LSTM(256)(embedded_question)</span><br><span class="line"></span><br><span class="line"># Let&apos;s concatenate the question vector and the image vector:</span><br><span class="line">merged = keras.layers.concatenate([encoded_question,encoded_image])</span><br><span class="line"></span><br><span class="line"># And let&apos;s train a logistic regression over 1000 words on top:</span><br><span class="line">output = Dense(1000,activation=&apos;softmax&apos;)(merged)</span><br><span class="line"></span><br><span class="line"># This is our final model:</span><br><span class="line">vqa_model = Model(inputs=[image_input,question_input],outputs=output)</span><br><span class="line"># The next stage would be training this model on actual data.</span><br></pre></td></tr></table></figure>

<h5 id="视频问答模型"><a href="#视频问答模型" class="headerlink" title="视频问答模型"></a>视频问答模型</h5><p>现在我们已经训练了图像问答模型，我们可以很快地将它转换为视频问答模型。在适当的训练下，你可以给它展示一小段视频（例如 100 帧的人体动作），然后问它一个关于这段视频的问题（例如，「这个人在做什么运动？」 -&gt; 「足球」）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import TimeDistributed</span><br><span class="line"></span><br><span class="line">video_input = Input(shape=(100, 224, 224, 3))</span><br><span class="line"># 这是基于之前定义的视觉模型（权重被重用）构建的视频编码</span><br><span class="line">encoded_frame_sequence = TimeDistributed(vision_model)(video_input)  # 输出为向量的序列</span><br><span class="line">encoded_video = LSTM(256)(encoded_frame_sequence)  # 输出为一个向量</span><br><span class="line"></span><br><span class="line"># 这是问题编码器的模型级表示，重复使用与之前相同的权重：</span><br><span class="line">question_encoder = Model(inputs=question_input, outputs=encoded_question)</span><br><span class="line"></span><br><span class="line"># 让我们用它来编码这个问题：</span><br><span class="line">video_question_input = Input(shape=(100,), dtype=&apos;int32&apos;)</span><br><span class="line">encoded_video_question = question_encoder(video_question_input)</span><br><span class="line"></span><br><span class="line"># 这就是我们的视频问答模式：</span><br><span class="line">merged = keras.layers.concatenate([encoded_video, encoded_video_question])</span><br><span class="line">output = Dense(1000, activation=&apos;softmax&apos;)(merged)</span><br><span class="line">video_qa_model = Model(inputs=[video_input, video_question_input], outputs=output)</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/C++基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/C++基础/" itemprop="url">C++ 编程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T09:58:04+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>main 并非程序语言定义的关键词。但是，执行C++程序的编译系统时，会假设程序中定义有main()函数。如果没有定义，程序将无法执行。<br>数据的输入输出并非C++程序语言本身定义的一部分，而是由C++的一套面向对象类体系（classess hierarchy）提供支持，并作为C++标准程序库（standard library）的一员。</p>
<p>class 的定义通常分为两部分，写于不同的文件。其中之一是“头文件（head file）”，用来声明该 class 所提供的各种操作行为（operations）。另一个文件，程序代码文件（program text），则包含这些操作行为的实现内容（implementation）。</p>
<p>想要使用class ，则必须先在程序中包含其头文件。表头文件可以让程序知道class的定义。<br>iostream 为C++的标准”输入/输出程序库“，其中包含了相关的整套 classes，用以支持对终端机和文件的输入与输出。</p>
<p>string class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> user_name</span><br></pre></td></tr></table></figure>

<p>如此一来便定义了一个名为user_name的对象，它隶属于string class。这样的定义称为“声明语句（declaration statement）”。使用这一语句的时候，必须包含 string class 的头文件，让程序知道 string class 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> string</span></span><br></pre></td></tr></table></figure>

<p>定义新的classes时，应该为每一个class提供它们自己的output运算符。这样可以让classes用户得以像面对内建类型一样地以相同方式输出对象内容。</p>
<p>类型决定了对象所能含有的数值范围，同时也决定了对象应该占用多少内存空间。</p>
<p>另一种初始化语法：“构造函数语法（constructor syntax）”： int num(0);<br>如果对象需要多个初始值，等号赋值的方式就没办法完成任务了。如标准程序库中的复数（complex number）类，它就需要两个初始值，一为实部，一为虚部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; purei(<span class="number">0</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>出现在complex之后的尖括号，表示complex是一个template class（模板类）。 template class 允许我们在“不必指明 data members 之类型”的情况下定义class。<br>举个例子，复数内包含两个member data object。其一表示复数的实数部分，其二表示虚数部分。两者都需要以浮点数来表现，但我们应该采用哪种浮点数类别呢？C++有三种浮点数类别：float，double，long double。template class 机制使程序员得以直到使用 template class 时才决定真正的数据型别。程序员可以先安插一个代名，稍后才绑定至实际的数据型别。上例便是将 complex 类的成员绑定至 double 型别。<br>当“内建数据型别”与“程序员自行定义之class型别”具备不同的初始化语法时，我们无法撰写出一个 template，使它同时支持“内建型别”与“class 型别”，让语法统一，可以简化template的设计。</p>
<p>被定义为 const 的对象在获得初值后，无法再有任何变动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> line_size = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = line_size;</span><br></pre></td></tr></table></figure>

<p>如果测试条件属于整数型别，可用switch来替换if语句。</p>
<p>可利用continue语句来终止循环的现行迭代（current iteration）。</p>
<p>array的尺度必须是个常量表达式（constant expression），也就是一个不需要在执行期间计算其值的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seq_size = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> pell_seq[seq_size];</span><br></pre></td></tr></table></figure>

<p>vector 是个 class template，故必须在类名称之后的尖括号里指定其元素型别，其尺度则写在小括号中；此处所给予的尺度并不一定是常量表达式<br>定义vector object 必须包含vector头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pell_seq(seq_size);</span><br></pre></td></tr></table></figure>

<p>for (init-statement; condition; expression)<br>        statement</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">srand(seq_cnt)</span><br><span class="line">seq_index = rand() % seq_cnt</span><br><span class="line">current_vec = seq_addrs[ seq_index ];</span><br></pre></td></tr></table></figure>

<p>init-statement 会在循环开始前被执行一次。condition在每次循环迭代之前计算出来；expression会在循环每次迭代结束之后被计算。</p>
<p>array 与 vector 的差异：vector 可以知道自己的大小。</p>
<p>指针为程序引入了一层间接性，可以操控指针（代表某特定内存地址），而不再直接操控对象。<br>使用指针时，必须在提领它之前先确定它的确指向某对象。<br>一个未指向任何对象的指针，其内容地址为0。有时候我们称之为null指针。任何指针都可以被初始化，或是令其值为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化每个指针，使它们不指向任何对象</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> *pd = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> *ps = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>为了防止对null指针进行提领操作，我们可以检验该指针所含有的地址是否为0。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( pi &amp;&amp; *pi !=<span class="number">1024</span>)</span><br><span class="line">      *pi = <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pi &amp;&amp;...)</span><br><span class="line">只有在pi含有一个非零值时，其核定结果方才为<span class="literal">true</span>。如果核定结果为<span class="literal">false</span>，那么AND运算符就不会评估其第二表达式。</span><br></pre></td></tr></table></figure>

<p>欲检验某指针是否为null，我们通常使用逻辑运算符NOT：<br>if (!pi) //当 pi 之值为0，此表达式为true</p>
<p>指针符合以下形式：<br>type_of_object_pointed_to * name_of_pointer_object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">srand(seq_cnt);</span><br><span class="line">seq_index = rand() % seq_cnt;</span><br><span class="line">current_vec  = seq_addrs[seq_index];</span><br></pre></td></tr></table></figure>

<p>rand() 和 srand() 都是标准程序库提供的所谓伪随机数（pseudo-random number)产生器。srand()的参数是所谓随机数产生器种子（seed）。每次调用rand()，都会返回一个介于 0 和“ int 所能表示之最大整数”间的一个整数。</p>
<p>使用class object 的指针，和使用内建型别的指针略有不同。这是因为class object 链接到一组我们可以调用（invoke）的操作行为（operations）。  </p>
<p>指针选择行为操作使用 arrow 成员选择运算符 ! pv -&gt; empty()</p>
<p>由于指针可能并未指向任何对象，所以在调用empty()之前，应该先检验pv是否为非零值：<br>pv &amp;&amp; ! pv-&gt;empty()</p>
<p>若需要使用下标运算符，必须先提领pv。由于下标运算符的优先级较高，因此，pv提领操作的两边必须加上小括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pv &amp;&amp; ! pv-&gt;empty() &amp;&amp; ((*pv)[<span class="number">1</span>] == <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>欲对文件进行读写操作，得包含fstream头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>为了开启一个可供输出的文件，我们定义一个ofstream（供输出用的file stream）对象，并将文件名传入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以输出模式开启 seq_data.txt</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"seq_data.txt"</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>如果指定的文件并不存在，便会有一个文件被产生出来，并开启作为输出之后。如果指定的文件已经存在，这个文件会被开启作为输出之用，而文件中原已存在的数据会被丢弃。使用追加模式（append mode）开启文件，可以将新数据追加到原有数据的后面，原有数据不会丢弃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以追加模式（append mode）开启seq_data.txt</span></span><br><span class="line"><span class="comment">// 新数据会被追加到文件尾端</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"seq_data.txt"</span>,ios_base::app)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文件有可能开启失败。在进行写入操作之前，我们必须确定文件的确开启成功。最简单的办法便是检查class object 的真伪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 outfile 的计算结果为 false，表示此文件并未开启成功。</span></span><br><span class="line"><span class="keyword">if</span> (!outfile)</span><br></pre></td></tr></table></figure>

<p>如果文件未能成功开启，ofstream对象会被计算为false。本例中我们将信息写入cerr，告知用户此状况。cerr代表标准错误输出设备（standard error）。和cout一样，cerr将其输出结果导至用户的终端机。两者的唯一差别是，cerr的输出结果并无缓冲（buffered）情形——它会立即显示于用户终端机上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!outfile)</span><br><span class="line">      <span class="comment">// 因为某种原因，文件无法开启</span></span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Oops! Unable to save session data!\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     <span class="comment">// ok: outfile 开启成功，接下来将数据写入</span></span><br><span class="line">     oufile &lt;&lt; usr_name &lt;&lt; ‘ ’</span><br><span class="line">     &lt;&lt; num_tries&lt;&lt; <span class="string">' '</span></span><br><span class="line">     &lt;&lt; num_right &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>如果文件开启顺利，我们便将输出信息导至该文件，就像将信息写入cout及cerr这两个ostream对象一样。本例之中，我们将3个数值写入outfile，并以空格符区分后两个数值。endl 是事先定义好的所谓操控器（manipulator），由iostream library 提供。<br>操控器不会将数据写到iostream，而不会从中读取数据，其作用是在iostream上执行某些操作。endl会插入一个换行符，并清除缓冲区（output buffer）的内容。此外还有更多的操控器，如 hex(以16进制显示整数)、oct（以8进制显示整数）、setprecision(n)（设定浮点数显示精度为n）。</p>
<p>如果要开启一个可供读取的文件，可以定义一个ifstream（ input file stream）对象，并将文件名传入。如果文件未能开启，ifstream对象会被核定为false。如果成功，该文件的写入位置会被设定在起始处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以读取模式 （input mode）开启infile</span></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"seq_data.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> num_tries = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num_cor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (! infile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 由于某种原因，文件无法开启。。。</span></span><br><span class="line">    <span class="comment">// 我们将假设这是一位新用户。。。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ok ，读取这个文件的每一行</span></span><br><span class="line">    <span class="comment">// 检查这个用户曾经是否玩过这个程序</span></span><br><span class="line">    <span class="comment">// 每一行的检查格式是：</span></span><br><span class="line">            name num_tries num_correct</span><br><span class="line">    <span class="comment">// nt :猜过的总次数（num_tries)</span></span><br><span class="line">    <span class="comment">// nc:猜对的总次数（num_correct)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> nt;</span><br><span class="line">    <span class="keyword">int</span> nc;</span><br><span class="line">          <span class="keyword">while</span>(infile&gt;&gt;name)</span><br><span class="line">          &#123;</span><br><span class="line">          infile &gt;&gt; nt &gt;&gt;nc ;</span><br><span class="line">                <span class="keyword">if</span> (name == usr_name)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">//找到他了</span></span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">" Welcome back, "</span>&lt;&lt; usr_name</span><br><span class="line">                        &lt;&lt; <span class="string">" \n Your current score is  "</span>&lt;&lt; nc</span><br><span class="line">                        &lt;&lt; <span class="string">"out of "</span>&lt;&lt;nt&lt;&lt;<span class="string">"\n Good Luck!\n"</span>;</span><br><span class="line">                        num_tries = nt;</span><br><span class="line">                        num_cor = nc;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> while 循环的每次迭代都会读取文件的下一行内容。这样的操作会持续到文件尾端才结束。<br> <code>infile&gt;&gt;name</code>,这个语句的返回值即是从infile 读到的class object。一旦读到文件尾端，读入的class object 会被核定为false。因此我们可以在while循环的条件表达式中，以此作为结束条件：<br> <code>while(infile&gt;&gt;name)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile&gt;&gt;nt&gt;&gt;nc</span><br></pre></td></tr></table></figure>

<p>会先将用户猜过的总次数读到nt之中，再将用户猜对的总次数读到nc之中。</p>
<p>如果想要同时读写同一个文件，需要定义一个fstream对象，为了以追加模式（append mode）开启，我们得传入第二参数值 ios_base :: in | ios_base :: app :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"seq_data.txt"</span>,ios_base::in | ios_base::app)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (! iofile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 由于某些原因，文件无法开启……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开始读取之前，将文件重新定位至起始处</span></span><br><span class="line">    iofile.seekg(<span class="number">0</span>):</span><br><span class="line">    <span class="comment">// 其它部分都和先前讨论的相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以附加模式开启文件时，文件位置会位于尾端。如果我们没有先重新定位，就试着读取文件内容，那么立刻会遇到“读到文件尾”的状况。seekg()可将文件位置重新定位至文件的起始处。由于此文件是以追加模式开启，因此，任何写入操作都会将数据附加于文件最末端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（侯捷笔记3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（侯捷笔记3)/" itemprop="url">笔记整理（侯捷笔记3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>静态数据只有一份。静态数据需要在类外做定义，给不给初值均可。<br>静态函数没有this指针，只能处理静态数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span>&#123;m_data = x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">9.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      Account::set_rate(<span class="number">5.0</span>);</span><br><span class="line">      </span><br><span class="line">      Account a;</span><br><span class="line">      a.set_rate(<span class="number">7.0</span>);<span class="comment">// a 的地址不会传入函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用静态函数有两种方式：1.通过类名调用。2.通过对象调用。</span></span><br></pre></td></tr></table></figure>

<h2 id="单例模式-把构造函数放在private区域"><a href="#单例模式-把构造函数放在private区域" class="headerlink" title="单例模式 把构造函数放在private区域"></a>单例模式 把构造函数放在private区域</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">static</span> A&amp; <span class="title">getInstance</span><span class="params">(<span class="keyword">return</span> a;)</span></span>;</span><br><span class="line">      setup() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      A();</span><br><span class="line">      A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">      <span class="keyword">static</span> A a ;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::getInstance().setup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改进：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      static A&amp; getInstance());</span><br><span class="line">      setup() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      A();</span><br><span class="line">      A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line">A&amp; A::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">static</span> A a ;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::getInstance().setup();</span><br></pre></td></tr></table></figure>

<h2 id="class-template，类模板"><a href="#class-template，类模板" class="headerlink" title="class template，类模板"></a>class template，类模板</h2><p><code>template&lt;typename T&gt;</code></p>
<h2 id="function-template，函数模板"><a href="#function-template，函数模板" class="headerlink" title="function template，函数模板"></a>function template，函数模板</h2><p><code>template&lt;class T&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（MOOC)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（MOOC)/" itemprop="url">笔记整理（MOOC)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们调用一个函数的时候，会在内存中建立起一块特殊区域，称为“程序栈（program stack）”。程序栈提供了每个函数参数的储存空间。它也提供函数所定义的每个对象的内存空间——我们将这些对象称为 local object（局部对象）。一旦函数完成，这块内存就会被释放掉，或者说从程序堆栈中被pop出来。<br>当我们将vec[ix]这样的对象传入函数时，默认情形下其值会被复制一份，成为参数的局部性定义（local definition）。这种方式称为pass by value（传值）。我们在bubble_sort()内传给swap()的对象，和我们在swap()内操作的对象，其实是没有任何关联的两组对象。为了让程序正确运行，必须通过某种方法，令swap()的参数和传入的实际对象产生关联。即所谓的pass by reference （传址）。最简单的做法便是将参数声明为一个reference：在型别名称和reference名称之间插入&amp;符号，便声明了一个reference。<br>C++不允许改变references所代表的对象，他们必须从一而终。面对reference的所有操作都像面对“reference”所代表之对象所进行的操作一般无二。以reference作为函数参数时，亦复如此。<br>以by reference 方法传递对象当作函数参数，对象本身并不会复制出另一份——复制的是对象的地址。函数中对该对象进行的任何操作，都相当于是对传入的对象进行间接操作。将参数声明为reference的另一个理由是降低复制大型对象的负担。</p>
<p>也可以将vector以pointer形式传递。这和以reference传递的效果作用相同：传递的是对象地址，而不是整个对象的复制品。唯一的差别在于reference和pointer的用法不同。</p>
<p>pointer 参数和reference 参数更重要的差异是：pointer可能（也可能不）指向某个实际对象。当我们提领pointer时，一定要先确定其值非0。而reference则必定会代表某个对象，所以无需做此检查。reference不可以置为0。</p>
<p>一般来说，除非希望在函数内更改参数值，否则在传递内建型别时，不要使用传址方式，传址机制主要是作为传递 class object 之用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(size&lt;=<span class="number">0</span> || size&gt;<span class="number">1024</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">"Warning: fibon_seq():"</span></span><br><span class="line">    &lt;&lt; size &lt;&lt; <span class="string">"not supported -- resetting to 8\n"</span>;</span><br><span class="line">    size = <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; elems(size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ix=<span class="number">0</span>;ix&lt;size;++ix)</span><br><span class="line">      <span class="keyword">if</span> (ix ==<span class="number">0</span> || ix==<span class="number">1</span>)</span><br><span class="line">        elems[ix]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        elems[ix] = elems[ix<span class="number">-1</span>] + elems[ix<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论以pointer或reference形式将elems返回，都不正确，因为elems在fibon_seq()执行完毕时已不复存在。如果将elems以传值方式返回，便不会产生任何问题；因为返回的乃是对象的复制品，它在函数之外依然存在。</p>
<p>为对象配置的内存，其存活期称为储存期（storage duration） 或范围（extent）。每次fibon_seq()执行起来，都会为elems配置内存，每当fibon_seq()终了便会加以释放。我们称此对象具有局部性范围（local extent）。函数参数便有局部性范围。</p>
<p>对象在程序中存活区域称为该对象的 scope（生存空间）。size 和 elems 在fibon_seq()函数内拥有local scope。若某个对象仅具有local scope（局部性生存空间），其名称在local scope之外便不可视。<br>对象如果在函数之外声明，则具有 file scope。对象如果拥有file scope，则从其声明点至文件尾端都是可视的。file scope内的对象亦具备所谓的 static scope，意谓该对象的内存在main()开始执行之前便已经配置好了，可以一直存在至程序结束为止。</p>
<p>内建型别的对象，如果定义在file scope之内，必定被初始化为0。但如果它们被定义于local scope之内，那么除非程序员指定其初值，否则不会被初始化。<br>file scope 对象会打乱不同函数间的独立性，使它们难以理解。</p>
<h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><p>不论local scope 或者是file extent，都由系统自动管理。第三种存储期形式称为 dynamic extent（动态范围）。其内存由程序的自由空间（free store）配置而来，有时也称为heap memory（堆内存）。此种内存必须由程序员自行管理，其配置是通过new 表达式来达成的，释放通过delete表达式完成。</p>
<p>new Type:<br>Type 可以为任意内建型别，也可以是程序知道的class型别。new 表达式亦可写为：<br>new Type(initial_value);<br>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

<p>先由heap 配置出一个型别为int 的对象，再将其地址赋值给pi。默认情形下，由heap配置而来的对象，皆为经过初始化。new表达式的另一种形式允许我们指定初值，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>同样是先由heap配置出一个类型为int的对象，再将其地址赋值给pi，但这个对象的值会被初始化为1024.<br>从heap中配置数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">24</span>];</span><br></pre></td></tr></table></figure>

<p>从heap中配置一数目组，拥有24个整数。pia会被初始化为数组第一个元素的地址。数组中的每个元素都未经过初始化。C++ 没有提供任何语法让我们得以从heap配置数组的同时为其元素设定初值。<br>从heap配置而来的对象，被称为具有dynamic extent，因为它们是在执行期通过 new 表达式配置来的，因此可以持续存活，直到以 delete 表达式加以释放为止。下面的 delete 表达式会释放Pi所指的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete pi;</span><br></pre></td></tr></table></figure>

<p>如果要删除数组中的所有对象，必须在数组指针和delete表达式之间，加上一个空的下标运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<p>注意，无需检验pi是否非零：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (pi!=0) // 多此一举——编译器会提我们检查</span><br><span class="line">  delete pi;</span><br></pre></td></tr></table></figure>

<p>以“参数传递”作为函数间的沟通方式，比“直接将对象定义于file scope”更适当。理由之一是，函数如果过度依赖定义于file scope内的对象，就比较难以在其他环境中被重复使用，也比较难以修改——我们不仅需要了解该函数的运行逻辑，也必须了解定义于file scope中的那些个对象的运行逻辑。</p>
<p>通常将参数默认值置于函数声明处。</p>
<h4 id="局部静态对象（Local-Static-Objects）"><a href="#局部静态对象（Local-Static-Objects）" class="headerlink" title="局部静态对象（Local Static Objects）"></a>局部静态对象（Local Static Objects）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *</span><br><span class="line">fibon_seq(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elems;</span><br><span class="line">	<span class="comment">// 函数的运行逻辑置于此处</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此刻的elems被定义为fibon_seq()中的局部静态对象。局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在。elems 的内容不再像以前一样地于fibon_seq()每次被调用时就被破坏又被重新建立。这也是为什么现在我们可以安全地将elems的地址返回的原因。<br>局部静态对象使我们可以定义一个含有Fibonacci数列的vector，每当调用fibon_seq()时，只需计算那些尚未被置入elems的元素即可。</p>
<p>将函数声明为 inline ，表示要求编译器在每个函数调用点上，将函数的内容展开。面对一个inline函数，编译器可将该函数的调用操作改以一份函数码副本取而代之。这使我们获得效率上的改善，其结果等于是把三个函数写入 fibon_elem()内，但依然维持3个独立的运算单元。</p>
<p>在函数前面加上关键词 inline ,便可将该函数声明为 inline 。将函数指定为inline，只是对编译器提出的一种要求，编译器是否执行这项请求，需视编译器而定。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>function overloading<br>参数表（parameter list）不相同（可能是参数型别不同，也可能是参数数目不同）的两个或多个函数，可以拥有相同的函数名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器将调用者提供的实际参数拿来和每个重载函数的参数比较，找出其中最适当的。这也就是为什么每个重载函数的参数必须和其它重载函数的参数表不同的原因。</p>
<p>编译器无法根据函数返回值类型来区分两个具有相同名称的函数，以下便是不正确的写法，会产生编译错误：<br>//错误：参数表（而非返回值的型别）必须不同。<br>ostream&amp; display_message(char ch);<br>bool display_message(char ch);<br>因为返回值型别无法保证提供我们一个足以区分不同重载函数的情境。</p>
<p>将一组实现代码不同但工作内容相似的函数加以重载，可以让函数用户更容易使用这些函数。如果没有重载机制，我们就得为每个函数提供不同的名称。</p>
<h4 id="定义并使用-Template-Functions（模板函数）"><a href="#定义并使用-Template-Functions（模板函数）" class="headerlink" title="定义并使用 Template Functions（模板函数）"></a>定义并使用 Template Functions（模板函数）</h4><p>将单一函数的内容与希望显示的各种vector型别捆绑（bind）起来。<br>function template 将参数表中指定的所有（或部分）参数的型别信息抽离出来。在display_message()例子中，我们希望将vector 所持元素的型别抽离出来，于是就可以定义出一份不需再有任何更改的模板（template）。不过，这样还不完整，因为我们遗漏了抽离出来的型别信息。这份型别信息由用户提供——当他决定采用 function template 的某个实体时提供。<br>function template 以关键词 template 开场，其后紧接着以成对尖括号（&lt;&gt;）包围起来的一个或多个识别名称，这些名称用以表示我们希望延缓决定的数据型别。每当用户利用模板（template）产生函数时，他就必须提供确实的型别信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;elemType&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ix =<span class="number">0</span>;ix&lt;vec.size();ix++)</span><br><span class="line">    &#123;</span><br><span class="line">      elemType t = vec[ix];</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; t &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键词 typename 表示，elemType 在display_message() 函数中乃是一个临时放置型别的代称。elemType 只是个任意名称，也可以用foobar 或 T 之类的名称。</p>
<p>在我们编译程序时，实际过程模板会被编译两次。 </p>
<ul>
<li>首先，对模板代码检查语法（如缺少分号）等语法错误。 </li>
<li>然后，实例化时，即调用模板函数时检查模板函数中的操作是否支持该类型。</li>
</ul>
<p>模板参数的个数可是任意个，但是不能为模板参数指定默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T1 <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a; </span><br><span class="line">&#125; </span><br><span class="line">… </span><br><span class="line">max(<span class="number">4</span>,<span class="number">4.2</span>)   <span class="comment">// OK, but type of first argument defines return type</span></span><br></pre></td></tr></table></figure>

<p>上面的例子看起来很好，但是有问题。首先，返回类型必须被声明。如果返回类型是其中的一个模板参数类型，另一个参数类型就可能被转换成返回的类型。另外一个问题，把第二个类型转换为第一个类型会产生局部临时对象，那么就不能使用引用的方式（by reference）传回结果。因此上面的例子中，返回的类型是T1 而不是 T const&amp;</p>
<p>由于调用参数（call parameters ）是由模板参数（template parameters）构造的，所以两者是相关的。我们把这种概念称为：函数模板参数推导。有了推导，就可以像调用普通函数那样调用函数模板。 </p>
<p>如之前的例子，调用时为函数模板显示指定类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// instantiate T as double</span></span><br></pre></td></tr></table></figure>

<p>当模板参数和调用参数没有直接关系，且编译器也无法推导出模板参数时，就需要明确的指定模板参数了。如，可以为max()指定第三个模板参数类型作为返回参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span><span class="params">(T1 <span class="keyword">const</span>&amp; a,T2 <span class="keyword">const</span>&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而，推导机制并不会对返回类型进行匹配，而且模板参数RT也不在调用参数中。因此，编译器无法推导出RT，调用时就必须显示指定类型，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// OK, but tedious</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，调用时要么不需要指定参数完全由编译器推导，要么就要把所有的参数多显示指定了。<br>当然，还有一种方法只明确的指定第一个模板参数，其它的参数由编译器自动推导。<br>如下：RT要放在第一个参数的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> RT <span class="title">max</span> <span class="params">(T1 <span class="keyword">const</span>&amp; a, T2 <span class="keyword">const</span>&amp; b)</span></span>; </span><br><span class="line">… </span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">4.2</span>)    <span class="comment">// OK: return type is double</span></span><br></pre></td></tr></table></figure>

<p>函数模板重载（Overloading Function Templates）<br>和普通的函数一样，函数模板也是可以重载的。<br>函数重载：不同的函数的定义可以有相同的函数名，当函数被调用的时候由编译器判断使用哪个函数。<br>如下，函数模板重载的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maximum of two int values</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span>&amp; a, <span class="keyword">int</span> <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maximum of two values of any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maximum of three values of any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b, T <span class="keyword">const</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> max(max(a, b), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	::max(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>);     <span class="comment">// calls the template for three arguments </span></span><br><span class="line">	::max(<span class="number">7.0</span>, <span class="number">42.0</span>);     <span class="comment">// calls max&lt;double&gt; (by argument deduction) </span></span><br><span class="line">	::max(<span class="string">'a'</span>, <span class="string">'b'</span>);      <span class="comment">// calls max&lt;char&gt; (by argument deduction) </span></span><br><span class="line">	::max(<span class="number">7</span>, <span class="number">42</span>);         <span class="comment">// calls the nontemplate for two ints </span></span><br><span class="line">	::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>);       <span class="comment">// calls max&lt;int&gt; (by argument deduction) </span></span><br><span class="line">	::max&lt;<span class="keyword">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argument deduction) </span></span><br><span class="line">	::max(<span class="string">'a'</span>, <span class="number">42.7</span>);     <span class="comment">// calls the nontemplate for two ints </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，非模板函数可以和同名的函数模板同时存在，也可以和相同类型的函数模板实例同时存在。当所有的条件都相同时，编译器会优先选择非模板函数。<br>因此上面的第四个调用的是非模板函数。</p>
<p>调用时可以使用空的模板参数列表”&lt;&gt;”,这种形式告诉编译器必须使用从函数模板的实例，且模板参数由调用参数自动推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>)    <span class="comment">// calls max&lt;int&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure>

<p>由于模板是不能进行自动类型转换的，而普通函数是可以自动类型转换，所有最后一个调用的是非模板函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="string">'a'</span>, <span class="number">42.7</span>)      <span class="comment">// only the nontemplate function allows different argument types</span></span><br></pre></td></tr></table></figure>

<p>如果表头文件和含入此文件的程序代码文件位于同一个驱动器目录下，我们便使用双引号。如果在不同的驱动器目录下，我们便使用尖括号。<br>如果此文件被认定为标准的、或项目专属的头文件，我们便以尖括号将文件名括住；编译器搜寻此文档时，会先在某些默认的驱动器目录中找寻，如果文件名由成对的双括号括住，此文件便被认为是一个用户自行提供的头文件；搜寻此文件时，会由含入此文件之文件所在的驱动器目录开始找起。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（侯捷笔记4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（侯捷笔记4)/" itemprop="url">笔记整理（侯捷笔记4)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Object-Oriented-Programming-Object-Oriented-Design"><a href="#Object-Oriented-Programming-Object-Oriented-Design" class="headerlink" title="Object Oriented Programming,Object Oriented Design"></a>Object Oriented Programming,Object Oriented Design</h1><h2 id="OOP-OOD"><a href="#OOP-OOD" class="headerlink" title="OOP OOD"></a>OOP OOD</h2><h4 id="Inheritance（继承）"><a href="#Inheritance（继承）" class="headerlink" title="-Inheritance（继承）"></a>-Inheritance（继承）</h4><h4 id="Composition（复合）"><a href="#Composition（复合）" class="headerlink" title="-Composition（复合）"></a>-Composition（复合）</h4><h4 id="Delegation（委托）"><a href="#Delegation（委托）" class="headerlink" title="-Delegation（委托）"></a>-Delegation（委托）</h4><h2 id="Composition（复合），表示has-a"><a href="#Composition（复合），表示has-a" class="headerlink" title="Composition（复合），表示has-a"></a>Composition（复合），表示has-a</h2><p><code>Adapter</code><br>Composition（复合）关系下的构造和析构<br><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5Ce3c0bf05.png" alt="e3c0bf05.png"></p>
<h3 id="构造由内而外"><a href="#构造由内而外" class="headerlink" title="构造由内而外"></a>构造由内而外</h3><p>Container的构造函数首先调用Component的default构造函数，然后才执行自己。<br><code>Container::Container(...):Component(){...};</code></p>
<h3 id="构造由外而内"><a href="#构造由外而内" class="headerlink" title="构造由外而内"></a>构造由外而内</h3><p>Container的析构函数首先执行自己，然后才调用Component的析构函数。<br><code>Container::~Container(...){...~Component()};</code></p>
<h2 id="Delegation（委托）-Composition-by-reference"><a href="#Delegation（委托）-Composition-by-reference" class="headerlink" title="Delegation（委托）.Composition by reference."></a>Delegation（委托）.Composition by reference.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        String();</span><br><span class="line">        String(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">        String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">        ~String();</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        StringRep* rep;<span class="comment">//pimpl(Handle/Body)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"String.hpp"</span></span></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>;</span></span><br><span class="line">        StringRep(<span class="keyword">const</span> <span class="keyword">char</span>*s);</span><br><span class="line">        ~StringRep();</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">char</span>* rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; </span><br><span class="line">String::String()&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C0f52c2f8.png" alt="0f52c2f8.png"></p>
<h2 id="Inheritance（继承）-表示is-a"><a href="#Inheritance（继承）-表示is-a" class="headerlink" title="Inheritance（继承）,表示is-a"></a>Inheritance（继承）,表示is-a</h2><h3 id="Inheritance（继承）关系下的构造和析构"><a href="#Inheritance（继承）关系下的构造和析构" class="headerlink" title="Inheritance（继承）关系下的构造和析构"></a>Inheritance（继承）关系下的构造和析构</h3><p>base class 的构造函数必须是virtual，否则会出现undefined behavior<br><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C1053a33c.png" alt="1053a33c.png"></p>
<h4 id="构造由内而外-1"><a href="#构造由内而外-1" class="headerlink" title="构造由内而外"></a>构造由内而外</h4><p>Derived的构造函数首先调用base的default构造函数，然后才执行自己。<br><code>Derived::Derived(...):Base(){...};</code></p>
<h4 id="构造由外而内-1"><a href="#构造由外而内-1" class="headerlink" title="构造由外而内"></a>构造由外而内</h4><p>Derived的析构函数首先执行自己，然后才调用Base的析构函数。<br><code>Derived::~Derived(...){...~Base()};</code></p>
<h2 id="Inheritance（继承）with-virtual-functions（虚函数）"><a href="#Inheritance（继承）with-virtual-functions（虚函数）" class="headerlink" title="Inheritance（继承）with virtual functions（虚函数）"></a>Inheritance（继承）with virtual functions（虚函数）</h2><ul>
<li>non-virtual函数：你不希望derived class 重新定义（override，复写）它。</li>
<li>virtual函数：你希望derived class 重新定义（override，复写）它，且它已经有默认定义。</li>
<li>pure virtual函数：你希望derived class 一定要重新定义（override，复写）它，你对它没有默认定义。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// impure virtual</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// non-virtual</span></span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Template Method 设计模式</p>
<p><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C4856d28e.png" alt="4856d28e.png"></p>
<h4 id="Delegation（委托）-Inheritance（继承）"><a href="#Delegation（委托）-Inheritance（继承）" class="headerlink" title="Delegation（委托）+Inheritance（继承）"></a>Delegation（委托）+Inheritance（继承）</h4><p>  <img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5Cd9aa4c92.png" alt="d9aa4c92.png"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Component(<span class="keyword">int</span> val) &#123; value = val; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span> :</span><span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Primitive(<span class="keyword">int</span> val) :Component(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span><span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Component*&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Composite(<span class="keyword">int</span> val) :Component(val) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* elem)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c.push_back(elem);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src=":storage%5C6eb24750-df83-4827-a5ea-e76190b6d3a3%5C82ee2b56.png" alt="82ee2b56.png"><br>创建未来的class 名称<br>下面创建的原型要让上面看得到，放上去。<br>Prototype 原型<br>每一个子类有自己的一个个体，并且有一个构造函数把自己这个个体挂到上面去。<br>每一个子类有一个clone，让父类能够通过原型调用clone创建一个个副本，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（C++ADT)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（C++ADT)/" itemprop="url">笔记整理（C++ ADT)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>编写程序前，需要清楚地了解如何通过程序来实现索要完成的任务。 编写代码前，应列出程序的提纲（项目越大，越复杂，提纲应越详细），包括其需求。</p>
<p>实现的细节，应该在一个项目的后期完成，实现阶段要用到的详细数据结构更不应该在一开始就指定。</p>
<p>在刚开始的时候，最重要的是每项任务的输入输出。开始阶段应该关心程序需要什么，而不是如何去做。程序的行为比实现程序的机制更重要。如某个项需要完成一些任务，那么应该指定在这个项上进行的操作，而不是指定这个项的内部结构。这些操作是基于这个项的。当明确这些操作之后，就可以开始实现这个程序了。实现决定应该使用哪种数据结构，从而达到更好的时间以及空间执行效率。指定了操作的项被称为抽象数据类型（ADT）。</p>
<p>抽象数据类型不是程序的一部分，因为程序需要定义数据结构，而不只是数据结构上执行的操作。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>OOP以对象为中心，而对象是用类来定义的。类是一个模板，对象根据类来创建。类是软件的一部分，包括数据的说明以及对数据执行的操作，还可能包含对其他类数据的操作。<br>类中定义的函数称为方法，或者成员函数或者函数成员，类中使用的变量称为数据成员。<br>数据及其相关操作的结合称为数据封装。<br>对象是类的实例，是用类定义创建的实体。  </p>
<p>与非面向对象语言中的函数比，对象使数据和成员函数之间的结合更加紧密，更有意义。在非面向对象编程语言中，数据的声明和函数定义分散在整个程序中，只有程序文档才能说明它们之间存在联系。而OOL中，联系在一开始就建立起来了；事实上，这种联系是程序的基础。对象是由相互关联的数据和操作定义的，同一个程序中可能会有很多对象，对象通过传递消息来相互通信，为了更为充分的通信，需要泄露对象一些内部细节。基于对象的结构化编程可以完成多个目标。</p>
<p>首先，数据与操作之间的强耦合关系在实际的建模过程中非常有用，软件工程尤其强调这一点。<br>其次，对象便于查找错误，因为操作都只限于它们的对象。即使有副作用也容易跟踪。<br>第三，对象可以对其他对象隐藏某些操作细节。从而使得这些操作不会受到其他对象的影响，这就是所谓的信息隐藏原则。</p>
<p>对象就像是一个黑盒子，其行为有明确的定义，我们使用对象是因为知道其功能，而不是因为了解其内部运行机制。对象的这种不透明性对于保持其独立性是非常有用的。如果恰当的定义了对象之间的通信管道，那么只有当对象中的改变影响到通信管道时，才会影响其他对象。在了解了对象发出和收到的信息之后，可以方便地用某个在特殊情况下更为合适的对象取代当前对象。</p>
<p>信息隐藏往往容易模糊数据和操作的界限。</p>
<p>C++能够在类声明中使用类型参数来声明通用类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">genType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">genClass</span>&#123;</span></span><br><span class="line">  genType storage[<span class="number">50</span>];</span><br><span class="line">  ..............</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  此后才会决定如何初始化genType:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">genClass&lt;<span class="keyword">int</span>&gt; intObject;</span><br><span class="line">genClass&lt;<span class="keyword">float</span>&gt; floatObject;</span><br></pre></td></tr></table></figure></p>
<p>这个通用类是生成两个新类（int类型的genClass和float类型的genClass）的基础，然后使用这两个类创建了两个对象intObject和floatObject。通过这种方式，通用类可以根据特定的声明以各种不同的形式出现，一个通用声明就足以使类具有不同的形式。</p>
<p>让storage数组大小可选：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">genType</span>,<span class="title">int</span> <span class="title">size</span> = 50&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">genClass</span>&#123;</span></span><br><span class="line">  genType storage[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">genClass&lt;<span class="keyword">int</span>&gt; intObject1; <span class="comment">// use the default size;</span></span><br><span class="line">genClass&lt;<span class="keyword">int</span>,<span class="number">100</span>&gt; intObject2;</span><br><span class="line">genClass&lt;<span class="keyword">float</span>,<span class="number">123</span>&gt; floatObject;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（DSIPy)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（DSIPy)/" itemprop="url">笔记整理（Python 数据结构）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><p>时间复杂度的几条基本计算规则</p>
<ol>
<li>基本操作，即只有常数项，认为其时间复杂度为O(1)。</li>
<li>顺序结构，时间复杂度按加法进行计算</li>
<li>循环结构，时间复杂度按乘法进行计算</li>
<li>分支结构，时间复杂度取最大值</li>
<li>判断一个算法的效率时，往往只需要关注操作数量的最高次项，其他次项和常数项可以忽略。</li>
<li>无特殊说明时，算法的时间复杂度均指最坏时间复杂度。</li>
</ol>
<p>常见时间复杂度的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</span><br></pre></td></tr></table></figure>

<h3 id="Python内置类型性能分析"><a href="#Python内置类型性能分析" class="headerlink" title="Python内置类型性能分析"></a>Python内置类型性能分析</h3><p>timeit 模块可以用来测试一小段Python代码的执行速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class timeit.Timer(stmt=&apos;pass&apos;,setup=&apos;pass&apos;,timer=&lt;timer function&gt;)</span><br></pre></td></tr></table></figure>

<p>Timer是测量小段代码执行速度的类；<br>stmt参数是要测试的代码语句（statement）；<br>setup参数是运行代码时需要的设置；<br>timer参数是一个定时器函数，与平台有关。</p>
<p>timeit.Timer.timeit(number=100000)<br>Timer类中测试语句执行速度的对象方法，number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p>
<p>数据结构静态描述了数据元素之间的关系。高效的程序需要在数据结构的基础上设计和选择算法。<br>程序 = 数据结构 + 算法<br>总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。</p>
<h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><p>抽象数据类型指一个数学模型以及定义在这个模型上的一组操作。即把数据类型和数据类型上的运算捆绑在一起，进行封装。引入ADT的目的是为了把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。</p>
<p>地址所占用的内存空间大小一致。</p>
<p>选择排序算法不具有稳定性（考虑升序，每次选最大的情况）。<br>冒泡排序具有稳定性。<br>插入排序具有稳定性。<br>希尔排序不具有稳定性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（侯捷笔记)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（侯捷笔记)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="侯捷1"><a href="#侯捷1" class="headerlink" title="侯捷1"></a>侯捷1</h1><ul>
<li>class without pointer members<ul>
<li>Complex</li>
</ul>
</li>
<li>class with pointer members<ul>
<li>String  </li>
</ul>
</li>
</ul>
<p>complex.h<br>防卫式声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__   </span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件布局</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__   </span></span><br><span class="line">________________________________________________</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span>                                                                <span class="title">forward</span> <span class="title">declarations</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">complex</span>                                                               前置声明</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">complex</span>&amp;</span></span><br><span class="line"><span class="class">    __<span class="title">doap1</span>(<span class="title">complex</span>* <span class="title">ths</span>,<span class="title">const</span> <span class="title">complex</span>&amp; <span class="title">r</span>);</span></span><br><span class="line">________________________________________________</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">________________________________________________</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">                                                                                    <span class="class"><span class="keyword">class</span> <span class="title">declarations</span></span></span><br><span class="line"><span class="class">........................................                                                    类-声明</span></span><br><span class="line"><span class="class">&#125;                                                               </span></span><br><span class="line"><span class="class">________________________________________________</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">________________________________________________</span></span><br><span class="line"><span class="class"><span class="title">complex</span> :</span>: function...                                                     <span class="class"><span class="keyword">class</span> <span class="title">definition</span> 类定义</span></span><br><span class="line"><span class="class">________________________________________________</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br></pre></td></tr></table></figure>

<p>不带指针的类，大多数情况不需要写析构函数。 </p>
<p>构造函数放在private区域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Singleton</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">  static A&amp; getInstance();</span><br><span class="line">  setup()&#123;...&#125;</span><br><span class="line">private:</span><br><span class="line">   A():</span><br><span class="line">   A(const A&amp; rhs);</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A&amp; A::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">  static A a;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同class的各个objects互为friends（友元）<br><img src=":storage%5Ce085efcd-aaff-4f6d-94a3-107cbd04e949%5C5194a5f0.png" alt="5194a5f0.png"></p>
<p>类定义：<br> 1.数据一定在private里。2.传参最好以传引用的方式。（注意加不加const）3.返回值也尽量以引用来传递。5.构造函数最好使用initialization list。</p>
<p>如果在一个函数内部创建了一个新的变量，并且将其引用返回，实际上达不到理想的效果，因为函数结束后，临时创建的新的变量就消失了，所以它的引用也没有了本来的意义。</p>
<h2 id="operator-overloading（操作符重载-1，成员函数）-this"><a href="#operator-overloading（操作符重载-1，成员函数）-this" class="headerlink" title="operator overloading（操作符重载-1，成员函数） this"></a>operator overloading（操作符重载-1，成员函数） this</h2><p>任何的成员函数都有一个隐藏的this指针。this指针指向调用者。</p>
<p>return by reference 语法分析<br>传递者无需知道接收者是以reference形式接收</p>
<h2 id="operator-overloading（操作符重载-2，非成员函数）-无this"><a href="#operator-overloading（操作符重载-2，非成员函数）-无this" class="headerlink" title="operator overloading（操作符重载-2，非成员函数） 无this"></a>operator overloading（操作符重载-2，非成员函数） 无this</h2><p>temp object（临时对象） typename();</p>
<p>String class<br>如果类里面带指针，拷贝构造函数一定要自己写。<br>big three: 拷贝构造，拷贝赋值，析构函数<br>class with pointer members 必须有 copy ctor 和 copy op=，否则可能造成内存泄漏 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/笔记整理（侯捷笔记2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/笔记整理（侯捷笔记2)/" itemprop="url">笔记整理（侯捷笔记2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="所谓stack，所谓heap"><a href="#所谓stack，所谓heap" class="headerlink" title="所谓stack，所谓heap"></a>所谓stack，所谓heap</h1><p>Stack，是存在于某作用域（scope）的一块内存空间（memory space）。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。<br>在函数本体（function body）内声明的任何变量，其所使用的内存块都取自上述stack。</p>
<p>Heap，或称system heap，是指由操作系统提供的一块global内存空间，程序可动态分配（dynamic allocated）从其中获得若干区块（blocks）。<br>class Complex<br>…<br>{<br>  Complex c1(1,2);        // c1 所占用的空间来自stack<br>  Complex* p = new Complex(3);Complex（3）是个临时对象，其所占用的空间乃是以new的方式动态分配取得，并由p指向<br>  }</p>
<p>  stack object 的生命期<br>  c1 便是所谓stack object，其生命在作用域（scope）结束之际结束。这种作用域内的object，又称为auto object，因为它会被“自动”清理。</p>
<p>  static local objects 的生命期<br>  static Complex c2(1,2);  c2便是所谓static object，其生命在作用域（scope）结束之后仍然存在，直到整个程序结束。</p>
<p>  global objects 的生命期<br>  class Complex{}<br>  Complex c3(1,2);<br>  int main()<br>  {}</p>
<p>  c3 便是global object，其生命在整个程序结束之后才结束，可以将其视为一种static object，其作用域是“整个程序”。</p>
<p>  new: 先分配memory，再调用ctor</p>
<p>  Complex* pc = new Complex(1,2);<br>  编译器转化为：<br>  Complex *pc;</p>
<ol>
<li>void* mem = operator new(sizeof(Complex)); -&gt;其内部调用malloc(n)； // 分配内存</li>
<li>pc = static_cast&lt;Complex*&gt;（mem); // 转型</li>
<li>pc-&gt;Complex::Complex(1,2);// 构造函数 -&gt;Complex::Complex(pc,1,2);</li>
</ol>
<p>delete: 先调用dtor，再释放memory</p>
<p>String* ps = new String(“hello”);<br>…<br>delete ps;</p>
<p>编译器转化为：String::~String(ps);//析构函数<br>operator delete(ps); //释放内存 -&gt;其内部调用free(ps)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Python Data Types and Structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Python Data Types and Structures/" itemprop="url">Python Data Types and Structures</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Operations-and-expressions"><a href="#Operations-and-expressions" class="headerlink" title="Operations and expressions"></a>Operations and expressions</h2><p>There are number of operations that are common to all data types.For example, all data types, and generally all objects, can be tested for a truth value in some way.</p>
<h4 id="The-following-are-values-that-Python-considers-False"><a href="#The-following-are-values-that-Python-considers-False" class="headerlink" title="The following are values that Python considers False:"></a>The following are values that Python considers <code>False</code>:</h4><ul>
<li>The None type</li>
<li>False</li>
<li>An integer, float, or complex zero</li>
<li>An empty sequence or mapping</li>
<li>An instance of a user-defined class that defines a <strong>len</strong>() or <strong>bool</strong>() method that returns zero or False</li>
</ul>
<p>All other values are considered <code>True</code>.</p>
<h2 id="Boolean-operations"><a href="#Boolean-operations" class="headerlink" title="Boolean operations"></a>Boolean operations</h2><p>Both the <code>and</code> operator and the <code>or</code> operator use “short-circuiting” when evaluating an expression.This means Python will only evaluate an operator if it needs to.</p>
<h2 id="Comparison-and-Arithmetic-operators"><a href="#Comparison-and-Arithmetic-operators" class="headerlink" title="Comparison and Arithmetic operators"></a>Comparison and Arithmetic operators</h2><p>For collection objects, these operators compare the number of elements and the equivalence operator <code>==</code>  returns True if each collection object is structurally equivalent, and the value of each element is identical.</p>
<h2 id="Membership-identity-and-logical-operations"><a href="#Membership-identity-and-logical-operations" class="headerlink" title="Membership, identity, and logical operations"></a>Membership, identity, and logical operations</h2><p>Membershi operators(<code>in</code>,<code>not in</code>) test for variables in sequences,such as lists or strings do what you would expect,x in y returns True if a variable x is found in y.</p>
<p>The <code>is</code> operator compares object identity.</p>
<p>For example, the following snippet shows contrast equivalence with object identity:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=[1,2,3];y=[1,2,3]</span><br><span class="line">x==y #equivalence</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">x is y #object identity</span><br><span class="line">False</span><br><span class="line">x = y # assignment</span><br><span class="line">x is y</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="Built-in-data-types"><a href="#Built-in-data-types" class="headerlink" title="Built-in data types"></a>Built-in data types</h2><p>Python data types can be divided into three categories:<strong>numeric</strong>,<strong>sequence</strong>,and <strong>mapping</strong>.</p>
<p>There is also the None object that represents a Null,or absence of a value.It should not be forgotten either that other objects such as classes,files,and exceptions can also properly be considered types;however,they will not be considered here.</p>
<p>Every value in Python has a data type. Unlike many programming languages, in Python you do not need to explicitly declare the type of a variable. Python keeps track of object types internally.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>None</td>
<td>The null object.</td>
</tr>
<tr>
<td>Sequences</td>
<td>str</td>
<td>string of characters.</td>
</tr>
<tr>
<td>Sequences</td>
<td>list</td>
<td>List of arbitrary objects.</td>
</tr>
<tr>
<td>Sequences</td>
<td>Tuple</td>
<td>Group of arbitrary items.</td>
</tr>
<tr>
<td>Sequences</td>
<td>range</td>
<td>Creates a range of integers.</td>
</tr>
<tr>
<td>Mapping</td>
<td>dict</td>
<td>Dictionary of key-value pairs.</td>
</tr>
<tr>
<td>Mapping</td>
<td>set</td>
<td>Mutable,unordered collection of unique items.</td>
</tr>
<tr>
<td>Mapping</td>
<td>frozenset</td>
<td>Immutable set</td>
</tr>
</tbody></table>
<h3 id="None-type"><a href="#None-type" class="headerlink" title="None type"></a>None type</h3><p>The None type is immutable and has one value, None. It is used to represent the absence of a value. It is returned by objects that do not explicitly return a value and evaluates to False in Boolean expressions. It is often used as the default value in optional arguments to allow the function to detect whether the caller has passed a value.</p>
<h3 id="Numeric-Types"><a href="#Numeric-Types" class="headerlink" title="Numeric Types"></a>Numeric Types</h3><p>All numeric types, apart from bool, are signed and they are all immutable.</p>
<p>The integer type, int, represents whole numbers of unlimited range. Floating point numbers are represented by the native double precision floating point representation of the machine.</p>
<p>Complex numbers are represented by two floating point numbers. They are assigned using the j operator to signify the imaginary part of the complex number, for example:<br><code>a = 2+3j</code><br> We can access the real and imaginary parts with <code>a.real</code> and <code>a.imag</code>, respectively.</p>
<h3 id="Representation-error"><a href="#Representation-error" class="headerlink" title="Representation error"></a>Representation error</h3><p>It should be noted that the native double precision representation of floating point numbers leads to some unexpected results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1-0.9</span><br><span class="line">0.09999999999999998</span><br><span class="line">&gt;&gt;&gt; 1-0.9==0.1</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>This is a result of the fact that <strong>most decimal fractions are not exactly representable as a binary fraction</strong>,which is how most uderlying hardware represents floating point numbers.</p>
<p>For algorithms or applications where this may be an issue,Python provides a <strong>decimal module</strong>.</p>
<p>This module allows for the exact representation of decimal numbers and facilitates greater control properties such as rounding behavior,number of sigificant digits,and precision.</p>
<p>It defines two objects,a Decimal type,representing decimal numbers,and a Context type,representing various computational parameters such as precision,rounding,and error handling.</p>
<p>In addition, Decimal objects also have several methods for mathematical operations, such as natural exponents, x.exp(), natural logarithms, x.ln(), and base 10 logarithms, x.log10().</p>
<h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p>Lists and tuples are sequences of arbitrary objects, strings are sequences of characters. String, tuple, and range objects are immutable.</p>
<p>Note that for the immutable types, any operation will only return a value rather than actually change the value.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>len(s)</td>
<td>Number of elements in s</td>
</tr>
<tr>
<td>min(s,[,default=obj,key=func])</td>
<td>The minimum value in s (alpabetically for strings)</td>
</tr>
<tr>
<td>max(s,[,default=obj,key=func])</td>
<td>Maximum value in s(alphabetically for strings)</td>
</tr>
<tr>
<td>sum(s,[,start=0])</td>
<td>The sum of elements (returns TypeError if s is not numeric)</td>
</tr>
<tr>
<td>all(s)</td>
<td>Returns True if all elements in <code>s</code> are True(that is,not <code>0</code>,<code>False</code>,or <code>Null</code>)</td>
</tr>
<tr>
<td>any(s)</td>
<td>Check whether any item in <code>s</code> is True</td>
</tr>
</tbody></table>
<p>In addition, all sequences support the following operations:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>s+r</td>
<td>Concatenates two sequences of the same type</td>
</tr>
<tr>
<td>s*n</td>
<td>Make n copies of s, where n is an integer</td>
</tr>
<tr>
<td>v1,v2,…,vn=s</td>
<td>Unpacks n variables from s to v1,v2,and so on</td>
</tr>
<tr>
<td>s[i]</td>
<td>Indexing-returns element i of s</td>
</tr>
<tr>
<td>s[i:j:stride]</td>
<td>Slicing returns elements between i and j with optional stride</td>
</tr>
<tr>
<td>x in s</td>
<td>Returns True if element x is in s</td>
</tr>
<tr>
<td>x not in s</td>
<td>Returns true if element x is not in s</td>
</tr>
</tbody></table>
<h2 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h2><p>Tuples are immutable sequences of arbitrary objects.They are indexed by integers greater than zero.Tuples are hashable,which means we can sort lists of them and they can be used as keys to dictionaries.</p>
<p>Syntactically,tuples are just a comma-separated sequence of values;however,it is common practice to enclose them in parentheses:<br><code>tpl= (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></p>
<p>It is important to remember to use a trailing comma when creating a tuple with one element, for example:<br>     <code>t = (&#39;a&#39;,)</code></p>
<p>Without the trailing comma, this would be interpreted as a string.</p>
<p>We can also create a tuple using the built-in function tuple(). With no argument, this creates an empty tuple. If the argument to tuple() is a sequence then this creates a tuple of elements of that sequence, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple(&apos;sequence&apos;)</span><br><span class="line">(&apos;s&apos;, &apos;e&apos;, &apos;q&apos;, &apos;u&apos;, &apos;e&apos;, &apos;n&apos;, &apos;c&apos;, &apos;e&apos;)</span><br></pre></td></tr></table></figure>

<p>Most operators, such as those for slicing and indexing, work as they do on lists. However, because tuples are immutable, trying to modify an element of a tuple will give you a TypeError. We can compare tuples in the same way that we compare other sequences, using the <code>==</code>, <code>&gt;</code> and <code>&lt;</code> operators.</p>
<p>An important use of tuples is to allow us to assign more than one variable at a time by placing a tuple on the left-hand side of an assignment,for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l=[&apos;one&apos;,&apos;two&apos;]</span><br><span class="line">&gt;&gt;&gt; x,y = l #assigns x and y to &apos;one&apos; and &apos;two&apos; respectively</span><br></pre></td></tr></table></figure>

<p>We can actually use this multiple assignment to swap values in a tuple, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y=y,x #x=&apos;two&apos; and y = &apos;one&apos;</span><br></pre></td></tr></table></figure>

<p>A ValueError will be thrown if the number of values on each side of the assignment are not the same.</p>
<h2 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h2><p>Dictionaries are arbitrary collections of objects indexed by numbers,strings,or other immutable objects.Dictionaries themselves are mutable;however,their index keys must be immutable.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>len(d)</td>
<td>Number of items in d.</td>
</tr>
<tr>
<td>d.clear()</td>
<td>Removes all items from d</td>
</tr>
<tr>
<td>d.fromkeys(s,[,value])</td>
<td>Returns a new dictionary with keys from sequence s and values set to value.</td>
</tr>
<tr>
<td>d.get(k,[,v])</td>
<td>Returns d[k] if found,or else returns v,or None if v is not given.</td>
</tr>
<tr>
<td>d.items()</td>
<td>Returns a sequence of key:value pairs in d.</td>
</tr>
<tr>
<td>d.keys()</td>
<td>Returns a sequence of keys in d.</td>
</tr>
<tr>
<td>d.pop(k [,default])</td>
<td>Returns d[k] and removes it from d. If d[k] is not found,it returns default or raises KeyError.</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>Removes a random key:value pair from d and returns it as a tuple.</td>
</tr>
<tr>
<td>d.setdefault(k [,v])</td>
<td>Returns d[k].If d[k] is not found,it returns v and sets d[k] to v.</td>
</tr>
<tr>
<td>d.update(b)</td>
<td>Adds all objects from b to d.</td>
</tr>
<tr>
<td>d.values()</td>
<td>Returns a sequence of values in d.</td>
</tr>
</tbody></table>
<p>The relationship between the time an algorithm takes to run compared to the size of its input is often referred to as its time complexity.<br>算法运行的时间与其输入的大小之间的关系通常被称为其时间复杂度。</p>
<p>In contrast to the list object, when the in operator is applied to dictionaries, it uses a <strong>hashing algorithm</strong> and this has the effect of the increase in time for each lookup almost independent of the size of the dictionary. This makes dictionaries extremely useful as a way to work with large amounts of indexed data.</p>
<p>Notice when we print out the key:value pairs of the dictionary it does so in no particular order.This is not a problem since we use specified keys to look up each dictionary value rather than an ordered sequence of integers as is the case for strings and lists.</p>
<h2 id="Sorting-dictionaries"><a href="#Sorting-dictionaries" class="headerlink" title="Sorting dictionaries"></a>Sorting dictionaries</h2><p>The sorted() method has two optional arguments that are of interest: key and reverse.</p>
<p>The key argument has nothing to do with the dictionary keys, but rather is a way of passing a function to the sort algorithm to determine the sort order.</p>
<p>We use the <code>__getitem__</code> special method to sort the dictionary keys according to the dictionary values:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;a&apos;: 68, &apos;b&apos;: 1&#125;</span><br><span class="line">&gt;&gt;&gt; sorted(list(d),key=d.__getitem__)</span><br><span class="line">[&apos;b&apos;, &apos;a&apos;]</span><br></pre></td></tr></table></figure>

<p>Essentially,what the preceding code doing is for every key in d to use the corresponding value to sort.We can also sort the values according to the sorted order of the dictionary keys.However,since dictionaries do not have a method to return a key by using its value,the equivalent of the <code>list.index</code> method for lists,using the optional key argument to do this is a little tricky. An alternative approach is to use a list comprehension,as the following example demonstrates:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [value for (key,value) in sorted(d.items())]</span><br><span class="line">[68, 1]</span><br></pre></td></tr></table></figure>

<p>The sorted() method also has an optional reverse argument,and unsurprisingly,this does exactly what it says,reverses the order of the sorted list,for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(list(d),key=d.__getitem__,reverse=True)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure>

<h2 id="Dictionaries-for-text-analysis"><a href="#Dictionaries-for-text-analysis" class="headerlink" title="Dictionaries for text analysis"></a>Dictionaries for text analysis</h2><p>A common use of dictionaries is to count the occurrences of like items in a sequence; a typical example is counting the occurrences of words in a body of text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def wordcount(fname):</span><br><span class="line">    try:</span><br><span class="line">        fhand=open(fname)</span><br><span class="line">    except:</span><br><span class="line">        print(&apos;File cannot be opened&apos;)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    count=dict()</span><br><span class="line">    for line in fhand:</span><br><span class="line">        words=line.split()</span><br><span class="line">        for word in words:</span><br><span class="line">            if word not in count:</span><br><span class="line">                count[word]=1</span><br><span class="line">            else:</span><br><span class="line">                count[word]+=1</span><br><span class="line">    return(count)</span><br></pre></td></tr></table></figure>

<p>This will retrun a dictionary with an element for each unique word in the text file.<br>Dictionary comprehensions work in an identical way to the list comprehensions.</p>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>Sets are themselves mutable,we can add and remove items from them;however,the items themselves must be immutable.</p>
<p>An important distinction with sets is that they cannot contain duplicate items.</p>
<p>Sets are typically used to perform mathematical operations such as intersection, union, difference, and complement.</p>
<p>交并差补<br>intersection，union，difference，complement</p>
<p>Unlike sequence types,set types do not provide andy indexing or slicing operations.There are also no keys associated with values,as is the case with dictionaries.</p>
<p>There are two types of set objects in Python, the mutable set object and the immutable frozenset object. Sets are created using comma-separated values within curly braces.<br>By the way, we cannot create an empty set using a={}, because this will create a dictionary. To create an empty set, we write either a=set() or a=frozenset().<br>Method|Operators|Description<br>—|—|—<br>len(s)||Returns the number of elements in s.<br>s.copy()||Returns a shallow copy of s<br>s.difference(t)        |s-t-t2-…|Returns a set of all items in s but not in t<br>s.intersection(t)||Returns a set of all items in both t and s<br>s.isdisjoint(t)||Returns True if s and t have no items in common<br>s.issubset(t)|s&lt;=t s&lt;t(s!=t)|Returns True if all items in s are also in t<br>s.issuperset(t)| s&gt;=t s&gt;t(s!=t)|Returns True if all items in t are also in s<br>s.symmetric_difference(t)|s^t|Returns a set of all items that are in s or t,but not both<br>s.union(t)|s|t1|t2|..|Returns a set of all items in s or t</p>
<p>The parameter <code>t</code> can be any Python object that supports iteration and all methods are available to both set and frozenset objects.<br>It is important to be aware that the operator versions of these methods require their arguments to be sets, whereas the methods themselves can accept any iterable type. For example, <code>s - [1,2,3]</code>, for any set s, will generate an unsupported operand type. Using the equivalent <code>s.difference([1,2,3])</code> will return a result.</p>
<p>Mutable set objects have additional methods<br>Method|Description<br>—|—<br>s.add(item)|Adds item to s.Has no effect if item is already present.<br>s.clear()|Remove all items from s<br>s.difference_update(t)|Removes all items in s that are also in t<br>s.discard(item)|Removes item from s.<br>s.intersection_update(t)|Removes all items from s that are not in the intersection of s and t.<br>s.pop()|Returns and removes an arbitrary item from s<br>s.remove(item)|Removes item from s<br>s.symmetric_difference_update(t)|Removes all items from s that are not in the symmetric difference of s ant t.<br>s.update(t)|Adds all the items in an iterable object t to s.</p>
<p>Notice that the set object does not care that its members are not all of the same type,as long as they are all immutable.<br>Hashable types all have a hash value that does not change throughout the lifetimeof the instance.<strong>All built-in immutable types are  hashable</strong>.<strong>All built-in mutable types are not hashable</strong>,so they cannot be used as elements of sets or keys to dictionaries.</p>
<h2 id="Immutable-sets"><a href="#Immutable-sets" class="headerlink" title="Immutable sets"></a>Immutable sets</h2><p>Python has an immutable set type called frozenset.It works pretty much exactly like set apart from not allowing methods or operations that change values such as the <code>add()</code> or <code>clear()</code> methods.</p>
<p>There are several ways that this immutability can be useful. For example, since normal sets are mutable and therefore not hashable, they cannot be used as members of other sets. The frozenset, on the other hand, is immutable and therefore able to be used as a member of a set.<br>Also the immutable property of frozenset means we can use it for a key to a dictionary.</p>
<h2 id="Modules-for-data-structures-and-algorithms"><a href="#Modules-for-data-structures-and-algorithms" class="headerlink" title="Modules for data structures and algorithms"></a>Modules for data structures and algorithms</h2><p>So far, we have looked at the built-in datatypes of strings, lists, sets, and dictionaries as well as the decimal and fractions modules. They are often described by the term abstract data types (ADTs).ADTs can be considered as mathematical specifications for the set of operations that can be performed on data.</p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>The collections module provides more specialized,high,performance alternatives for the built-in data types as well as a utility function to create named tuples.</p>
<table>
<thead>
<tr>
<th>Datatype or operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>namedtuple()</td>
<td>Creates tuple subclasses with named fields.</td>
</tr>
<tr>
<td>deque</td>
<td>Lists with fast appends and pops either end.</td>
</tr>
<tr>
<td>ChainMap</td>
<td>Dictionary like class to create a single view of multiple mappings.</td>
</tr>
<tr>
<td>Counter</td>
<td>Dictionary subclass for counting hashable objects.</td>
</tr>
<tr>
<td>OrderedDict</td>
<td>Dictionary subclass that remembers the entry order.</td>
</tr>
<tr>
<td>defaultdict</td>
<td>Dictionary subclass that calls a function to supply missing vlaues.</td>
</tr>
<tr>
<td>UserDict <br> UserList<br>UserString</td>
<td>These three data types are simply wrappers for their underlying base classes.Their use has largely been supplanted by the ability to subclassses their respective base classes directly.Can be used to access the underlying object as an attribute.</td>
</tr>
</tbody></table>
<h2 id="Deques"><a href="#Deques" class="headerlink" title="Deques"></a>Deques</h2><p>Double-ended queues,or deques,are list-like objects that support thread-safe,memory-effcient appends.</p>
<p>Deques are mutable and support some of the operations of lists,such as indexing.Deques can be assigned by index.However,we cannot directly slice deques.</p>
<p>The major advantage of deques over lists is that inserting items at the beginning of a deque is much faster than inserting items at the beginning of a list,although inserting items at the end of a deques is very slightly slower than the equivalent operation on a list.</p>
<p>Deques are thread,safe and can be serialized using the pickle module.</p>
<p>We can also use the rotate(n) method to move and rotate all items of n steps to the right for positive values of the integer n,or left for negative values of n the left,using positive integers as the argument</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([&apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;])</span><br><span class="line">&gt;&gt;&gt; dq.rotate(2)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([&apos;f&apos;, &apos;g&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br><span class="line">&gt;&gt;&gt; dq.rotate(2)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([&apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>a simple way to return a slice of a deque, as a list, which can be done as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; list(itertools.islice(dq,3,9))</span><br><span class="line">[&apos;z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>itertools.islice</code> method works in the same way that slice works on a list,except rather than taking a list for an argument,it takes an iterable and returns slelected values,by start and stop indices,as a list.</p>
<p><code>maxlen</code> a optional parameter that restricts the size of deque.<br>This makes  it ideally suited to a data structure known as a <em>circular buffer</em>.This is a fixed-size structure that is effectively connected end to end and they are typically used for buffering data streams.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dq2 = deque([],maxlen=3)</span><br><span class="line">&gt;&gt;&gt; for i in range(6):</span><br><span class="line">...     dq2.append(i)</span><br><span class="line">...     print(dq2)</span><br><span class="line">... </span><br><span class="line">deque([0], maxlen=3)</span><br><span class="line">deque([0, 1], maxlen=3)</span><br><span class="line">deque([0, 1, 2], maxlen=3)</span><br><span class="line">deque([1, 2, 3], maxlen=3)</span><br><span class="line">deque([2, 3, 4], maxlen=3)</span><br><span class="line">deque([3, 4, 5], maxlen=3)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>In this example,we are populating from the right and consuming from the left.Notice that once the buffer is full,the oldest values are consumed first,and values are replaced from the right.</p>
<h2 id="ChainMaps"><a href="#ChainMaps" class="headerlink" title="ChainMaps"></a>ChainMaps</h2><p><code>collection.chainmap</code> class provides a way to link a number of dictionaries,or other mappings,so that they can be treated as one object.</p>
<p>In addition,there is a maps attribute,a <code>new_child()</code> method,and a parents property.</p>
<p>The uderlying mappings for ChainMap objects are stored in a list and are accessible using the <code>maps[i]</code> attribute to retrieve <code>ith</code> dictionary.</p>
<p>ChainMaps are an ordered list of dictionaries.ChainMap is useful in applications where we are using a number of dictionaries containing related data.</p>
<p>The advantage of using ChainMaps, rather than just a dictionary, is that we <strong>retain previously set values</strong>. Adding a child context overrides values for the same key, but it does not remove it from the data structure. This can be useful for when we may need to keep a record of changes so that we can easily roll back to a previous setting.</p>
<p>We can retrieve and change any value in any of the dictionaries by providing the map() method with an appropriate index. This index represents a dictionary in the ChainMap. Also, we can retrieve the parent setting, that is, the default settings, by using the parents() method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from collections import ChainMap</span><br><span class="line">&gt;&gt;&gt; cm2.maps[0]=&#123;&apos;theme&apos;:&apos;desert&apos;,&apos;showIndex&apos;:False&#125;</span><br><span class="line">&gt;&gt;&gt; cm2</span><br><span class="line">ChainMap(&#123;&apos;theme&apos;: &apos;desert&apos;, &apos;showIndex&apos;: False&#125;, &#123;&apos;theme&apos;: &apos;Default&apos;, &apos;language&apos;: &apos;eng&apos;, &apos;showIndex&apos;: True, &apos;showFooter&apos;: True&#125;)</span><br><span class="line">&gt;&gt;&gt; cm2[&apos;showIndex&apos;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; cm2.parents</span><br><span class="line">ChainMap(&#123;&apos;theme&apos;: &apos;Default&apos;, &apos;language&apos;: &apos;eng&apos;, &apos;showIndex&apos;: True, &apos;showFooter&apos;: True&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Counter-objects"><a href="#Counter-objects" class="headerlink" title="Counter objects"></a>Counter objects</h2><p>Counter is a subclass of a dictionary where each dictionary <code>key</code> is a hashable object and the associated value is an integer count of that object.<br>There are three ways to initialize a counter.</p>
<p>We can pass it any sequence object,a dictionary of <code>key:value</code> pairs,or a tuple of the format(<code>object = value,...</code>),for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Counter</span><br><span class="line">&gt;&gt;&gt; c1 = Counter(&apos;anysequence&apos;)</span><br><span class="line">&gt;&gt;&gt; c2 = Counter(&#123;&apos;a&apos;:1,&apos;c&apos;:1,&apos;e&apos;:3&#125;)</span><br><span class="line">&gt;&gt;&gt; c1</span><br><span class="line">Counter(&#123;&apos;e&apos;: 3, &apos;n&apos;: 2, &apos;a&apos;: 1, &apos;y&apos;: 1, &apos;s&apos;: 1, &apos;q&apos;: 1, &apos;u&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; c2</span><br><span class="line">Counter(&#123;&apos;e&apos;: 3, &apos;a&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>We can also create an empty counter object and populate it by passing its update method an iterable or a dictionary, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ct = Counter()</span><br><span class="line">&gt;&gt;&gt; ct.update(&apos;abca&apos;)</span><br><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;&apos;a&apos;: 2, &apos;b&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; ct.update(&#123;&apos;a&apos;:3&#125;)</span><br><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;&apos;a&apos;: 5, &apos;b&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>Notice how the update method adds the counts rather than replacing them with new values. Once the counter is populated, we can access stored values in the same way we would for dictionaries, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;&apos;a&apos;: 5, &apos;b&apos;: 1, &apos;c&apos;: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; for item in ct:</span><br><span class="line">...     print(&apos;%s:%d&apos;%(item,ct[item]))</span><br><span class="line">... </span><br><span class="line">a:5</span><br><span class="line">b:1</span><br><span class="line">c:1</span><br></pre></td></tr></table></figure>

<p>The most notable difference between counter objects and dictionaries is that counter objects return a zero count for missing items rather than raising a key error,for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ct[&apos;x&apos;]</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>We can create an iterator out of a Counter object by using its <code>elements()</code> method.This returns an iterator where counts below one are not included and the order is not guaranteed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ct.update(&#123;&apos;a&apos;:-3,&apos;b&apos;:-2,&apos;d&apos;:3,&apos;e&apos;:2&#125;)</span><br><span class="line">sorted(ct.elements())# returns a sorted list from the iterator</span><br><span class="line">[&apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;e&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure>

<p>Two other Counter methods worth mentioning are <code>most_common()</code> and <code>subtract()</code> . </p>
<p>The most common method takes a positive integer argument that determines the number of most common elements to return. Elements are returned as a list of (key ,value) tuples. The subtract method works exactly like update except instead of adding values, it subtracts them.</p>
<h2 id="Ordered-dictionaries"><a href="#Ordered-dictionaries" class="headerlink" title="Ordered dictionaries"></a>Ordered dictionaries</h2><p>When we test to see whether two dictionaries are equal, this equality is only based on their keys and values; however, with an OrderedDict , the insertion order is also considered An equality test between two <code>OrderedDicts</code> with the same keys and values but a different insertion order will return False :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import OrderedDict</span><br><span class="line">&gt;&gt;&gt; od1=OrderedDict()</span><br><span class="line">&gt;&gt;&gt; od1[&apos;one&apos;]=1</span><br><span class="line">&gt;&gt;&gt; od1[&apos;two&apos;]=2</span><br><span class="line">&gt;&gt;&gt; od2=OrderedDict()</span><br><span class="line">&gt;&gt;&gt; od2[&apos;two&apos;]=2</span><br><span class="line">&gt;&gt;&gt; od2[&apos;one&apos;]=1</span><br><span class="line">&gt;&gt;&gt; od1==od2</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>Similarly, when we add values from a list using update , the OrderedDict will retain the same order as the list. This is the order that is returned when we iterate the values, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kvs = [(&apos;three&apos;,3),(&apos;four&apos;,4),(&apos;five&apos;,5),(&apos;six&apos;,6)]</span><br><span class="line">&gt;&gt;&gt; od1.update(kvs)</span><br><span class="line">&gt;&gt;&gt; for k,v in od1.items():print(k,v)</span><br><span class="line">... </span><br><span class="line">one 1</span><br><span class="line">two 2</span><br><span class="line">three 3</span><br><span class="line">four 4</span><br><span class="line">five 5</span><br><span class="line">six 6</span><br></pre></td></tr></table></figure>

<p>The OrderedDict is often used in conjunction with the sorted method to create a sorted dictionary.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; od3 = OrderedDict(sorted(od1.items(),key = lambda t:(4*t[1])-t[1]**2))</span><br><span class="line">&gt;&gt;&gt; od3.values()</span><br><span class="line">odict_values([6, 5, 4, 1, 3, 2])</span><br><span class="line">&gt;&gt;&gt; od3</span><br><span class="line">OrderedDict([(&apos;six&apos;, 6), (&apos;five&apos;, 5), (&apos;four&apos;, 4), (&apos;one&apos;, 1), (&apos;three&apos;, 3), (&apos;two&apos;, 2)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>The defaultdict object is a subclass of dict and therefore they share methods and operations. It acts as a convenient way to initialize dictionaries. With a dict , Python will throw a KeyError when attempting to access a key that is not already in the dictionary. The defaultdict overrides one method, <strong>missing</strong>(key) , and creates a new instance variable, default_factory . With defaultdict , rather than throw an error, it will run the function, supplied as the default_factory argument, which will generate a value. A simple use of defaultdict is to set default_factory to int and use it to quickly tally the counts of items in the dictionary, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def isprimary(c):</span><br><span class="line">...     if(c==&apos;red&apos;) or (c==&apos;blue&apos;) or (c==&apos;green&apos;):</span><br><span class="line">...             return True</span><br><span class="line">...     else:</span><br><span class="line">...             return False</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd2=defaultdict(bool)</span><br><span class="line">&gt;&gt;&gt; dd2</span><br><span class="line">defaultdict(&lt;class &apos;bool&apos;&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; words=[&apos;blue&apos;,&apos;green&apos;,&apos;red&apos;,&apos;yellow&apos;]</span><br><span class="line">&gt;&gt;&gt; for word in words:dd2[word]=isprimary(word)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; dd2</span><br><span class="line">defaultdict(&lt;class &apos;bool&apos;&gt;, &#123;&apos;blue&apos;: True, &apos;green&apos;: True, &apos;red&apos;: True, &apos;yellow&apos;: False&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Named-tuples"><a href="#Named-tuples" class="headerlink" title="Named tuples"></a>Named tuples</h2><p>The namedtuple method returns a tuple-like object that has fields accessible with named indexes as well as the integer indexes of normal tuples.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import namedtuple</span><br><span class="line">&gt;&gt;&gt; space = namedtuple(&apos;space&apos;,&apos;x y z&apos;)</span><br><span class="line">&gt;&gt;&gt; space</span><br><span class="line">&lt;class &apos;__main__.space&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; s1 = space(x=2.0,y=4.0,z=10)#we can also use space(2.0,4.0,10)</span><br><span class="line">&gt;&gt;&gt; s1.x*s1.y*s1.z#calculates the volume</span><br><span class="line">80.0</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>The namedtuple method take two optional Boolean arguments, verbose and rename . When verbose is set to True then the class definition is printed when it is built. This argument is depreciated in favor of using the __source attribute. When the rename argument is set to True then any invalid field names will be automatically replaced with positional arguments. As an example, we attempt to use def as a field name. This would normally generate an error, but since we have assigned rename to True , the Python interpreter allows this. However, when we attempt to look up the def value, we get a syntax error, since def is a reserved keyword. The illegal field name has been replaced by a field name created by adding an underscore to the positional value:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; space2 = namedtuple(&apos;space2&apos;,&apos;x def z&apos;,rename=True)</span><br><span class="line">&gt;&gt;&gt; s1 = space2(3,4,5)</span><br><span class="line">&gt;&gt;&gt; s.def</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    s.def</span><br><span class="line">        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">space2(x=3, _1=4, z=5)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>In addition to the inherited tuple methods, the named tuple also defines three methods of its own, _make() , asdict() , and _replace . These methods begin with an underscore to prevent potential conflicts with field names. The _make() method takes an iterable as an argument and turns it into a named tuple object, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sl=[4,5,6]</span><br><span class="line">&gt;&gt;&gt; space._make(sl)</span><br><span class="line">space(x=4, y=5, z=6)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>_asdict</code> method returns an OrderedDict with the field names mapped to index keys and the values mapped to the dictionary values, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1._asdict()</span><br><span class="line">OrderedDict([(&apos;x&apos;, 3), (&apos;_1&apos;, 4), (&apos;z&apos;, 5)])</span><br></pre></td></tr></table></figure>

<p>The _replace method returns a new instance of the tuple, replacing the specified values,<br>for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[82]: s1._replace(x=7, z=9)</span><br><span class="line">Out[82]: space2 (x=7, _l=4, z=9)</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>The array module defines a datatype array that is similar to the list datatype except for the constraint that their contents must be of a single type of the underlying representation, as is determined by the machine architecture or underlying C implementation.</p>
<p>The array objects support the following attributes and methods:<br>Attributed or method Description<br>Method|Description<br>—|—<br>a.typecode|The typecode character used to create the array.<br>a.itemsize|Size,in bytes of items stored in the array.<br>a.append(x)|Appends item x to the end of the array.<br>a.buffer_info()|Returns the memory location and length of the buffer userd to store the array.<br>a.byteswap()|Swaps the byte order of each item.Used for writing to a machine or file with a different byte order.<br>a.count(x)|Returns the number of occurrences of x in a .<br>a.extend(b)|Appends any iterable, b , to the end of array a .<br>a.frombytes(s)|Appends items from a string, s , as an array of machine values.<br>a.fromfile(f, n)|Reads n items, as machine values, from a file object, f , and appends them to a . Raises an EOFError if there are fewer than n items in n .<br>a.fromlist(l)|Appends items from list l .<br>a.fromunicode(s)|Extends a with unicode string s . Array a must be of type u or else ValueError is raised.<br>index(x)|Returns the first (smallest) index of item x.<br>a.insert(i, x)|Inserts item x before index i.<br>a.pop([i])|Removes and returns items with index i . Defaults to the last item (i = -1) if not specified.<br>a.remove(x)|Removes the first occurrence of item x .<br>a.reverse()|Reverses the order of items.<br>a.tobytes()|Convert the array to machine values and returns the bytes representation.<br>a.tofile(f)|Writes all items, as machine values, to file object f.<br>a.tolist()|Converts the array to a list.<br>a.tounicode()|Convert an array to unicode string. The array type must be ‘u’ or else a ValueError is raised.</p>
<p>Array objects support all the normal sequence operations such as indexing, slicing, concatenation, and multiplication.</p>
<p>因为我们对节省空间感兴趣，也就是说，我们正在处理大型数据集和有限的内存大小，所以我们通常在数组上执行就地操作，并且只在需要时创建副本。 通常，枚举用于对每个元素执行操作。 在下面的代码片段中，我们执行向数组中的每个项添加一个的简单操作：<br>应该注意的是，当对创建列表的数组（例如列表推导）执行操作时，首先使用数组的内存效率增益将被否定。 当我们需要创建一个新的数据对象时，解决方案是使用生成器表达式来执行操作，例如：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaohui Bai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BaiZhaohui" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:isolatedislet@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaohui Bai</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

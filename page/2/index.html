<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Mist">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Mist">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mist">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Mist</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mist</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/直击招聘3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/直击招聘3/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h1><p>通用算法是用来操作容器中的数据的模板函数。算法部分主要由头文件<algorithm>、<numeric>、<functional>组成。<br>STL中算法大致可以分为以下4类：</functional></numeric></algorithm></p>
<ul>
<li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li>
<li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li>
<li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li>
<li>数值算法：对容器内容进行数值计算</li>
</ul>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul>
<li>adjacent_find()：在iterator对指定的元素范围内查找一对相邻重复元素，若找到，返回指向这对元素的第一个元素的位置，否则返回last。</li>
<li>binary_search()：在有序序列中二分查找value，若找到，返回true</li>
<li>count()：利用等于运算符把指定范围内的元素与输入值相比较，返回相等元素的个数。</li>
<li>count_if()：利用给定的谓词对指定范围内的元素进行操作，返回结果为true的个数。</li>
<li>find()：利用底层元素的等于运算符对指定范围内的元素与输入值进行比较，当匹配时结束，返回该元素的一个位置。</li>
<li>find_if()：使用给定的谓词代替等于运算符执行find。</li>
<li>lower_bound()：返回一个迭代器，指向在有序序列范围内插入指定值而不破坏容器顺序的第一个位置。</li>
<li>upper_bound()：返回一个迭代器，指向在有序序列范围内插入指定值而不破坏容器顺序的最后一个位置，该位置是一个大于value的值。</li>
</ul>
<p>InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);<br>其中first和last是两个迭代器确定查找的序列范围；pred为谓词对象，用于执行某种动作或者操作，通常返回true或者false，像==比较运算符就是这样的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stud(<span class="keyword">int</span> n, <span class="built_in">string</span> na) :no(n), name(na) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; no &lt;&lt; <span class="string">","</span> &lt;&lt; name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">Getname</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> test;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cmp(<span class="built_in">string</span> str) :test(str) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Stud &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s.Getname() == test;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stud a[]&#123; Stud(<span class="number">2</span>,<span class="string">"Marry"</span>),Stud(<span class="number">1</span>,<span class="string">"John"</span>),Stud(<span class="number">3</span>,<span class="string">"Smith"</span>) &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">vector</span>&lt;Stud&gt;myv(a, a + n);</span><br><span class="line">	<span class="built_in">vector</span>&lt;Stud&gt;::iterator it;</span><br><span class="line">	it = find_if(myv.begin(), myv.end(), Cmp(<span class="string">"Marry"</span>));</span><br><span class="line">	it-&gt;Disp();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序中，Cmp是一个谓词对象类，执行find_if(myv.begin(),myv.end(),Cmp(“Marry”))语句时第3个实参Cmp(“Marry”)创建一个Cmp对象并赋值给形参pred。find_if()通过调用pred进行元素的查找，而Cmp中重载了函数调用()运算符，所以执行该重载运算符实现元素的查找，成功时返回其位置（即no为2）的元素。</p>
<h3 id="排序和通用算法"><a href="#排序和通用算法" class="headerlink" title="排序和通用算法"></a>排序和通用算法</h3><p>这类算法用于提供元素排序策略。</p>
<ul>
<li>merge()：合并两个有序序列，存放到另一个序列。</li>
<li>nth_element()：将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它的前面，大于它的出现在它的后面。</li>
<li>partial_sort()：对序列做部分排序，被排序的元素个数正好可以被放到范围内。</li>
<li>partition()：对指定范围内的元素重新排序，使用关系函数，把结果为true的元素放在结果为false的元素之前。</li>
<li>reverse()：将指定范围内的元素重新反序排序。</li>
<li>reverse_copy()：与reverse()类似，不过将结果写到另一个容器。</li>
<li>rotate()：将指定范围内的元素移到容器末尾，由middle指向的元素成为容器的第一个元素。例如，hissboo以元素’b’旋转后变为boohiss。</li>
<li>rotate_copy()</li>
<li>sort()：默认以升序重新排列</li>
<li>stable_sort()：采用稳定排序方法</li>
</ul>
<p>以partition()为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;myv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myv.begin(); it != myv.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Less0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myv(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myv: "</span>; Disp(myv);</span><br><span class="line">	partition(myv.begin(), myv.end(), Less0());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myv: "</span>; Disp(myv);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除和替换算法"><a href="#删除和替换算法" class="headerlink" title="删除和替换算法"></a>删除和替换算法</h3><ul>
<li>copy()：复制序列</li>
<li>copy_backward()：与copy()相同，不过元素是以相反的顺序被复制。</li>
<li>remove()：删除指定范围内所有等于指定元素的元素。注意，该函数不是真正的删除函数。内置数组不适合使用remove和remove_if函数。</li>
<li>remove_if()：删除指定范围内谓词结果为true的所有元素。</li>
<li>replace()：将指定范围内所有等于old_value的元素用new_value代替。</li>
<li>unique()：清除序列中的重复元素，和remove类似，它也不能真正地删除元素。</li>
<li>unique_copy()：与unique()类似，但是把结果输出到另一个容器。</li>
</ul>
<h3 id="排列组合算法"><a href="#排列组合算法" class="headerlink" title="排列组合算法"></a>排列组合算法</h3><p>这类算法提供计算给定集合按一定顺序的所有可能排列组合。</p>
<ul>
<li>next_permutation()：取出当前范围内的排列，并重新排列为下一个序列。</li>
<li>prev_permutation()：取出指定范围内的序列，并将它重新排序为上一个序列。</li>
</ul>
<h3 id="生成和异变算法"><a href="#生成和异变算法" class="headerlink" title="生成和异变算法"></a>生成和异变算法</h3><ul>
<li>fill()：将输入值赋给指定范围内的所有元素。</li>
<li>fill_n()：将输入值赋给first到first+n范围内的所有元素。</li>
<li>for_each()：用指定函数依次对指定范围内的所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;myv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>(*pf)(<span class="keyword">int</span>) = print;</span><br><span class="line">	for_each(myv.begin(), myv.end(), pf);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="关系算法"><a href="#关系算法" class="headerlink" title="关系算法"></a>关系算法</h3><ul>
<li>equal()</li>
<li>include()：判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;运算符，若成功返回true。</li>
<li>lexicographical_compare()：比较两个序列。</li>
<li>max()</li>
<li>max_element()</li>
<li>min()</li>
<li>min_element()</li>
</ul>
<h3 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h3><ul>
<li>set_union()：并集运算，构造一个有序序列，包含两个序列中所有的不重复元素</li>
<li>set_intersection()：交集运算，构造一个有序序列，其中元素在两个序列中都存在。</li>
<li>set_difference()：差集运算，构造一个有序序列，该序列仅保留第一个序列中存在的但第二个序列中不存在的元素。</li>
</ul>
<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><ul>
<li>make_heap()：将指定范围内的元素做成一个堆</li>
<li>pop_heap()：从堆中弹出一个元素</li>
<li>push_heap()：将一个元素插入堆中</li>
<li>sort_heap()：将指定范围的元素进行堆排序（假设初始序列是一个堆）。</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>string相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还包含了所有的序列容器的操作。字符串的常用操作包括增、删、查、改、比较、链接、输入、输出等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MatchFirstChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"S"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> s == str.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; myv;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it;</span><br><span class="line">	myv.push_back(<span class="string">"She"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Sea"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Shells"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"by"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"the"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Sea"</span>);</span><br><span class="line">	myv.push_back(<span class="string">"Shore"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myv: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (it = myv.begin(); it != myv.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> n = count_if(myv.begin(), myv.end(), MatchFirstChar);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"以 S 开头的元素个数："</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/直击招聘2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/直击招聘2/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="迭代器和迭代器适配器"><a href="#迭代器和迭代器适配器" class="headerlink" title="迭代器和迭代器适配器"></a>迭代器和迭代器适配器</h1><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h3><ul>
<li>InputIterator，可读，不可写，只支持自增运算</li>
<li>OutputIterator，写，不能读，只支持自增运算</li>
<li>ForwardIterator，可读可写，只支持自增运算</li>
<li>BidirectionalIterator（双向迭代器），可读可写，支持自增和自减运算。</li>
<li>RandomAccessIterator（随机访问迭代器），可读可写，支持完整的迭代器算术运算</li>
<li>advance(it,n)函数，用于将迭代器it前进n步，相当于it=it+n</li>
</ul>
<h3 id="2-迭代器适配器"><a href="#2-迭代器适配器" class="headerlink" title="2.迭代器适配器"></a>2.迭代器适配器</h3><p>普通适配器是指容器适配器，迭代器适配器与容器适配器类似，只是底层不是一个容器，而是附属容器的那个迭代器，因此结果不再是容器适配器，而是迭代器适配器。<br>迭代器适配器分为插入迭代器、反向迭代器和流迭代器几种类型。<br>1.插入迭代器<br>        常作为参数向算法（如copy()）说明向哪个容器及其位置插入数据，而插入数据操作主要有insert(),push_back()和push_front（），对应的迭代器为insert_iterator、front_insert_iterator和back_insert_iterator。</p>
<pre><code>insert_iterator 也称为inserters，用来将”赋值新值“操作转换为”插入新值“操作。通过这种迭代器，算法可以插入（insert）行为而非覆盖（overwrite）行为。</code></pre> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Displist</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;firstlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = firstlist.begin(); it != firstlist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; firstlist(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> b[]&#123; <span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; secondlist(b, b + m);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	it = firstlist.begin();</span><br><span class="line">	advance(it, <span class="number">3</span>);</span><br><span class="line">	insert_iterator&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; insert_it(firstlist, it);</span><br><span class="line">	copy(secondlist.begin(), secondlist.end(), insert_it);<span class="comment">//将secondlist元素复制到insert_it处</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"firstlist: "</span>; </span><br><span class="line">	Displist(firstlist);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"secondlist: "</span>;</span><br><span class="line">	Displist(secondlist);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序使用insert_iterator迭代器inset_it将secondlist的所有元素插入到firstlist中第4个元素开始的地方。</p>
<p>2.反向迭代器<br>        反向迭代器重新定义递增运算和递减运算，使其行为与正向迭代器正好倒置。<br>3.流迭代器<br>        流迭代器是一种迭代器适配器，通过它可以把stream当成算法的原点和终点。<br>        一个istream迭代器可以用来从输入流中读元素，而一个ostream迭代器可以用来对输出流写入元素。<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;T&gt; 标识符(istream &amp;);</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; ins(<span class="built_in">cin</span>); <span class="comment">//istream迭代器ins从键盘获取一个int整数序列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// istream迭代器ins从abc.txt文件中获取一个int整数序列</span></span><br><span class="line"><span class="function">istream <span class="title">infile</span><span class="params">(<span class="string">"abc.txt"</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; ins(infile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream_iterator&lt;T&gt;标识符(ostream &amp;);</span><br><span class="line">ostream_iterator&lt;T&gt; 标识符(ostream &amp;,<span class="keyword">char</span> *delimiter);</span><br><span class="line">其中delimiter是一个C风格字符串，它被输出到每个元素的后面</span><br><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; outs(<span class="built_in">cout</span>,<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ostream <span class="title">outfile</span><span class="params">(<span class="string">"abc.txt"</span>)</span></span>;</span><br><span class="line">ostream_iterator &lt;<span class="keyword">int</span>&gt; outs(outfile,<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/直击招聘1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/直击招聘1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="STL：标准模板库"><a href="#STL：标准模板库" class="headerlink" title="STL：标准模板库"></a>STL：标准模板库</h1><p>STL中主要包含：container容器、algorithm算法、iterator迭代器。容器用于存放数据对象（元素），算法用于操作容器中的数据对象。尽管各种容器的内部结构各异，但是其外部常常给人的感觉都是相似的，即将对容器数据的操作设计称通用算法，也就是将算法和容器分离开来。算法和容器的中介就是迭代器。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h4><ul>
<li>vector（向量）：连续存储元素</li>
<li>list（链表）：由结点组成的双向链表，每个节点包含一个元素</li>
<li>deque（双端队列）：连续存储的指向不同元素的指针所组成的数组。<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4></li>
<li>set（集合）/multiset（多重集合）：由结点组成的红黑树，每个结点都包含一个元素。在set中没有相同关键字的元素，而multiset中允许存在两个相同的关键字的元素。</li>
<li>map（映射）/multimap（多重映射）：由（关键字，值）对组成的集合。在map中没有关键字相同的元素，而multimap中允许存在两个关键字相同的元素。<h4 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h4></li>
<li>stack（栈）：先进后出的序列</li>
<li>queue（队列）：先进先出的序列</li>
<li>priority_queue（优先队列）：元素的出队次序由指定的某种谓词决定的一种队列<h4 id="哈希容器"><a href="#哈希容器" class="headerlink" title="哈希容器"></a>哈希容器</h4></li>
<li>hash_map（hash_multimap,hash_set,hash_multiset）：哈希表</li>
<li>unordered_map：无序哈希表，替代hash_map</li>
</ul>
<h3 id="1-Vector（向量容器）"><a href="#1-Vector（向量容器）" class="headerlink" title="1.Vector（向量容器）"></a>1.Vector（向量容器）</h3><p>vector相当于动态数组，存储具有相同类型的一组元素，可以从尾部快速插入与删除元素，快速随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入和删除位置后的所有元素。如果出事分配的内存空间不够，当超过空间大小的时候，会重新分配更大的空间（通常按两倍大小扩展），此时需要进行大量的元素复制，增加了性能开销。<br>定义vector的几种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;<span class="comment">//定义元素为int的向量v1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>); <span class="comment">// 指定向量v2的初始大小为10个int元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1.23</span>); <span class="comment">//指定向量v3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4(a,a+<span class="number">5</span>);<span class="comment">// 用数组a[0...4]共5个元素初始化v4</span></span><br></pre></td></tr></table></figure>

<p>主要成员函数：</p>
<ul>
<li>max_size()：vector中能保存的最大元素个数。</li>
<li>size()： 当前vector中实际元素个数</li>
<li>[]：返回指定下标的元素，表明vector的元素可以随机访问</li>
<li>reserve(n)：为vector容器预分配n个元素的存储空间</li>
<li>capacity()：返回当前vector在重新分配内存前所能容纳的元素个数</li>
<li>resize(n)：调整vector容器的大小，使其能容纳n个元素。</li>
<li>empty()：判断vector是否为空。</li>
<li>at()：返回指定位置的元素。</li>
<li>front()：获取vector中第1个元素</li>
<li>back()：获取vector中最后一个元素</li>
<li>assign()：给vector中元素赋值</li>
<li>insert()：参数：位置迭代器及要插入元素，将待插入元素插入迭代器指定元素之前。</li>
<li>push_back()：在vector尾部添加一个元素。</li>
<li>pop_back()：删除vector的尾部元素。</li>
<li>erase()：删除某个iterator或者iterator区间指定的元素。</li>
<li>clear()：删除vector中所有元素。</li>
<li>begin()：用于正向迭代，返回vector中第一个元素的位置。</li>
<li>end()：用于正向迭代，返回vector中最后一个元素后面的一个位置。</li>
<li>rbegin()：用于反向迭代，返回最后一个元素的位置。</li>
<li>rend()：用于反向迭代，返回第一个元素前面一个位置。</li>
</ul>
<p><strong>注意</strong>：resize()和reserve()说明如下。<br>    1.reserve()是为容器预留空间，但不是真正创建元素对象，在创建元素对象之前不能引用容器内的元素，因此当加入新的元素时需要用push_back()/insert()函数。<br>    2.resize()是改变容器的大小，并创建对象，因此在调用这个函数后就可以引用容器内的对象了，故加入新的元素时用operator[]操作符或者用迭代器来引用元素对象。<br>    3.reserve()函数需要一个参数指出要预留的容器的大小；resize()函数可以有两个参数，第1个参数是容器的新的大小，第2个参数是要加入容器的新元素，如果这个参数省略，那么就调用元素对象的默认构造函数。<br>    4.采用reserve()成员函数为vector预先分配需要的内存空间可以提高执行效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(a, a + <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">////正向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it,it1;</span><br><span class="line">	<span class="keyword">for</span> (it = vec.begin(); it != vec.end(); ++it)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit;</span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找某个元素</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">	it1 = find(vec.begin(),vec.end(),x);</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找到元素"</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; *it1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未找到元素"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递减排序</span></span><br><span class="line">	sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果反向迭代，迭代器的创建使用<code>vector&lt;int&gt;::reverse_iterator rit;</code>来创建，而且在遍历的时候，如果起始以vec.rbegin()开始，以vec.rend()结束的话，rit还是以增的方式进行变化，而不是减，虽然是反向遍历。</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find() 为输入迭代器所定义的范围内查找单个对象的算法，可以在前两个参数指定的范围内，查找与第三个参数相等的第一个对象。它会返回一个指向被找到对象的迭代器，如果没有找到对象，会返回这个序列的结束迭代器。<br>其调用形式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（start,end,value）</span><br></pre></td></tr></table></figure>

<p>容器的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a.begin(),a.end(),value）</span><br></pre></td></tr></table></figure>

<p>数组的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a,a+length,val）</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>所有的sort算法的参数都需要输入一个范围，[begin, end)。这里使用的迭代器(iterator)都需是随机迭代器(RadomAccessIterator), 也就是说可以随机访问的迭代器（partition 和stable_partition 除外）。可以自定义比较函数作为参数传入。</p>
<h3 id="2-deque（双端队列容器）"><a href="#2-deque（双端队列容器）" class="headerlink" title="2.deque（双端队列容器）"></a>2.deque（双端队列容器）</h3><p>它是一个双端队列类模板。双端队列容器可以从前面或者后面快速插入与删除元素，并且可以快速随机访问元素，但是在中间插入和删除元素较慢。deque容器采用多个连续的存储块，即由一段一段的定量连续空间构成，随时可以增加一段新的空间并连接起来，因此deque没有capacity的概念。deque通过一个中央管理器来管理这些空间并隐藏deque的这些底层细节，让用户感觉在使用一个整体连续对象，并且提供了随机存取的接口。deque的空间的重新分配比vector快，在重新分配空间后原有的元素不需要全部复制。实际上，deque是对vector和list优/缺点的结合，它是处于两者之间的一种容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq1; <span class="comment">//定义元素为int的双端队列dq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq2(<span class="number">10</span>);<span class="comment">//指定双端队列dq2的初始大小为10个int 元素</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt;dq3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq4(dq2.begin(),dq2.end());<span class="comment">//用dq2的所有元素初始化dq4</span></span><br></pre></td></tr></table></figure>

<p>deque主要的成员函数：</p>
<ul>
<li>size()</li>
<li>[]</li>
<li>empty()</li>
<li>at()</li>
<li>front()</li>
<li>back()</li>
<li>push_front()</li>
<li>push_back()</li>
<li>pop_front()</li>
<li>pop_back()</li>
<li>erase()：删除指定位置或者指定区间的元素</li>
<li>clear()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispdq</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;dq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = dq.begin(); it != dq.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">	dq.push_front(<span class="number">1</span>);</span><br><span class="line">	dq.push_back(<span class="number">2</span>);</span><br><span class="line">	dq.push_front(<span class="number">3</span>);</span><br><span class="line">	dq.push_back(<span class="number">4</span>);</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	dq.pop_front();</span><br><span class="line">	dq.pop_back();</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-list（链表容器）"><a href="#3-list（链表容器）" class="headerlink" title="3.list（链表容器）"></a>3.list（链表容器）</h3><p>它是一个双链表类模板，可以从任何地方快速插入与删除。它的每个元素间用指针链接。与vector相比，list不支持随机访问（没有提供operator[]运算符和at()成员函数），为了访问链表容器中特定的元素，必须从第1个位置（表头）开始，随着指针从一个元素到下一个元素，直到找到满足条件的元素。<br>list中插入元素的速度比vector中快。由于list对每个元素单独分配空间，所以不存在空间不够、重新分配空间的情况。<br>定义list对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l2(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line">lsit&lt;<span class="keyword">int</span>&gt;l4(a,a+<span class="number">5</span>);<span class="comment">//用数组a[0...4]共5个元素初始化l4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>的主要成员函数：</span><br><span class="line">- size()</span><br><span class="line">- empty()</span><br><span class="line">- push_back()</span><br><span class="line">- pop_back()</span><br><span class="line">- push_front()</span><br><span class="line">- pop_front()</span><br><span class="line">- insert(pos,num)</span><br><span class="line">- insert(pos,n,num)：在pos位置插入n个元素num</span><br><span class="line">- insert(pos,beg,end)：在pos位置插入区间为[beg,end]的元素</span><br><span class="line">- remove()：删除<span class="built_in">list</span>中所有指定值的元素</span><br><span class="line">- remove_if(cmp)：删除条件满足的元素</span><br><span class="line">- erase()：从<span class="built_in">list</span>中删除一个或者几个元素</span><br><span class="line">- clear()</span><br><span class="line">- unique()：删除相邻的重复元素</span><br><span class="line">- reverse()：反转链表</span><br><span class="line">- sort()：对<span class="built_in">list</span>容器中的元素排序</span><br><span class="line">- c1.merge(c2)：合并两个有序的链表并使之有序，重新放到c1中，且释放c2。</span><br><span class="line">- c1.merge(c2,comp)，合并两个有序链表，并使之按照自定义 规则排序之后重新放到c1，且释放c2。</span><br><span class="line">- c1.splice(c1.beg,c2)：将c2连接在c1的beg位置，并释放c2</span><br><span class="line">- begin()</span><br><span class="line">- end()：用于正向迭代，返回<span class="built_in">list</span>中最后一个元素后面的一个位置</span><br><span class="line">- rbegin()</span><br><span class="line">- rend()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + n);</span><br><span class="line">	<span class="comment">//mylist.remove(3);</span></span><br><span class="line">	mylist.remove_if(cmp);</span><br><span class="line">	mylist.unique();</span><br><span class="line">	Disp(mylist);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于STL算法中的排序算法sort()只能用于顺序容器，不能用于list容器，所以list提供了自己的sort成员函数。<br>在使用list.sort()时，默认情况下使用底层元素类型的小于运算符按递增方式排序，如果按递减排序，需使用预定义的类模板greater，它调用底层元素类型的大于运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + <span class="number">6</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">mylist.sort();</span><br><span class="line">Disp(mylist);</span><br><span class="line">mylist.sort(greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">Disp(mylist);</span><br></pre></td></tr></table></figure>


  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myClass(<span class="keyword">int</span> m) :n(m)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> myClass &amp;s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (n &gt; s.getn());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Displist</span><span class="params">(<span class="built_in">list</span>&lt;myClass&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;getn();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myClass obj1(3), obj2(5), obj3(2);</span><br><span class="line">	myClass obj4(7), obj5(4), obj6(1),obj7(6);</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt; mylist1, mylist2;</span><br><span class="line">	mylist1.push_back(obj1);</span><br><span class="line">	mylist1.push_back(obj2);</span><br><span class="line">	mylist1.push_back(obj3);</span><br><span class="line">	mylist2.push_back(obj4);</span><br><span class="line">	mylist2.push_back(obj5);</span><br><span class="line">	mylist2.push_back(obj6);</span><br><span class="line">	mylist2.push_back(obj7);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	mylist1.sort();</span><br><span class="line">	mylist2.sort();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1合并到mylist2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	mylist2.merge(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-set（集合容器）-multiset（多重集合容器）"><a href="#4-set（集合容器）-multiset（多重集合容器）" class="headerlink" title="4.set（集合容器）/multiset（多重集合容器）"></a>4.set（集合容器）/multiset（多重集合容器）</h3><p>vector,dque,list均属于顺序容器，这类容器通过元素在容器中的位置来顺序存储和访问元素；而set/multiset、map/multimap属于关联容器，这类容器中的每个元素都有一个key（关键字），通过key来存储和读取元素。关联容器不提供顺序容器中的front()、push_front()、back()、push_back()以及pop_back()操作。<br>set的底层使用一种平衡二叉树（即红黑树）实现，在插入、删除时仅需要操作结点指针即可完成，不涉及内存移动和复制，所以效率比较高。默认情况下会对元素按关键字自动进行升序排列，所以查找速度比较快，同时支持交、差、并等集合运算。由于set中没有相同关键字的元素，在向set中插入元素时，如果已经存在，则不插入。multiset中允许存在两个相同关键字的元素，删除multiset中值等于elem的所有元素，若删除成功，返回删除个数，否则返回0。<br>set/multiset成员函数：</p>
<ul>
<li>max_size()</li>
<li>size()</li>
<li>empty()</li>
<li>insert()</li>
<li>erase()</li>
<li>clear()</li>
<li>count(k)：返回容器中关键字k出现的次数</li>
<li>find(k):如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值</li>
<li>upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素</li>
<li>lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispset</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;myset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myset.begin(); it != myset.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set1, set2, set3;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	set1.insert(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> b[]&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>]);</span><br><span class="line">	set2.insert(b, b + m);</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set1: "</span>;</span><br><span class="line">	Dispset(set1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set2: "</span>;</span><br><span class="line">	Dispset(set2);</span><br><span class="line">	insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; insert_it(set3, set3.begin());</span><br><span class="line">	set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"并集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"交集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"差集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-map（映射容器）-multimap（多重映射容器）"><a href="#5-map（映射容器）-multimap（多重映射容器）" class="headerlink" title="5.map（映射容器）/multimap（多重映射容器）"></a>5.map（映射容器）/multimap（多重映射容器）</h3><p>它们是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。set/multiset中的key和value是key类型的，而map中的key和value是一个pair类结构（二元组）中的两个分量。<br>pair类结构用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较的比较运算符模板函数。例如定义了一个对象p1表示一个平面坐标点并输入坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;p1;<span class="comment">//定义pair对象p1</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p1.first&gt;&gt;p1.second;<span class="comment">//输入p1的坐标</span></span><br></pre></td></tr></table></figure>

<p>map/multimap 中所有key-value对按key的升序排列，以平衡二叉树（红黑树）的形式存储，可以根据key快速找到与之对应的value，利用key类型的&lt;运算符比较大小，对于非内置类型的元素，需要自己定义或者重载&lt;运算符。map中不允许关键字重复出现，存在[ ]运算符；而multimap中允许关键字重复出现，但没有[ ]运算符。<br>map/multimap的主要成员函数：</p>
<ul>
<li>max_size</li>
<li>size()</li>
<li>empty()</li>
<li>map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字则以key为关键字插入一个元素（不适合multimap）。</li>
<li>insert(elem)：插入一个元素elem并返回该元素的位置。</li>
<li>clear()</li>
<li>find()</li>
<li>count()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
</ul>
<p>map中改变元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap; <span class="comment">//定义map对象mymap</span></span><br><span class="line">mymap[<span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">//或者mymap.insert(pair&lt;char,int&gt;('a',1));</span></span><br></pre></td></tr></table></figure>

<p>获得map中一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = mymap[<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispmap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;mymap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mymap.begin(); it != mymap.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;first&lt;&lt;<span class="string">" "</span> &lt;&lt; it-&gt;second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymap;</span><br><span class="line">	mymap.insert(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'a'</span>, <span class="number">1</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">'b'</span>, <span class="number">2</span>));</span><br><span class="line">	mymap[<span class="string">'c'</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap: "</span>;</span><br><span class="line">	Dispmap(mymap);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-stack（栈容器）"><a href="#6-stack（栈容器）" class="headerlink" title="6.stack（栈容器）"></a>6.stack（栈容器）</h3><p>stack、queue和priority_queue都是适配器容器，适配器容器是基于其他某种底层容器实现的。<br>如默认的stack和queue都基于deque容器实现，而priority_queue则在vector容器上实现，也可以指定其他底层容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; myst; <span class="comment">//第二个参数指定底层容器为vector</span></span><br></pre></td></tr></table></figure>

<p>显示指定适配器容器的底层容器时必须满足一定的约束条件，因为适配器容器都根据底层容器来定义自己的操作。如stack关联的底层容器可以是任何一种顺序容器类型，因此stack可以建立在vector、list、deque容器之上（一般用vector和deque实现比list实现的性能好）。queue要求其底层容器必须支持push_front运算，因此只能建立在list和deque容器上，而不能建立在vector容器上。priority_queue要求提供随机访问功能，因此可建立在vector或deque容器上，但不能建立在list容器上。<br>可以看出适配器容器并没有提供与元素保存的保存形式有关的真正的数据结构实现，所以适配器容器不支持迭代器。<br>从一般算法角度看，stack就是一个栈类模板。栈具有先进后出的特点，只有一个出口，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>push()：元素进栈</li>
<li>top()：返回栈顶元素</li>
<li>pop()</li>
</ul>
<h3 id="7-queue（队列容器）"><a href="#7-queue（队列容器）" class="headerlink" title="7.queue（队列容器）"></a>7.queue（队列容器）</h3><p>它是一个队列类模板。先进先出，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>front()：返回队头元素</li>
<li>back()：返回队尾元素</li>
<li>push()：元素进队</li>
<li>pop()</li>
</ul>
<h3 id="8-priority-queue（优先队列容器）"><a href="#8-priority-queue（优先队列容器）" class="headerlink" title="8.priority_queue（优先队列容器）"></a>8.priority_queue（优先队列容器）</h3><p>它是一个优先队列类模板，它是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列中最高优先级的元素。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>top()</li>
<li>push()</li>
<li>pop()<br>优先队列中优先级的高低由队列中数据元素的关系函数（比较运算符）确定，可以使用默认，也可以重载自己编写的关系函数。</li>
</ul>
<p>1.对于C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，值越大优先级越高，可以改为以greater<t>作为关系函数，这样值越大优先级越低。</t></t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//优先队列pq1默认使用vector作为容器</span></span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq2(a, a + n);</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，但需要重载该运算符，也可以自定义相应的关系函数。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Stud(<span class="keyword">int</span> n, <span class="built_in">string</span> na) <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		no = n;</span><br><span class="line">		name = na;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&lt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &lt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&gt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &gt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  结构体的关系函数改写operator()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Studcmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Stud &amp;s1, <span class="keyword">const</span> Stud &amp;s2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s1.name &gt; s2.name;<span class="comment">//name越小优先级越高</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stud a[]&#123; Stud(<span class="number">1</span>,<span class="string">"Marry"</span>),Stud(<span class="number">3</span>,<span class="string">"John"</span>),Stud(<span class="number">2</span>,<span class="string">"Smith"</span>) &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq1.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq1.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud,<span class="built_in">vector</span>&lt;Stud&gt;,greater&lt;Stud&gt;&gt; pq2(a,a+n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq2.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq2.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	priority_queue&lt;Stud, <span class="built_in">vector</span>&lt;Stud&gt;, Studcmp&gt; pq3(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq3: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq3.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq3.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq3.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq3.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-hash-map（哈希表容器）"><a href="#9-hash-map（哈希表容器）" class="headerlink" title="9.hash_map（哈希表容器）"></a>9.hash_map（哈希表容器）</h3><p>它使用hash表的数据结构，插入的元素关键字不允许重复（重复关键字的元素不会被插入）。hash_map 的所有元素都是pair，第 1 个元素为关键字（key），不能修改，第2个元素为值（value），可被修改。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>find(const key_type&amp; k)： 查找指定关键字k的元素</li>
<li>void insert(first,last)</li>
<li>erase(iterator pos)：删除迭代器pos指定位置的元素</li>
<li>erase(const key_type&amp; k)：删除容器中等于关键字k的元素。</li>
<li>clear()：删除容器中的所有元素。</li>
</ul>
<h3 id="10-unordered-map（无序哈希表容器）"><a href="#10-unordered-map（无序哈希表容器）" class="headerlink" title="10.unordered_map（无序哈希表容器）"></a>10.unordered_map（无序哈希表容器）</h3><p>unordered_map 也是一个哈希表容器，属于C++11特性。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>hash_function()：获取存储的哈希函数对象</li>
<li>operator[]：查找与指定关键字匹配的元素。当成功时返回对应元素的迭代器指针。</li>
<li>count()</li>
<li>insert()</li>
<li>erase()</li>
<li>begin()</li>
<li>end()</li>
</ul>
<h3 id="map、hash-map、unordered-map"><a href="#map、hash-map、unordered-map" class="headerlink" title="map、hash_map、unordered_map"></a>map、hash_map、unordered_map</h3><p>1.一般情况下，unordered_map 比hash_map插入、删除操作的速度更快，查找效率相近。<br>2.map、unordered_map用法类似，只是map中的元素是有序存储的，而unordered_map无序存储，它的查找速度更快，但是占用的内存空间也更大。<br>3.非频繁的查询或者考虑有序性时采用map比较稳定；频繁查询或者不需要考虑有序性时采用unordered_map更好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/STL/" itemprop="url">STL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="STL：标准模板库"><a href="#STL：标准模板库" class="headerlink" title="STL：标准模板库"></a>STL：标准模板库</h1><p>STL中主要包含：container容器、algorithm算法、iterator迭代器。容器用于存放数据对象（元素），算法用于操作容器中的数据对象。尽管各种容器的内部结构各异，但是其外部常常给人的感觉都是相似的，即将对容器数据的操作设计称通用算法，也就是将算法和容器分离开来。算法和容器的中介就是迭代器。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h4><ul>
<li>vector（向量）：连续存储元素</li>
<li>list（链表）：由结点组成的双向链表，每个节点包含一个元素</li>
<li>deque（双端队列）：连续存储的指向不同元素的指针所组成的数组。<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4></li>
<li>set（集合）/multiset（多重集合）：由结点组成的红黑树，每个结点都包含一个元素。在set中没有相同关键字的元素，而multiset中允许存在两个相同的关键字的元素。</li>
<li>map（映射）/multimap（多重映射）：由（关键字，值）对组成的集合。在map中没有关键字相同的元素，而multimap中允许存在两个关键字相同的元素。<h4 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h4></li>
<li>stack（栈）：先进后出的序列</li>
<li>queue（队列）：先进先出的序列</li>
<li>priority_queue（优先队列）：元素的出队次序由指定的某种谓词决定的一种队列<h4 id="哈希容器"><a href="#哈希容器" class="headerlink" title="哈希容器"></a>哈希容器</h4></li>
<li>hash_map（hash_multimap,hash_set,hash_multiset）：哈希表</li>
<li>unordered_map：无序哈希表，替代hash_map</li>
</ul>
<h3 id="1-Vector（向量容器）"><a href="#1-Vector（向量容器）" class="headerlink" title="1.Vector（向量容器）"></a>1.Vector（向量容器）</h3><p>vector相当于动态数组，存储具有相同类型的一组元素，可以从尾部快速插入与删除元素，快速随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入和删除位置后的所有元素。如果出事分配的内存空间不够，当超过空间大小的时候，会重新分配更大的空间（通常按两倍大小扩展），此时需要进行大量的元素复制，增加了性能开销。<br>定义vector的几种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;<span class="comment">//定义元素为int的向量v1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>); <span class="comment">// 指定向量v2的初始大小为10个int元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1.23</span>); <span class="comment">//指定向量v3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4(a,a+<span class="number">5</span>);<span class="comment">// 用数组a[0...4]共5个元素初始化v4</span></span><br></pre></td></tr></table></figure>

<p>主要成员函数：</p>
<ul>
<li>max_size()：vector中能保存的最大元素个数。</li>
<li>size()： 当前vector中实际元素个数</li>
<li>[]：返回指定下标的元素，表明vector的元素可以随机访问</li>
<li>reserve(n)：为vector容器预分配n个元素的存储空间</li>
<li>capacity()：返回当前vector在重新分配内存前所能容纳的元素个数</li>
<li>resize(n)：调整vector容器的大小，使其能容纳n个元素。</li>
<li>empty()：判断vector是否为空。</li>
<li>at()：返回指定位置的元素。</li>
<li>front()：获取vector中第1个元素</li>
<li>back()：获取vector中最后一个元素</li>
<li>assign()：给vector中元素赋值</li>
<li>insert()：参数：位置迭代器及要插入元素，将待插入元素插入迭代器指定元素之前。</li>
<li>push_back()：在vector尾部添加一个元素。</li>
<li>pop_back()：删除vector的尾部元素。</li>
<li>erase()：删除某个iterator或者iterator区间指定的元素。</li>
<li>clear()：删除vector中所有元素。</li>
<li>begin()：用于正向迭代，返回vector中第一个元素的位置。</li>
<li>end()：用于正向迭代，返回vector中最后一个元素后面的一个位置。</li>
<li>rbegin()：用于反向迭代，返回最后一个元素的位置。</li>
<li>rend()：用于反向迭代，返回第一个元素前面一个位置。</li>
</ul>
<p><strong>注意</strong>：resize()和reserve()说明如下。<br>    1.reserve()是为容器预留空间，但不是真正创建元素对象，在创建元素对象之前不能引用容器内的元素，因此当加入新的元素时需要用push_back()/insert()函数。<br>    2.resize()是改变容器的大小，并创建对象，因此在调用这个函数后就可以引用容器内的对象了，故加入新的元素时用operator[]操作符或者用迭代器来引用元素对象。<br>    3.reserve()函数需要一个参数指出要预留的容器的大小；resize()函数可以有两个参数，第1个参数是容器的新的大小，第2个参数是要加入容器的新元素，如果这个参数省略，那么就调用元素对象的默认构造函数。<br>    4.采用reserve()成员函数为vector预先分配需要的内存空间可以提高执行效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(a, a + <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">////正向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it,it1;</span><br><span class="line">	<span class="keyword">for</span> (it = vec.begin(); it != vec.end(); ++it)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit;</span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找某个元素</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">	it1 = find(vec.begin(),vec.end(),x);</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找到元素"</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; *it1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未找到元素"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递减排序</span></span><br><span class="line">	sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果反向迭代，迭代器的创建使用<code>vector&lt;int&gt;::reverse_iterator rit;</code>来创建，而且在遍历的时候，如果起始以vec.rbegin()开始，以vec.rend()结束的话，rit还是以增的方式进行变化，而不是减，虽然是反向遍历。</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find() 为输入迭代器所定义的范围内查找单个对象的算法，可以在前两个参数指定的范围内，查找与第三个参数相等的第一个对象。它会返回一个指向被找到对象的迭代器，如果没有找到对象，会返回这个序列的结束迭代器。<br>其调用形式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（start,end,value）</span><br></pre></td></tr></table></figure>

<p>容器的表示方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a.begin(),a.end(),value）</span><br></pre></td></tr></table></figure>

<p>数组的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a,a+length,val）</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>所有的sort算法的参数都需要输入一个范围，[begin, end)。这里使用的迭代器(iterator)都需是随机迭代器(RadomAccessIterator), 也就是说可以随机访问的迭代器（partition 和stable_partition 除外）。可以自定义比较函数作为参数传入。</p>
<h3 id="2-deque（双端队列容器）"><a href="#2-deque（双端队列容器）" class="headerlink" title="2.deque（双端队列容器）"></a>2.deque（双端队列容器）</h3><p>它是一个双端队列类模板。双端队列容器可以从前面或者后面快速插入与删除元素，并且可以快速随机访问元素，但是在中间插入和删除元素较慢。deque容器采用多个连续的存储块，即由一段一段的定量连续空间构成，随时可以增加一段新的空间并连接起来，因此deque没有capacity的概念。deque通过一个中央管理器来管理这些空间并隐藏deque的这些底层细节，让用户感觉在使用一个整体连续对象，并且提供了随机存取的接口。deque的空间的重新分配比vector快，在重新分配空间后原有的元素不需要全部复制。实际上，deque是对vector和list优/缺点的结合，它是处于两者之间的一种容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq1; <span class="comment">//定义元素为int的双端队列dq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq2(<span class="number">10</span>);<span class="comment">//指定双端队列dq2的初始大小为10个int 元素</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt;dq3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq4(dq2.begin(),dq2.end());<span class="comment">//用dq2的所有元素初始化dq4</span></span><br></pre></td></tr></table></figure>

<p>deque主要的成员函数：</p>
<ul>
<li>size()</li>
<li>[]</li>
<li>empty()</li>
<li>at()</li>
<li>front()</li>
<li>back()</li>
<li>push_front()</li>
<li>push_back()</li>
<li>pop_front()</li>
<li>pop_back()</li>
<li>erase()：删除指定位置或者指定区间的元素</li>
<li>clear()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispdq</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;dq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = dq.begin(); it != dq.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">	dq.push_front(<span class="number">1</span>);</span><br><span class="line">	dq.push_back(<span class="number">2</span>);</span><br><span class="line">	dq.push_front(<span class="number">3</span>);</span><br><span class="line">	dq.push_back(<span class="number">4</span>);</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	dq.pop_front();</span><br><span class="line">	dq.pop_back();</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-list（链表容器）"><a href="#3-list（链表容器）" class="headerlink" title="3.list（链表容器）"></a>3.list（链表容器）</h3><p>它是一个双链表类模板，可以从任何地方快速插入与删除。它的每个元素间用指针链接。与vector相比，list不支持随机访问（没有提供operator[]运算符和at()成员函数），为了访问链表容器中特定的元素，必须从第1个位置（表头）开始，随着指针从一个元素到下一个元素，直到找到满足条件的元素。<br>list中插入元素的速度比vector中快。由于list对每个元素单独分配空间，所以不存在空间不够、重新分配空间的情况。<br>定义list对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l2(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line">lsit&lt;<span class="keyword">int</span>&gt;l4(a,a+<span class="number">5</span>);<span class="comment">//用数组a[0...4]共5个元素初始化l4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>的主要成员函数：</span><br><span class="line">- size()</span><br><span class="line">- empty()</span><br><span class="line">- push_back()</span><br><span class="line">- pop_back()</span><br><span class="line">- push_front()</span><br><span class="line">- pop_front()</span><br><span class="line">- insert(pos,num)</span><br><span class="line">- insert(pos,n,num)：在pos位置插入n个元素num</span><br><span class="line">- insert(pos,beg,end)：在pos位置插入区间为[beg,end]的元素</span><br><span class="line">- remove()：删除<span class="built_in">list</span>中所有指定值的元素</span><br><span class="line">- remove_if(cmp)：删除条件满足的元素</span><br><span class="line">- erase()：从<span class="built_in">list</span>中删除一个或者几个元素</span><br><span class="line">- clear()</span><br><span class="line">- unique()：删除相邻的重复元素</span><br><span class="line">- reverse()：反转链表</span><br><span class="line">- sort()：对<span class="built_in">list</span>容器中的元素排序</span><br><span class="line">- c1.merge(c2)：合并两个有序的链表并使之有序，重新放到c1中，且释放c2。</span><br><span class="line">- c1.merge(c2,comp)，合并两个有序链表，并使之按照自定义 规则排序之后重新放到c1，且释放c2。</span><br><span class="line">- c1.splice(c1.beg,c2)：将c2连接在c1的beg位置，并释放c2</span><br><span class="line">- begin()</span><br><span class="line">- end()：用于正向迭代，返回<span class="built_in">list</span>中最后一个元素后面的一个位置</span><br><span class="line">- rbegin()</span><br><span class="line">- rend()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + n);</span><br><span class="line">	<span class="comment">//mylist.remove(3);</span></span><br><span class="line">	mylist.remove_if(cmp);</span><br><span class="line">	mylist.unique();</span><br><span class="line">	Disp(mylist);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于STL算法中的排序算法sort()只能用于顺序容器，不能用于list容器，所以list提供了自己的sort成员函数。<br>在使用list.sort()时，默认情况下使用底层元素类型的小于运算符按递增方式排序，如果按递减排序，需使用预定义的类模板greater，它调用底层元素类型的大于运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + <span class="number">6</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">mylist.sort();</span><br><span class="line">Disp(mylist);</span><br><span class="line">mylist.sort(greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">Disp(mylist);</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myClass(<span class="keyword">int</span> m) :n(m)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> myClass &amp;s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (n &gt; s.getn());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Displist</span><span class="params">(<span class="built_in">list</span>&lt;myClass&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;getn();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myClass obj1(3), obj2(5), obj3(2);</span><br><span class="line">	myClass obj4(7), obj5(4), obj6(1),obj7(6);</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt; mylist1, mylist2;</span><br><span class="line">	mylist1.push_back(obj1);</span><br><span class="line">	mylist1.push_back(obj2);</span><br><span class="line">	mylist1.push_back(obj3);</span><br><span class="line">	mylist2.push_back(obj4);</span><br><span class="line">	mylist2.push_back(obj5);</span><br><span class="line">	mylist2.push_back(obj6);</span><br><span class="line">	mylist2.push_back(obj7);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	mylist1.sort();</span><br><span class="line">	mylist2.sort();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1合并到mylist2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	mylist2.merge(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-set（集合容器）-multiset（多重集合容器）"><a href="#4-set（集合容器）-multiset（多重集合容器）" class="headerlink" title="4.set（集合容器）/multiset（多重集合容器）"></a>4.set（集合容器）/multiset（多重集合容器）</h3><p>vector,dque,list均属于顺序容器，这类容器通过元素在容器中的位置来顺序存储和访问元素；而set/multiset、map/multimap属于关联容器，这类容器中的每个元素都有一个key（关键字），通过key来存储和读取元素。关联容器不提供顺序容器中的front()、push_front()、back()、push_back()以及pop_back()操作。<br>set的底层使用一种平衡二叉树（即红黑树）实现，在插入、删除时仅需要操作结点指针即可完成，不涉及内存移动和复制，所以效率比较高。默认情况下会对元素按关键字自动进行升序排列，所以查找速度比较快，同时支持交、差、并等集合运算。由于set中没有相同关键字的元素，在向set中插入元素时，如果已经存在，则不插入。multiset中允许存在两个相同关键字的元素，删除multiset中值等于elem的所有元素，若删除成功，返回删除个数，否则返回0。<br>set/multiset成员函数：</p>
<ul>
<li>max_size()</li>
<li>size()</li>
<li>empty()</li>
<li>insert()</li>
<li>erase()</li>
<li>clear()</li>
<li>count(k)：返回容器中关键字k出现的次数</li>
<li>find(k):如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值</li>
<li>upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素</li>
<li>lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispset</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;myset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myset.begin(); it != myset.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set1, set2, set3;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	set1.insert(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> b[]&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>]);</span><br><span class="line">	set2.insert(b, b + m);</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set1: "</span>;</span><br><span class="line">	Dispset(set1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set2: "</span>;</span><br><span class="line">	Dispset(set2);</span><br><span class="line">	insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; insert_it(set3, set3.begin());</span><br><span class="line">	set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"并集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"交集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"差集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-map（映射容器）-multimap（多重映射容器）"><a href="#5-map（映射容器）-multimap（多重映射容器）" class="headerlink" title="5.map（映射容器）/multimap（多重映射容器）"></a>5.map（映射容器）/multimap（多重映射容器）</h3><p>它们是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。set/multiset中的key和value是key类型的，而map中的key和value是一个pair类结构（二元组）中的两个分量。<br>pair类结构用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较的比较运算符模板函数。例如定义了一个对象p1表示一个平面坐标点并输入坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;p1;<span class="comment">//定义pair对象p1</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p1.first&gt;&gt;p1.second;<span class="comment">//输入p1的坐标</span></span><br></pre></td></tr></table></figure>

<p>map/multimap 中所有key-value对按key的升序排列，以平衡二叉树（红黑树）的形式存储，可以根据key快速找到与之对应的value，利用key类型的&lt;运算符比较大小，对于非内置类型的元素，需要自己定义或者重载&lt;运算符。map中不允许关键字重复出现，存在[ ]运算符；而multimap中允许关键字重复出现，但没有[ ]运算符。<br>map/multimap的主要成员函数：</p>
<ul>
<li>max_size</li>
<li>size()</li>
<li>empty()</li>
<li>map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字则以key为关键字插入一个元素（不适合multimap）。</li>
<li>insert(elem)：插入一个元素elem并返回该元素的位置。</li>
<li>clear()</li>
<li>find()</li>
<li>count()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
</ul>
<p>map中改变元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap; <span class="comment">//定义map对象mymap</span></span><br><span class="line">mymap[<span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">//或者mymap.insert(pair&lt;char,int&gt;('a',1));</span></span><br></pre></td></tr></table></figure>

<p>获得map中一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = mymap[<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispmap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;mymap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mymap.begin(); it != mymap.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;first&lt;&lt;<span class="string">" "</span> &lt;&lt; it-&gt;second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymap;</span><br><span class="line">	mymap.insert(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'a'</span>, <span class="number">1</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">'b'</span>, <span class="number">2</span>));</span><br><span class="line">	mymap[<span class="string">'c'</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap: "</span>;</span><br><span class="line">	Dispmap(mymap);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-stack（栈容器）"><a href="#6-stack（栈容器）" class="headerlink" title="6.stack（栈容器）"></a>6.stack（栈容器）</h3><p>stack、queue和priority_queue都是适配器容器，适配器容器是基于其他某种底层容器实现的。<br>如默认的stack和queue都基于deque容器实现，而priority_queue则在vector容器上实现，也可以指定其他底层容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; myst; <span class="comment">//第二个参数指定底层容器为vector</span></span><br></pre></td></tr></table></figure>

<p>显示指定适配器容器的底层容器时必须满足一定的约束条件，因为适配器容器都根据底层容器来定义自己的操作。如stack关联的底层容器可以是任何一种顺序容器类型，因此stack可以建立在vector、list、deque容器之上（一般用vector和deque实现比list实现的性能好）。queue要求其底层容器必须支持push_front运算，因此只能建立在list和deque容器上，而不能建立在vector容器上。priority_queue要求提供随机访问功能，因此可建立在vector或deque容器上，但不能建立在list容器上。<br>可以看出适配器容器并没有提供与元素保存的保存形式有关的真正的数据结构实现，所以适配器容器不支持迭代器。<br>从一般算法角度看，stack就是一个栈类模板。栈具有先进后出的特点，只有一个出口，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>push()：元素进栈</li>
<li>top()：返回栈顶元素</li>
<li>pop()</li>
</ul>
<h3 id="7-queue（队列容器）"><a href="#7-queue（队列容器）" class="headerlink" title="7.queue（队列容器）"></a>7.queue（队列容器）</h3><p>它是一个队列类模板。先进先出，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>front()：返回队头元素</li>
<li>back()：返回队尾元素</li>
<li>push()：元素进队</li>
<li>pop()</li>
</ul>
<h3 id="8-priority-queue（优先队列容器）"><a href="#8-priority-queue（优先队列容器）" class="headerlink" title="8.priority_queue（优先队列容器）"></a>8.priority_queue（优先队列容器）</h3><p>它是一个优先队列类模板，它是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列中最高优先级的元素。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>top()</li>
<li>push()</li>
<li>pop()<br>优先队列中优先级的高低由队列中数据元素的关系函数（比较运算符）确定，可以使用默认，也可以重载自己编写的关系函数。</li>
</ul>
<p>1.对于C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，值越大优先级越高，可以改为以greater<t>作为关系函数，这样值越大优先级越低。</t></t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//优先队列pq1默认使用vector作为容器</span></span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq2(a, a + n);</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，但需要重载该运算符，也可以自定义相应的关系函数。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Stud(<span class="keyword">int</span> n, <span class="built_in">string</span> na) <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		no = n;</span><br><span class="line">		name = na;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&lt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &lt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&gt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &gt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  结构体的关系函数改写operator()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Studcmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Stud &amp;s1, <span class="keyword">const</span> Stud &amp;s2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s1.name &gt; s2.name;<span class="comment">//name越小优先级越高</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stud a[]&#123; Stud(<span class="number">1</span>,<span class="string">"Marry"</span>),Stud(<span class="number">3</span>,<span class="string">"John"</span>),Stud(<span class="number">2</span>,<span class="string">"Smith"</span>) &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq1.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq1.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud,<span class="built_in">vector</span>&lt;Stud&gt;,greater&lt;Stud&gt;&gt; pq2(a,a+n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq2.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq2.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	priority_queue&lt;Stud, <span class="built_in">vector</span>&lt;Stud&gt;, Studcmp&gt; pq3(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq3: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq3.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq3.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq3.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq3.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-hash-map（哈希表容器）"><a href="#9-hash-map（哈希表容器）" class="headerlink" title="9.hash_map（哈希表容器）"></a>9.hash_map（哈希表容器）</h3><p>它使用hash表的数据结构，插入的元素关键字不允许重复（重复关键字的元素不会被插入）。hash_map 的所有元素都是pair，第 1 个元素为关键字（key），不能修改，第2个元素为值（value），可被修改。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>find(const key_type&amp; k)： 查找指定关键字k的元素</li>
<li>void insert(first,last)</li>
<li>erase(iterator pos)：删除迭代器pos指定位置的元素</li>
<li>erase(const key_type&amp; k)：删除容器中等于关键字k的元素。</li>
<li>clear()：删除容器中的所有元素。</li>
</ul>
<h3 id="10-unordered-map（无序哈希表容器）"><a href="#10-unordered-map（无序哈希表容器）" class="headerlink" title="10.unordered_map（无序哈希表容器）"></a>10.unordered_map（无序哈希表容器）</h3><p>unordered_map 也是一个哈希表容器，属于C++11特性。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>hash_function()：获取存储的哈希函数对象</li>
<li>operator[]：查找与指定关键字匹配的元素。当成功时返回对应元素的迭代器指针。</li>
<li>count()</li>
<li>insert()</li>
<li>erase()</li>
<li>begin()</li>
<li>end()</li>
</ul>
<h3 id="map、hash-map、unordered-map"><a href="#map、hash-map、unordered-map" class="headerlink" title="map、hash_map、unordered_map"></a>map、hash_map、unordered_map</h3><p>1.一般情况下，unordered_map 比hash_map插入、删除操作的速度更快，查找效率相近。<br>2.map、unordered_map用法类似，只是map中的元素是有序存储的，而unordered_map无序存储，它的查找速度更快，但是占用的内存空间也更大。<br>3.非频繁的查询或者考虑有序性时采用map比较稳定；频繁查询或者不需要考虑有序性时采用unordered_map更好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/林轩田-基石-Lecture1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/林轩田-基石-Lecture1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>学习是指通过观察积累经验来获取技能。<br>即 观察-&gt;学习-&gt;技能</p>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>机器学习是指机器从数据中通过积累、计算获得技能。</p>
<h4 id="技能statistics-many-useful-tools-for-ML"><a href="#技能statistics-many-useful-tools-for-ML" class="headerlink" title="技能statistics : many useful tools for ML"></a>技能statistics : many useful tools for ML</h4><p>技能：使得某项指标得到提升的能力。</p>
<h4 id="什么时候使用机器学习？"><a href="#什么时候使用机器学习？" class="headerlink" title="什么时候使用机器学习？"></a>什么时候使用机器学习？</h4><p>例子：定义一棵树。对于大家来说，看到一棵树一定能认出来它是一棵树，为什么？因为我们见过太多的树，并且掌握了树的特征，有枝干，有叶子，叶子通常是绿色的……，但是如果通过特定的规则去定义什么是树就比较难了，而这个时候使用机器学习来判断是不是一棵树就相对简单。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>无法人工编程的系统（如在火星上导航）</li>
<li>无法清晰地定义解决方案（语音，图像辨识）</li>
<li>需要快速响应，而人类无法达到的时候</li>
<li>面向大规模用户（如根据个人喜好来做推荐的系统）</li>
</ul>
<h4 id="机器学习的关键要素"><a href="#机器学习的关键要素" class="headerlink" title="机器学习的关键要素"></a>机器学习的关键要素</h4><ol>
<li>存在可学习的潜在模式，所以某个”表现指标“可以得到提升。</li>
<li>但是没有简单的编码定义</li>
<li>大量数据</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>unknow pattern to be learned &lt;=&gt; target function<br>hypothesis &lt;=&gt; skill</p>
<p>假设空间里包含的假设有好有坏（相对于目标函数），由算法来挑选最好的假设。<br><code>learning model = A and H</code></p>
<h4 id="机器学习进一步定义"><a href="#机器学习进一步定义" class="headerlink" title="机器学习进一步定义"></a>机器学习进一步定义</h4><p>机器学习：使用数据来计算与目标f最接近的假设g<br>即 数据-&gt;（A on H）-&gt; g: x-&gt;y<br>A 为算法，H 为假设空间，g 为假设空间中的某一假设</p>
<h4 id="数据挖掘（Data-Mining）"><a href="#数据挖掘（Data-Mining）" class="headerlink" title="数据挖掘（Data Mining）"></a>数据挖掘（Data Mining）</h4><p>use (huge) data to find property that is interesting</p>
<ul>
<li><p>如果”有趣的信息“与”接近目标的假设“一样，则DM=ML。</p>
</li>
<li><p>如果”有趣的信息“与”接近目标的假设“相关，则DM可以帮助ML，反之亦然。</p>
</li>
<li><p>传统的DM还关注在大规模数据集（库）进行有效计算，实际中ML、DM密不可分，很难区分。</p>
</li>
</ul>
<h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><p>compute something that shows intelligent behavior</p>
<p>g ~= f is something that shows intelligent behavior</p>
<p>ML can realize AI,among other routes<br>即ML是实现AI的一种方法</p>
<h4 id="Statistics-统计"><a href="#Statistics-统计" class="headerlink" title="Statistics 统计"></a>Statistics 统计</h4><p>use data to make inference about an unknown process<br>使用数据来做推论<br>g is an inference outcome; f is a something unknown —- statistics can be used to achieve ML</p>
<p>f 未知，可以将 g 当作推论，故统计可以用来实现机器学习</p>
<p>traditional statistics also focus on provable results with math assumptions,and less about computation</p>
<p>传统统计学也关注数学假设的可证明结果，而不是计算</p>
<p>statistics : many useful tools for ML</p>
<h4 id="Components-of-Machine-Learning"><a href="#Components-of-Machine-Learning" class="headerlink" title="Components of Machine Learning"></a>Components of Machine Learning</h4><p>A takes D and H to get g.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/小球回弹/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/小球回弹/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="小球回弹"><a href="#小球回弹" class="headerlink" title="小球回弹"></a>小球回弹</h3><p>小球回弹，“弹跳性”系数为0.6，根据用户的输入高度和回弹次数来输出小球运动的总距离。<br>思路：<br>若小球没有回弹，则小球运动的总距离即为初始高度。有回弹的话，小球每次回弹以后，高度变为上一次高度与“弹跳性”系数的乘积，小球每次回弹运动的距离为当前高度与回弹高度的和。<br>待改进：<br>首先即想到了递归，但是想不明白，日后再改！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def ball(height, num):</span><br><span class="line">    # backDis = height * 0.6</span><br><span class="line">    # totalDis = height + backDis</span><br><span class="line">    totalDis = 0</span><br><span class="line">    if num == 0:</span><br><span class="line">        return height</span><br><span class="line">    else:</span><br><span class="line">        for i in range(1, num+1):</span><br><span class="line">            backDis = height * 0.6</span><br><span class="line">            thisDis = height + backDis</span><br><span class="line">            height = backDis</span><br><span class="line">            totalDis += thisDis</span><br><span class="line"></span><br><span class="line">    return totalDis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    height = int(input(&quot;请输入高度：&quot;))</span><br><span class="line">    num = int(input(&quot;请输入回弹次数：&quot;))</span><br><span class="line">    print(ball(height, num))</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Keras FAQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Keras FAQ/" itemprop="url">Keras FAQ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="What-does-“sample”-“batch”-“epoch”-mean"><a href="#What-does-“sample”-“batch”-“epoch”-mean" class="headerlink" title="What does “sample”, “batch”, “epoch” mean?"></a>What does “sample”, “batch”, “epoch” mean?</h3><ul>
<li><h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h4><ul>
<li>样本，数据集中的一个元素，一条数据</li>
<li>例1：在卷积神经网络中，一张图片是一个样本</li>
<li>例2：在语音识别模型中，一段音频是一个样本</li>
</ul>
</li>
<li><h4 id="Batch："><a href="#Batch：" class="headerlink" title="Batch："></a>Batch：</h4><ul>
<li>批，含有N个样本的结合。批中每个样本都是独立并行处理的。训练期间，一个batch的结果只会用来更新一次模型。</li>
<li>一个<strong>batch</strong>的样本通常比单个输入更接近于总体输入数据的分布，batch越大就越近似。但是，使用batch将花费更长的时间来处理，并且仍然只更新模型一次。在推理时（evaluate/predict），建议在条件允许的情况下选择一个尽可能大的batch，（因为较大的batch通常评估/预测的速度会更快）。</li>
</ul>
</li>
<li><h4 id="Epoch："><a href="#Epoch：" class="headerlink" title="Epoch："></a>Epoch：</h4><ul>
<li>轮次，通常定义为“在整个数据集上的一轮迭代”，用于训练的不同阶段，有利于记录和定期评估。</li>
<li>当在Keras模型的<code>fit</code>方法中使用 <code>validation_data</code>或<code>validation_split</code>时，评估将在每个epoch结束时运行。</li>
<li>在Keras中，可以添加专门的用于在epoch结束时运行的<font color="#FF0000"> callbacks 回调</font>。例如学习率变化和模型检查点（保存）。</li>
</ul>
</li>
</ul>
<h3 id="How-can-I-save-a-Keras-model-（如何保存Keras模型？）"><a href="#How-can-I-save-a-Keras-model-（如何保存Keras模型？）" class="headerlink" title="How can I save a Keras model?（如何保存Keras模型？）"></a>How can I save a Keras model?（如何保存Keras模型？）</h3><h4 id="保存-加载整个模型（结构-权重-优化器状态）"><a href="#保存-加载整个模型（结构-权重-优化器状态）" class="headerlink" title="保存/加载整个模型（结构+权重+优化器状态）"></a>保存/加载整个模型（结构+权重+优化器状态）</h4><p><em>不推荐使用pickle或者cPickle来保存Keras模型。</em></p>
<p>可以使用<code>model.save(filepath)</code>将Keras模型保存到单个HDF5文件中，该文件将包含：</p>
<ul>
<li>模型的结构，允许重新创建模型</li>
<li>模型的权重</li>
<li>训练配置项（损失函数，优化器）</li>
<li>优化器状态，允许准确地从你上次结束的地方继续训练。</li>
</ul>
<p>可以使用<code>keras.model.load_model(filepath)</code>重新实例化模型。<code>load_model</code>还将负责使用保存的训练配置项来编译模型（除非模型从未编译过）。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import load_model</span><br><span class="line">model.save(&quot;my_model.h5&apos;) # creates a HDF5 file &apos;my_model.h5&apos;</span><br><span class="line">del model # deletes the existing model</span><br><span class="line"></span><br><span class="line"># returns a compiled model</span><br><span class="line"># identical to the previous one</span><br><span class="line">model = load_model(&apos;my_model.h5&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="只保存-加载模型的结构"><a href="#只保存-加载模型的结构" class="headerlink" title="只保存/加载模型的结构"></a>只保存/加载模型的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># save as JSON</span><br><span class="line">json_string = model.to_json()</span><br><span class="line"></span><br><span class="line"># save as YAML</span><br><span class="line">yaml_string = model.to_yaml()</span><br></pre></td></tr></table></figure>

<p>生成的JSON/YAML文件是人类可读的，且可根据需要手动进行修改。</p>
<p>可从这些数据建立一个新模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># model reconstruction from JSON:</span><br><span class="line">from keras.models import model_from_json</span><br><span class="line">model = model_from_json(json_string)</span><br><span class="line"></span><br><span class="line"># model reconstruction from YAML:</span><br><span class="line">from keras.models import model_from_yaml</span><br><span class="line">model = mode_from_yaml(yaml_string)</span><br></pre></td></tr></table></figure>

<h4 id="只保存-加载模型的权重"><a href="#只保存-加载模型的权重" class="headerlink" title="只保存/加载模型的权重"></a>只保存/加载模型的权重</h4><p><code>model.save_weights(&#39;my_model_weights.h5)</code><br>假设你有用于实例化模型的代码，则可以将保存的权重加载到具有相同结构的模型中。<br><code>model.load_weights(&#39;my_model_weights.h5&#39;)</code><br>如果你需要将权重加载到不同的结构（有一些共同层）的模型中，例如微调或迁移学习，则可以按层的名字来加载权重：<br><code>model.load_weights(&#39;my_model_weights.h5,by_name=True)</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Assuming the original model looks like this:</span><br><span class="line">    model = Sequential()</span><br><span class="line">    model.add(Dense(2,input_dim=3,name=&apos;dense_1&apos;))</span><br><span class="line">    model.add(Dense(3,name=&apos;dense_2&apos;))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># new model</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(2,input_dim=3,name=&apos;dense_1&apos;)) # will be loaded</span><br><span class="line">model.add(Dense(10,name=&apos;new_dense&apos;)) # will not be loaded</span><br><span class="line"></span><br><span class="line"># load weights from first model; will only affect the first layer,dense_1.</span><br><span class="line">model.load_weights(fname,by_name=True)</span><br></pre></td></tr></table></figure>

<h4 id="操作已保存的模型中的自定义层（或其他自定义对象）"><a href="#操作已保存的模型中的自定义层（或其他自定义对象）" class="headerlink" title="操作已保存的模型中的自定义层（或其他自定义对象）"></a>操作已保存的模型中的自定义层（或其他自定义对象）</h4><p>如果要加载的模型中包含自定义层或其他自定义类或函数，则可以通过<code>custom_object</code>参数将它们传递给加载机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import load_model</span><br><span class="line"># Assuming your model includes instance of an &quot;AttentionLayer&quot; class</span><br><span class="line">model = load_model(&apos;my_model.h5&apos;,custom_objects=&#123;&apos;AttenstionLayer`:AttentionLayer&#125;));</span><br></pre></td></tr></table></figure>

<p>或者可以使用<font color="red">自定义对象作用域：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from kreas.utils import CustomObjectScope</span><br><span class="line">with CustomObjectScope(&#123;&apos;AttentionLayer&apos;:AttentionLayer&#125;):</span><br><span class="line">    model = load_model(&apos;my_model.h5&apos;)</span><br></pre></td></tr></table></figure>

<p>自定义对象的处理与<code>load_model</code>,<code>model_from_json</code>,<code>model_from_yaml</code>的工作方式相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import model_from_json</span><br><span class="line">model = model_from_json(json_string,custom_objects=&#123;&apos;AttentionLayer&apos;:AttentionLayer&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Why-is-the-training-loss-much-higher-than-the-testing-loss-为什么训练误差比测试误差高很多？"><a href="#Why-is-the-training-loss-much-higher-than-the-testing-loss-为什么训练误差比测试误差高很多？" class="headerlink" title="Why is the training loss much higher than the testing loss?(为什么训练误差比测试误差高很多？)"></a>Why is the training loss much higher than the testing loss?(为什么训练误差比测试误差高很多？)</h3><p>Keras模型有训练和测试两种模式。正则化机制，如 Dropout 和 L1/L2 权重正则化，在测试时是关闭的。<br>此外，训练损失是每批训练数据的平均损失。因为模型是随着时间变化的，所以一个epoch中的第一批数据的损失通常比最后一批的损失要高。测试误差是模型在一个epoch训练完成后计算的，因而误差较小。</p>
<h3 id="How-can-I-obtain-the-output-of-an-intermediate-layer-如何获取中间层的输出？"><a href="#How-can-I-obtain-the-output-of-an-intermediate-layer-如何获取中间层的输出？" class="headerlink" title="How can I obtain the output of an intermediate layer?(如何获取中间层的输出？)"></a>How can I obtain the output of an intermediate layer?(如何获取中间层的输出？)</h3><p>一种简单的方法是创建一个新的<code>Model</code>（模型）来输出感兴趣的层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Model</span><br><span class="line">model = ... # create the original model</span><br><span class="line">layer_name = &apos;my_layer&apos;</span><br><span class="line">intermediate_layer_model = Model(inputs=model.input,</span><br><span class="line">                                 output=model.get_layer(layer_name).output)</span><br><span class="line">intermediate_output=intermediate_layer_model.predict(data)</span><br></pre></td></tr></table></figure>

<p>或者创建一个Keras函数，该函数在给定输入的情况下返回某个层的输出，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from keras import backend as K</span><br><span class="line"></span><br><span class="line"># with a Sequential model</span><br><span class="line">get_3rd_layer_output = K.function([model.layers[0].input],</span><br><span class="line">                                  [model.layers[3].output])</span><br><span class="line">layer_output = get_3rd_layer_output([x])[0]</span><br></pre></td></tr></table></figure>

<p>或者，可以直接建立一个Theano或TensorFlow函数。<br>注意，如果你的模型在训练和测试阶段有不同的行为（例如，使用 <code>Dropout</code>, <code>BatchNormalization</code> 等），则需要将学习阶段标志传递给你的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_3rd_layer_output = K.function([model.layers[0].input, K.learning_phase()],</span><br><span class="line">                                  [model.layers[3].output])</span><br><span class="line"># output in test mode = 0  测试模式 = 0 时的输出</span><br><span class="line">layer_output = get_3rd_layer_output([x,0])[0]</span><br><span class="line"></span><br><span class="line"># output in train mode = 1</span><br><span class="line">layer_output = get_3rd_layer_output([x,1])[0]</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-Keras-with-datasets-that-don’t-fit-in-memory-（如何用-Keras-处理超过内存的数据集？）"><a href="#How-can-I-use-Keras-with-datasets-that-don’t-fit-in-memory-（如何用-Keras-处理超过内存的数据集？）" class="headerlink" title="How can I use Keras with datasets that don’t fit in memory? （如何用 Keras 处理超过内存的数据集？）"></a>How can I use Keras with datasets that don’t fit in memory? （如何用 Keras 处理超过内存的数据集？）</h3><p>可以使用 <code>model.train_on_batch(x，y)</code> 和 <code>model.test_on_batch(x，y)</code> 进行批量训练与测试。</p>
<p>或者，你可以编写一个生成批处理训练数据的生成器，然后使用 <code>model.fit_generator(data_generator，steps_per_epoch，epochs)</code> 方法。</p>
<h3 id="How-can-I-interrupt-training-when-the-validation-loss-isn’t-decreasing-anymore-在验证集的误差不再下降时，如何中断训练？"><a href="#How-can-I-interrupt-training-when-the-validation-loss-isn’t-decreasing-anymore-在验证集的误差不再下降时，如何中断训练？" class="headerlink" title="How can I interrupt training when the validation loss isn’t decreasing anymore? 在验证集的误差不再下降时，如何中断训练？"></a>How can I interrupt training when the validation loss isn’t decreasing anymore? 在验证集的误差不再下降时，如何中断训练？</h3><p>可以使用<code>EarlyStopping</code>回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.callbacks import EarlyStopping</span><br><span class="line">early_stopping = EarlyStopping(monitor=&apos;val_loss&apos;,patience=2)</span><br><span class="line">model.fit(x,y,validation_split=0.2,callbacks=[early_stopping])</span><br></pre></td></tr></table></figure>

<h3 id="How-is-the-validation-split-computed-验证集划分是如何计算的？"><a href="#How-is-the-validation-split-computed-验证集划分是如何计算的？" class="headerlink" title="How is the validation split computed?(验证集划分是如何计算的？)"></a>How is the validation split computed?(验证集划分是如何计算的？)</h3><p>如果您将 <code>model.fit</code> 中的 <code>validation_split</code> 参数设置为 0.1，那么使用的验证数据将是最后 10％ 的数据。如果设置为 0.25，就是最后 25% 的数据。注意，在提取分割验证集之前，数据不会被混洗，因此验证集仅仅是传递的输入中最后一个 x％ 的样本。</p>
<p>所有 epoch 都使用相同的验证集（在同一个 <code>fit</code> 中调用）。</p>
<h3 id="Is-the-data-shuffled-during-training-在训练过程中数据是否会混洗？"><a href="#Is-the-data-shuffled-during-training-在训练过程中数据是否会混洗？" class="headerlink" title="Is the data shuffled during training? (在训练过程中数据是否会混洗？)"></a>Is the data shuffled during training? (在训练过程中数据是否会混洗？)</h3><p>是的，如果 <code>model.fit</code>中的 <code>shuffle</code>参数设置为 <code>True</code>（默认值），则训练数据将在每个 epoch 混洗。<br>验证集永远不会混洗。</p>
<h3 id="How-can-I-record-the-training-validation-loss-accuracy-at-each-epoch-如何在每个-epoch-后记录训练集和验证集的误差和准确率？"><a href="#How-can-I-record-the-training-validation-loss-accuracy-at-each-epoch-如何在每个-epoch-后记录训练集和验证集的误差和准确率？" class="headerlink" title="How can I record the training / validation loss / accuracy at each epoch?(如何在每个 epoch 后记录训练集和验证集的误差和准确率？)"></a>How can I record the training / validation loss / accuracy at each epoch?(如何在每个 epoch 后记录训练集和验证集的误差和准确率？)</h3><p><code>model.fit</code> 方法返回一个 <code>History</code> 回调，它具有包含连续误差的列表和其他度量的 <code>history</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hist = model.fit(x,y,validation_split=0.2)</span><br><span class="line">print(hist.history)</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-“freeze”-Keras-layers-如何「冻结」网络层？"><a href="#How-can-I-“freeze”-Keras-layers-如何「冻结」网络层？" class="headerlink" title="How can I “freeze” Keras layers? (如何「冻结」网络层？)"></a>How can I “freeze” Keras layers? (如何「冻结」网络层？)</h3><p>「冻结」一个层意味着将其排除在训练之外，即其权重将永远不会更新。这在微调模型或使用固定的词向量进行文本输入中很有用。<br>您可以将 <code>trainable</code> 参数（布尔值）传递给一个层的构造器，以将该层设置为不可训练的：</p>
<p><code>frozen_layer = Dense(32,trainable=False)</code></p>
<p>另外，可以在实例化之后将网络层的 <code>trainable</code> 属性设置为 <code>True</code> 或 <code>False</code>。为了使之生效，在修改 <code>trainable</code> 属性之后，需要在模型上调用 <code>compile()</code>。这是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = Input(shape=(32,))</span><br><span class="line">layer = Dense(32)</span><br><span class="line">layer.trainable = Flase</span><br><span class="line">y = layer(x)</span><br><span class="line"></span><br><span class="line">frozen_model = Model(x,y)</span><br><span class="line"># 在下面的模型中，训练期间不会更新层的权重</span><br><span class="line">frozen_model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;mse&apos;)</span><br><span class="line"></span><br><span class="line">layer.trainable = True</span><br><span class="line">trainable_model = Model(x,y)</span><br><span class="line"># 使用这个模型，训练期间 `layer` 的权重将被更新</span><br><span class="line"># (这也会影响上面的模型，因为它使用了同一个网络层实例)</span><br><span class="line">trainable_model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;mse&apos;)</span><br><span class="line"></span><br><span class="line">frozen_model.fit(data,labels)  # 这不会更新 `layer` 的权重</span><br><span class="line">trainable_model.fit(data,labels) # 这会更新 &apos;layer&apos; 的权重</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-stateful-RNNs-如何使用有状态-RNN-stateful-RNNs"><a href="#How-can-I-use-stateful-RNNs-如何使用有状态-RNN-stateful-RNNs" class="headerlink" title="How can I use stateful RNNs? (如何使用有状态 RNN (stateful RNNs)?)"></a>How can I use stateful RNNs? (如何使用有状态 RNN (stateful RNNs)?)</h3><p>使 RNN 具有状态意味着每批样本的状态将被重新用作下一批样本的初始状态。<br>当使用有状态 RNN 时，假定：</p>
<ul>
<li>所有的批次都有相同数量的样本</li>
<li>如果 <code>x1</code> 和 <code>x2</code> 是连续批次的样本，则 <code>x2[i]</code> 是 <code>x1[i]</code> 的后续序列，对于每个 <code>i</code>。</li>
</ul>
<p>要在 RNN 中使用状态，你需要:</p>
<ul>
<li>通过将 <code>batch_size</code> 参数传递给模型的第一层来显式指定你正在使用的批大小。例如，对于 10 个时间步长的 32 样本的 batch，每个时间步长具有 16 个特征，<code>batch_size = 32</code>。</li>
<li>在 RNN 层中设置 <code>stateful = True</code>。</li>
<li>在调用 <code>fit()</code> 时指定 <code>shuffle = False</code>。</li>
</ul>
<p>重置累积状态：</p>
<ul>
<li>使用 <code>model.reset_states()</code> 来重置模型中所有层的状态</li>
<li>使用 <code>layer.reset_states()</code> 来重置指定有状态 RNN 层的状态</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x # 输入数据，(32,21,16)</span><br><span class="line"># 将步长为10的序列输入到模型中</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(32,input_shape=(10,16),batch_size=32,stateful=True))</span><br><span class="line">model.add(Dense(16,activation=&apos;softmax&apos;))</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;categorical_crossentropy&apos;)</span><br><span class="line"></span><br><span class="line"># 训练网络，根据给定的前 10 个时间步，来预测第 11 个时间步：</span><br><span class="line">model.train_on_batch(x[:,:10,:],np.reshape(x[:,10,:],(32,16)))</span><br><span class="line"></span><br><span class="line"># 网络的状态已经改变。我们可以提供后续序列：</span><br><span class="line">model.train_on_batch(x[:, 10:20, :], np.reshape(x[:, 20, :], (32, 16)))</span><br><span class="line"></span><br><span class="line"># 重置 LSTM 层的状态：</span><br><span class="line">model.reset_states()</span><br><span class="line"></span><br><span class="line"># 另一种重置方法：</span><br><span class="line">model.layers[0].reset_states()</span><br></pre></td></tr></table></figure>

<p>请注意，<code>predict</code>, <code>fit</code>, <code>train_on_batch</code>, <code>predict_classes</code> 等方法全部都会更新模型中有状态层的状态。这使你不仅可以进行有状态的训练，还可以进行有状态的预测。</p>
<h3 id="How-can-I-remove-a-layer-from-a-Sequential-model-如何从-Sequential-模型中移除一个层？"><a href="#How-can-I-remove-a-layer-from-a-Sequential-model-如何从-Sequential-模型中移除一个层？" class="headerlink" title="How can I remove a layer from a Sequential model? (如何从 Sequential 模型中移除一个层？)"></a>How can I remove a layer from a Sequential model? (如何从 Sequential 模型中移除一个层？)</h3><p>可以通过调用<code>.pop()</code>来删除 <code>Sequential</code>模型中最后添加的层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(32,activation=&apos;relu&apos;,input_dim=784))</span><br><span class="line">model.add(Dense(32,activation=&apos;relu&apos;))</span><br><span class="line">print(len(model.layers)) # &quot;2&quot;</span><br><span class="line"></span><br><span class="line">model.pop()</span><br><span class="line">print(len(model.layers)) #&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-pre-trained-models-in-Keras-如何在-Keras-中使用预训练的模型？"><a href="#How-can-I-use-pre-trained-models-in-Keras-如何在-Keras-中使用预训练的模型？" class="headerlink" title="How can I use pre-trained models in Keras? (如何在 Keras 中使用预训练的模型？)"></a>How can I use pre-trained models in Keras? (如何在 Keras 中使用预训练的模型？)</h3><p>Keras提供了以下图像分类模型的代码和预训练的权重：</p>
<ul>
<li>Xception</li>
<li>VGG16</li>
<li>VGG19</li>
<li>ResNet50</li>
<li>Inception v3</li>
<li>Inception-ResNet v2</li>
<li>MobileNet v1</li>
<li>DenseNet</li>
<li>NASNet</li>
<li>MobileNet v2<br>可以使用<code>keras.applications</code>将它们导入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from keras.applications.xception import Xception</span><br><span class="line">from keras.applications.vgg16 import VGG16</span><br><span class="line">from keras.applications.vgg19 import VGG19</span><br><span class="line">from keras.applications.resnet import ResNet50</span><br><span class="line">from keras.applications.resnet import ResNet101</span><br><span class="line">from keras.applications.resnet import ResNet152</span><br><span class="line">from keras.applications.resnet_v2 import ResNet50V2</span><br><span class="line">from keras.applications.resnet_v2 import ResNet101V2</span><br><span class="line">from keras.applications.resnet_v2 import ResNet152V2</span><br><span class="line">from keras.applications.resnext import ResNeXt50</span><br><span class="line">from keras.applications.resnext import ResNeXt101</span><br><span class="line">from keras.applications.inception_v3 import InceptionV3</span><br><span class="line">from keras.applications.inception_resnet_v2 import InceptionResNetV2</span><br><span class="line">from keras.applications.mobilenet import MobileNet</span><br><span class="line">from keras.applications.mobilenet_v2 import MobileNetV2</span><br><span class="line">from keras.applications.densenet import DenseNet121</span><br><span class="line">from keras.applications.densenet import DenseNet169</span><br><span class="line">from keras.applications.densenet import DenseNet201</span><br><span class="line">from keras.applications.nasnet import NASNetLarge</span><br><span class="line">from keras.applications.nasnet import NASNetMobile</span><br><span class="line"></span><br><span class="line">model = VGG16(weights=&apos;imagenet&apos;, include_top=True)</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-HDF5-inputs-with-Keras-如何在-Keras-中使用-HDF5-输入？"><a href="#How-can-I-use-HDF5-inputs-with-Keras-如何在-Keras-中使用-HDF5-输入？" class="headerlink" title="How can I use HDF5 inputs with Keras? (如何在 Keras 中使用 HDF5 输入？)"></a>How can I use HDF5 inputs with Keras? (如何在 Keras 中使用 HDF5 输入？)</h3><p>可以使用 <code>keras.utils.io_utils</code> 中的<code>HDF5Matrix</code> 类。有关详细信息，请参阅 HDF5Matrix文档。<br>也可以直接使用 HDF5 数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import h5py</span><br><span class="line">with h5py.File(&apos;input/file.hdf5&apos;,&apos;r&apos;) as f:</span><br><span class="line">      x_data = f[&apos;x_data&apos;]</span><br><span class="line">      model.predict(x_data)</span><br></pre></td></tr></table></figure>

<h3 id="Where-is-the-Keras-configuration-file-stored-Keras-配置文件保存在哪里？"><a href="#Where-is-the-Keras-configuration-file-stored-Keras-配置文件保存在哪里？" class="headerlink" title="Where is the Keras configuration file stored? (Keras 配置文件保存在哪里？)"></a>Where is the Keras configuration file stored? (Keras 配置文件保存在哪里？)</h3><p>所有 Keras 数据存储的默认目录是：<br><code>$HOME/.keras/</code><br>注意，Windows 用户应该将 <code>$HOME</code> 替换为<code>%USERPROFILE%</code>。如果 Keras 无法创建上述目录（例如，由于权限问题），则使用<code>/tmp/.keras/</code>作为备份。<br>Keras配置文件是存储在 <code>$HOME/.keras/keras.json</code> 中的 JSON 文件。默认的配置文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;image_data_format&quot;: &quot;channels_last&quot;,</span><br><span class="line">    &quot;epsilon&quot;: 1e-07,</span><br><span class="line">    &quot;floatx&quot;: &quot;float32&quot;,</span><br><span class="line">    &quot;backend&quot;: &quot;tensorflow&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它包含以下字段：</p>
<p>图像处理层和实用程序所使用的默认值图像数据格式（<code>channels_last</code> 或 <code>channels_first</code>）。<br>用于防止在某些操作中被零除的 <code>epsilon</code> 模糊因子。<br>默认浮点数据类型。<br>默认后端。详见 backend 文档。<br>同样，缓存的数据集文件（如使用 <code>get_file()</code>下载的文件）默认存储在<code>$HOME/.keras/datasets/</code> 中。</p>
<h3 id="How-can-I-obtain-reproducible-results-using-Keras-during-development-如何在-Keras-开发过程中获取可复现的结果？"><a href="#How-can-I-obtain-reproducible-results-using-Keras-during-development-如何在-Keras-开发过程中获取可复现的结果？" class="headerlink" title="How can I obtain reproducible results using Keras during development? (如何在 Keras 开发过程中获取可复现的结果？)"></a>How can I obtain reproducible results using Keras during development? (如何在 Keras 开发过程中获取可复现的结果？)</h3><p>在模型的开发过程中，能够在一次次的运行中获得可复现的结果，以确定性能的变化是来自模型还是数据集的变化，或者仅仅是一些新的随机样本点带来的结果，有时候是很有用处的。</p>
<p>首先，你需要在程序启动之前将 <code>PYTHONHASHSEED</code> 环境变量设置为 0（不在程序本身内）。对于 Python 3.2.3 以上版本，它对于某些基于散列的操作具有可重现的行为是必要的（例如，集合和字典的 item 顺序，请参阅 Python 文档和 issue #2280 获取更多详细信息）。设置环境变量的一种方法是，在这样启动 python 时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat test_hash.py</span><br><span class="line">print(hash(&quot;keras&quot;))</span><br><span class="line">$ python3 test_hash.py                  # 无法复现的 hash (Python 3.2.3+)</span><br><span class="line">-8127205062320133199</span><br><span class="line">$ python3 test_hash.py                  # 无法复现的 hash (Python 3.2.3+)</span><br><span class="line">3204480642156461591</span><br><span class="line">$ PYTHONHASHSEED=0 python3 test_hash.py # 可复现的 hash</span><br><span class="line">4883664951434749476</span><br><span class="line">$ PYTHONHASHSEED=0 python3 test_hash.py # 可复现的 hash</span><br><span class="line">4883664951434749476</span><br></pre></td></tr></table></figure>

<p>此外，当使用 TensorFlow 后端并在 GPU 上运行时，某些操作具有非确定性输出，特别是<code>tf.reduce_sum()</code>。这是因为 GPU 并行运行许多操作，因此并不总能保证执行顺序。由于浮点数的精度有限，即使添加几个数字，也可能会产生略有不同的结果，具体取决于添加它们的顺序。你可以尝试避免某些非确定性操作，但有些操作可能是由 TensorFlow 在计算梯度时自动创建的，因此在 CPU 上运行代码要简单得多。为此，你可以将<code>CUDA_VISIBLE_DEVICES</code>环境变量设置为空字符串，例如：<br><code>$ CUDA_VISIBLE_DEVICES=&quot;&quot; PYTHONHASHSEED=0 python your_program.py</code></p>
<p>下面的代码片段提供了一个如何获得可复现结果的例子 - 针对 Python 3 环境的 TensorFlow 后端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import random as rn</span><br><span class="line"># 以下是 Numpy 在一个明确的初始状态生成固定随机数字所必需的。</span><br><span class="line">np.random.seed(42)</span><br><span class="line"># 强制 TensorFlow 使用单线程。</span><br><span class="line"># 多线程是结果不可复现的一个潜在因素。</span><br><span class="line"># 更多详情，见: https://stackoverflow.com/questions/42022950/</span><br><span class="line">session_conf = tf.ConfigProto(intra_op_parallelism_threads=1,</span><br><span class="line">                                              inter_op_parallelism_threads=1)</span><br><span class="line">from keras import backend as K</span><br><span class="line"># `tf.set_random_seed()` 将会以 TensorFlow 为后端，</span><br><span class="line"># 在一个明确的初始状态下生成固定随机数字。</span><br><span class="line"># 更多详情，见: https://www.tensorflow.org/api_docs/python/tf/set_random_seed</span><br><span class="line">tf.set_random_seed(1234)</span><br><span class="line">sess = tf.Session(graph=tf.get_default_graph(),config=session_conf)</span><br><span class="line">K.set_session(sess)</span><br><span class="line"># Rest of code follows ...</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-install-HDF5-or-h5py-to-save-my-models-in-Keras-如何在-Keras-中安装-HDF5-或-h5py-来保存我的模型？"><a href="#How-can-I-install-HDF5-or-h5py-to-save-my-models-in-Keras-如何在-Keras-中安装-HDF5-或-h5py-来保存我的模型？" class="headerlink" title="How can I install HDF5 or h5py to save my models in Keras? (如何在 Keras 中安装 HDF5 或 h5py 来保存我的模型？)"></a>How can I install HDF5 or h5py to save my models in Keras? (如何在 Keras 中安装 HDF5 或 h5py 来保存我的模型？)</h3><p>为了将你的 Keras 模型保存为 HDF5 文件，例如通过<code>keras.callbacks.ModelCheckpoint</code>，Keras 使用了 h5py Python 包。h5py 是 Keras 的依赖项，应默认被安装。在基于 Debian 的发行版本上，你需要再额外安装 <code>libhdf5</code>：</p>
<p><code>sudo apt-get install libhdf5-serial-dev</code><br>如果你不确定是否安装了 h5py，则可以打开 Python shell 并通过下面的命令加载模块<br><code>import h5py</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Python数据结构第一章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Python数据结构第一章/" itemprop="url">Python 数据结构第一章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="编写新的函数"><a href="#编写新的函数" class="headerlink" title="编写新的函数"></a>编写新的函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数头下方使用带有”””的字符串，这是一个文档字符串（docstring）。就像是函数中的注释，用户输入help(函数名)的时候，将显示这个字符串。<br>当一个函数不包含return语句时，它在执行完最后一条语句时，会自动地返回一个None值。<br>在模块中，可以按照任意顺序来定义函数，只要函数在被编译之前，不会真正地去执行函数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first() # Raises a NameError(function undefined yet)</span><br><span class="line"></span><br><span class="line">def first():</span><br><span class="line">      second()  # Not an error, because not actually</span><br><span class="line">def second():</span><br><span class="line">      print(&quot;Calling second.&quot;)</span><br><span class="line">first() # Here is where the call should go.</span><br></pre></td></tr></table></figure>

<p>这个例子中，second函数似乎在定义它之前就调用了，但实际上知道调用函数first的时候，才真正调用了second，而这个时候，这两个函数都定义过了。<br>可以使用<parameter name> = <default value>的形式，带上为参数指定的默认值，从而将参数指定为可选的。在参数列表中，必需的参数（不带默认值的参数）必须要放在可选的参数之前。</default></parameter></p>
<h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><p>递归函数必须至少包含一条选择语句。这条语句检查base case，来判断是停止还是继续递归。<br>迭代算法转换为一个递归函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def displayRange(lower,upper):</span><br><span class="line">      &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;</span><br><span class="line">      while lower &lt;= upper:</span><br><span class="line">              print(lower)</span><br><span class="line">              lower = lower + 1</span><br></pre></td></tr></table></figure>

<p>如何转换？注意两点：</p>
<ul>
<li>当 lower  &lt;= upper 的时候，循环体继续执行：</li>
<li>当函数执行的时候，lower增加1，但是upper不变。<br>  等价的递归函数可以执行类似的基本操作，但是，用一条if语句替代了循环，用函数的递归替代了复制语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def displayRange(lower,upper):</span><br><span class="line">    &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;</span><br><span class="line">    if lower &lt;= upper:</span><br><span class="line">        print(lower)</span><br><span class="line">        displayRange(lower+1,upper)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>大多数递归函数都至少接受一个参数。这个数据值测试结束递归过程的基本条件。在每一个递归步骤之前，也会以某种方式修改这个值。每次对数据值的修改，都应该会产生一个新的数据值，以允许函数最终达到基本条件。上面例子中，在每一次递归调用之前，将参数lower的值增加1，以使得其最终能够超过参数upper的值。<br>例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ourSum(lower,upper):</span><br><span class="line">      &quot;&quot;&quot;Return the sum of the numbers from lower thru upper.&quot;&quot;&quot;</span><br><span class="line">      if lower &gt; upper:</span><br><span class="line">          return 0</span><br><span class="line">      else:</span><br><span class="line">          return lower + ourSum(lower+1, upper)</span><br></pre></td></tr></table></figure>

<p>跟踪其调用情况来更好地理解递归的工作方式：添加一个参数表示缩进的边距，并且添加输出语句来跟踪每次调用的时候两个参数的值和返回的值。每次调用的第一条语句会计算缩进的边距，然后在输出两个参数的时候使用它。在每次调用返回之前，也会使用该缩进把计算所得到的值输出出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def ourSum(lower,upper,margin=0):</span><br><span class="line">    &quot;&quot;&quot;Returns the sum of the numbers from lower to upper,</span><br><span class="line">    and outputs a trace of the arguments and return values</span><br><span class="line">    on each call.&quot;&quot;&quot;</span><br><span class="line">    blanks = &quot; &quot; * margin</span><br><span class="line">    print(blanks,lower,upper)</span><br><span class="line">    if lower &gt; upper:</span><br><span class="line">        print(blanks, 0)</span><br><span class="line">    else:</span><br><span class="line">        result = lower + ourSum(lower + 1,upper, margin + 4)</span><br><span class="line">        print(blanks, result)</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h4 id="嵌套的函数定义"><a href="#嵌套的函数定义" class="headerlink" title="嵌套的函数定义"></a>嵌套的函数定义</h4><p>可以在一个函数的语句序列之中，嵌套其他函数的定义。考虑递归函数factorial的如下两个定义，第一个定义使用了一个嵌套的辅助函数，来用必需的参数执行递归。第二个定义给定了第二个参数一个默认值，从而简化了设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># First definition</span><br><span class="line">def factorial(n):</span><br><span class="line">    &quot;&quot;&quot;Returns the factorial of n.&quot;&quot;&quot;</span><br><span class="line">    def recurse(n, product):</span><br><span class="line">        if n == 1:return product</span><br><span class="line">        else: return recurse(n-1, n * product)</span><br><span class="line">    recurse(n,1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Second definition</span><br><span class="line">def factorial(n,product = 1):</span><br><span class="line">    &quot;&quot;&quot;Returns the factorial of n.&quot;&quot;&quot;</span><br><span class="line">    if n == 1 : return product</span><br><span class="line">    else: return factorial(n - 1 ,n *product)</span><br></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>Python 函数都是第一类的数据对象。这意味着，可将函数赋值给变量，保存到数据结构中，作为参数传递给其他函数，以及当作其他函数的值返回。<br>高阶函数（high-order function）：接受另一个函数作为参数，并且以某种方式应用该函数。<br>Python包含了内建的高阶函数，如map和filter，它们对于处理可迭代的对象很有用。<br>map 函数接受一个函数和一个可迭代对象作为参数，并且返回另一个可迭代对象。后者是对第一个可迭代对象中的每一项应用参数函数而得到的另一个可迭代对象。简而言之，map实际上将一个可迭代对象中的每一项都转换了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建了包含字符串的可迭代对象</span><br><span class="line">map(str, oldList)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据上面的对象创建了一个新的列表</span><br><span class="line">newList = list(map(str,oldList))</span><br></pre></td></tr></table></figure>

<p>若想要从考试分数的一个列表中删除所有的0分，如下循环可以完成这个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">newList = []</span><br><span class="line">for number in oldList:</span><br><span class="line">    if number &gt; 0:</span><br><span class="line">        newList.append(number)</span><br></pre></td></tr></table></figure>

<p>或者可以使用filter函数，该函数接受一个布尔函数和一个可迭代对象作为参数。filter函数返回一个可迭代的对象，其中每一项都传递给这个布尔函数。如果该函数返回True，这一项保留在返回的可迭代对象中；否则的话，删除该项。简而言之，实际上filter函数让接受的这个可迭代对象的每一项都通过一个测试。</p>
<p>因此，假设已经有了这个布尔函数：isPositive,如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建了一个可迭代对象，其中包含了非零的得分</span><br><span class="line">filter(isPositive, oldList)</span><br><span class="line"># 根据该对象创建了一个新的列表</span><br><span class="line">newList = list(filter(isPositive,oldList))</span><br></pre></td></tr></table></figure>

<h4 id="使用lambda表达式创建匿名函数"><a href="#使用lambda表达式创建匿名函数" class="headerlink" title="使用lambda表达式创建匿名函数"></a>使用lambda表达式创建匿名函数</h4><p>可以临时性地创建一个匿名函数以传递给 map 或 filter，从而避免定义像 isPositive 这样的一次性的辅助函数。<br>lambda表达式形式： <code>lambda &lt;argument list&gt; : &lt;expression&gt;</code><br>注意，这个表达式不能像其他的Python函数那样包含一个语句序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个匿名的布尔函数来从分数的列表删除0分。</span><br><span class="line">newList = list(filter(lambda number : number &gt; 0,oldList))</span><br></pre></td></tr></table></figure>

<p>另一个高阶函数functools.reduce，通过应用带有两个参数的函数来将一个可迭代对象的项转换为单个的值，而该函数的两个参数是下一项和前一次应用该函数的结果。<br>因此，前面展示的计算一个数列的乘积的for循环，也可以写成如下的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个匿名的布尔函数来从分数的列表删除0分。</span><br><span class="line">newList = list(filter(lambda number : number &gt; 0,oldList))</span><br></pre></td></tr></table></figure>

<p>另一个高阶函数functools.reduce，通过应用带有两个参数的函数来将一个可迭代对象的项转换为单个的值，而该函数的两个参数是下一项和前一次应用该函数的结果。<br>因此，前面展示的计算一个数列的乘积的for循环，也可以写成如下的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">product = functools.reduce(lambda x, y : x*y, range(1,11))</span><br></pre></td></tr></table></figure>

<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>当 Python 虚拟机在程序执行的过程中遇到一个语义错误的时候，它抛出一个异常，停止程序并且给出一条错误消息。<br>Python 包含了一条try-except语句，它允许程序捕获异常并执行相应的恢复操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">except &lt;exception type&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br></pre></td></tr></table></figure>

<p>当运行这条语句的时候，try 子句中的语句将会执行。如果这些语句中的一条引发异常，执行将会立即传递到 except 子句。如果所引发的异常的类型和这条子句中的异常类型一致，将会执行其语句。否则，将执行传递到try-except语句的调用者，并且进一步沿着调用链向上传递，直到异常成功地得到处理，或者程序停止并产生一条错误消息。如果 try 子句中的语句没有引发异常，就会跳过except子句，并且执行继续直到try-except语句的末尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Author: Ken Lambert</span><br><span class="line">Demonstrates a function that traps number format errors during input.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def safeIntegerInput(prompt):</span><br><span class="line">    &quot;&quot;&quot;Prompts the user for an integer and returns the</span><br><span class="line">    integer if it is well-formed.Otherwise, prints an </span><br><span class="line">    error message and repeats this process.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    inputString = input(inputString)</span><br><span class="line">    try:</span><br><span class="line">        number = int(inputString)</span><br><span class="line">        return number</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&quot;Error in number format: &quot;inputString)</span><br><span class="line">        return safeIntegerInput(prompt)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    age = safeIntegerInput(&quot;Enter your age: &quot;)</span><br><span class="line">    print(&quot;Your age is &quot;, age)</span><br></pre></td></tr></table></figure>

<h4 id="文件及其操作"><a href="#文件及其操作" class="headerlink" title="文件及其操作"></a>文件及其操作</h4><h5 id="文本文件的输出"><a href="#文本文件的输出" class="headerlink" title="文本文件的输出"></a>文本文件的输出</h5><p>根据文本文件的格式和数据的用途，可以将文本文件中的数据看做是字符、单词、数字或者文本行。当把这些数据当作整数或浮点数的时候，必须用空白符（空格、制表符和换行符）将其分隔开。<br>文本文件的所有数据输出或数据输入都必须是字符串。<br>可以使用文件对象将数据输出到文本文件中。Python中的open函数接受文件的路径名称和模式字符串作为参数，它打开到磁盘上的文件的一个连接，并且返回文件对象。模式字符串’r’表示输入文件，’w’表示输出文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在文件名为&quot;myfile.txt&quot;的文件上打开一个文件对象以进行输出。</span><br><span class="line">f = open(&quot;myfile.txt&quot;,&apos;w&apos;)</span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，会使用给定的路径名称来创建它。如果文件已经存在，Python会打开它。当数据写入到文件并且文件关闭的时候，文件中之前存在的任何数据都会被擦除。<br>使用write方法和文件对象，将字符串数据写入（或输入）到一个文件之中。write方接受单个的字符串参数。如果想要输出文本并且以换行来结束，必须在字符串中包含转义字符’\n’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在文件名为&quot;myfile.txt&quot;的文件上打开一个文件对象以进行输出。</span><br><span class="line">f = open(&quot;myfile.txt&quot;,&apos;w&apos;)</span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，会使用给定的路径名称来创建它。如果文件已经存在，Python会打开它。当数据写入到文件并且文件关闭的时候，文件中之前存在的任何数据都会被擦除。<br>使用write方法和文件对象，将字符串数据写入（或输入）到一个文件之中。write方接受单个的字符串参数。如果想要输出文本并且以换行来结束，必须在字符串中包含转义字符’\n’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将两行文本写入到了文件中</span><br><span class="line">f.write(&quot;First line.\nSecond line.\n&quot;)</span><br><span class="line"># 当所有的输出完成后，应该使用close方法来关闭文件，如果没有成功地关闭输出的文件，将会导致数据丢失。</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="将数字写入到一个文本文件"><a href="#将数字写入到一个文本文件" class="headerlink" title="将数字写入到一个文本文件"></a>将数字写入到一个文本文件</h5><p>文件方法write接受字符串参数。因此，其他类型的数据，如整数或浮点数，必须先转换成为字符串，然后才能写入到输出文件中。在Python中大多数数据类型的值都可以使用str函数来转换字符串。然后，使用空格或换行作为分隔字符，将所得到的字符串写入到文件中。</p>
<h5 id="将数字写入到一个文本文件-1"><a href="#将数字写入到一个文本文件-1" class="headerlink" title="将数字写入到一个文本文件"></a>将数字写入到一个文本文件</h5><p>文件方法write接受字符串参数。因此，其他类型的数据，如整数或浮点数，必须先转换成为字符串，然后才能写入到输出文件中。在Python中大多数数据类型的值都可以使用str函数来转换字符串。然后，使用空格或换行作为分隔字符，将所得到的字符串写入到文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import random </span><br><span class="line">f = open(&quot;integers.txt&quot;,&apos;w&apos;)</span><br><span class="line">for count in range(500):</span><br><span class="line">    number = random.randint(1,500)</span><br><span class="line">    f.write(str(number) + &quot;\n&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="从文本文件读取文本"><a href="#从文本文件读取文本" class="headerlink" title="从文本文件读取文本"></a>从文本文件读取文本</h5><p>打开一个文件进行输入的方式，和打开一个文件进行输出的方式相同。唯一的变化在于模式字符串。在打开文件进行输入的情况下，使用’r’字符串。最简单的方法是使用文件方法read来将整个文件的内容作为一个单独的字符串输入。如果文件包含了多行文本的话，换行字符将会嵌入到这个字符串中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&quot;myfile.txt&quot;,&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; text = f.read()</span><br></pre></td></tr></table></figure>

<p>在输入完成后，再次调用read将会返回一个空的字符串，表明已经到达了文件的末尾。要重复输入，必须再次打开文件。这样的话就不需要关闭该文件了。<br>使用for循环可以让程序每次只读取和处理一行文本。for循环将一个文件对象当作是文本行的一个序列。在每次通过循环的时候，循环变量都跳到序列中的下一行文本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;integers.txt&apos;,&apos;r&apos;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<p>readline 方法只读取一行的输入并且返回该字符串，包括换行符。如果readline遇到了文件的末尾，它会返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;integers.txt&apos;,&apos;r&apos;)</span><br><span class="line">while True:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    if line == &quot;&quot;:</span><br><span class="line">        break</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<h5 id="从文件读取数字"><a href="#从文件读取数字" class="headerlink" title="从文件读取数字"></a>从文件读取数字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ingeger.txt 是用换行符隔开的随机数</span><br><span class="line">f = open(&quot;integers.txt&quot;,&apos;r&apos;)</span><br><span class="line">sum = 0</span><br><span class="line">for line in f:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    number = int(line)</span><br><span class="line">    sum += number</span><br><span class="line">print(&quot;The sum is: &quot;,sum)</span><br></pre></td></tr></table></figure>

<p>从用空格隔开的文本文件中获取数字，则要稍微难一点。一种处理方法是，在一个for循环中读取行，但每一行可能包含空格隔开的几个整数。可以使用字符串方法split来获取表示这些整数的字符串的一个列表，然后使用另一个for循环来处理这个列表中的每一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;integers.txt&quot;,&apos;r&apos;)</span><br><span class="line">sum = 0</span><br><span class="line">for line in f:</span><br><span class="line">    wordlist = line.split()</span><br><span class="line">    for word in wordlist:</span><br><span class="line">          number = int(word)</span><br><span class="line">          sum += number</span><br><span class="line">print(&quot;The sum is :&quot;,sum)</span><br></pre></td></tr></table></figure>

<p>现在文本不必再剔除换行符了，因为split会自动地负责此项工作。</p>
<h5 id="用pickle读写对象"><a href="#用pickle读写对象" class="headerlink" title="用pickle读写对象"></a>用pickle读写对象</h5><p>我们可以将任何对象转换为文本进行存储，但是将复杂的对象映射为文本再映射回来，这个过程很烦，并且会为维护带来难度。Python有个模块，允许程序员使用一个叫做封装（pickling）的工具来保存和加载对象。这个术语源自于把黄瓜变成腌菜以便再罐子里储存的过程。然而，在计算对象的时候，我们还会把腌菜变回为黄瓜。任何对象都可以被封装（pickled），然后再将其保存到文件中，然后，随着你将其从文件中加载到程序中，对它们进行“拆封（unpickled)”。Python自动负责所有的转换细节。<br>首先导入一个pickle模块。使用”rb”和”wb”标志（用于字节流）来打开文件以进行输入和输出，并且以常用的方式来关闭文件。要保存对象，就使用pickle.dump函数。它的第一个参数是要”转储“或者说要存储到文件中的对象，其第二个参数是一个文件对象。<br>例如，可以使用pickle模块将一个名为lyst列表中的对象保存到一个名为item.dat的文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">lyst = [60, &quot;A string object&quot;, 1977]</span><br><span class="line">fileObj = open(&quot;items.dat&quot;,&quot;wb&quot;)</span><br><span class="line">for item in lyst:</span><br><span class="line">        pickle.dump(item,fileObj)</span><br><span class="line">fileObj.close()</span><br></pre></td></tr></table></figure>

<p>这个示例中，也可以将整个列表写入到一个文件中，而不是将其每个对象写入到文件中。<br>可以使用pickle.load函数，将封装的对象从一个文件加载到一个程序中。如果到达了文件的末尾，这个函数会引发一个异常。这使得输入过程复杂化了，因为在引发异常之前，没有明确的方法来检查是否达到了文件末尾。但是使用try-except语句解决这一问题。<br>现在，可构建一个输入文件循环来持续地加载对象，直到达到文件的末尾，此时引发一个EOFError。随后，except子句将会关闭文件并且退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#从item.dat文件中将对象加载到一个新的、名为lyst的列表中：</span><br><span class="line">import pickle</span><br><span class="line">lyst = list()</span><br><span class="line">fileObj = open(&quot;items.dat&quot;,&quot;rb&quot;)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        item = pickle.load(fileObj)</span><br><span class="line">        lyst.append(item)</span><br><span class="line">    except EOFError:</span><br><span class="line">        fileObj.close()</span><br><span class="line">        break</span><br><span class="line">print(lyst)</span><br></pre></td></tr></table></figure>

<h5 id="创建新的类"><a href="#创建新的类" class="headerlink" title="创建新的类"></a>创建新的类</h5><p>类描述了数据和一组相关对象方法。类提供了一个蓝图，可以用来创建对象以及在这些对象上调用方法的时候所执行的代码。Python中所有的数据类型都是类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#定义Python类</span><br><span class="line">calss &lt;class name&gt;(&lt;prarent class name&gt;):</span><br><span class="line">    &lt;class variable assignments&gt;</span><br><span class="line">    &lt;instance method definitions&gt;</span><br></pre></td></tr></table></figure>

<p>按照惯例，类名是要大写的。类定义的代码通常放在模块中，该模块的文件名和类名一样，但是是小写的。相关的类也可以出现在同一个模块中。<br>父类名是可选的，在这种情况下，会假设它是object。所有的Python类都位于层级中，object在这个层级的根部，有几个方法如<strong>str</strong>和<strong>eq</strong>均定义于object中，并且是所有的子类都会自动继承的。<br>实例方法在类的对象之上运行，它们包含了访问或修改实例变量的代码。实例变量引用了单个对象所拥有的存储。<br>类变量引用了类的所有对象共同拥有的存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Counter(object):</span><br><span class="line">    &quot;&quot;&quot;Models a counter&quot;&quot;&quot;</span><br><span class="line">    # Class variable</span><br><span class="line">    instances = 0</span><br><span class="line"></span><br><span class="line">    # Constructor</span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot; Set up the counter.&quot;&quot;&quot;</span><br><span class="line">        Counter.instances += 1</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    # Mutator methods</span><br><span class="line">    def reset(self):</span><br><span class="line">        &quot;&quot;&quot;Sets the counter to 0.&quot;&quot;&quot;</span><br><span class="line">        self._value = 0</span><br><span class="line"></span><br><span class="line">    def increment(self, amount=1):</span><br><span class="line">        &quot;&quot;&quot; Add amount to the counter.&quot;&quot;&quot;</span><br><span class="line">        self._value += amount</span><br><span class="line"></span><br><span class="line">    def decrement(self, amount=1):</span><br><span class="line">        &quot;&quot;&quot; Subtracts amount from the counter.&quot;&quot;&quot;</span><br><span class="line">        self._value -= amount</span><br><span class="line"></span><br><span class="line">    # Acessor methods</span><br><span class="line">    def getValue(self):</span><br><span class="line">        &quot;&quot;&quot;Returns the counter&apos;s value.&quot;&quot;&quot;</span><br><span class="line">        return self._value</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        &quot;&quot;&quot;Returns the string representation of the counter.&quot;&quot;&quot;</span><br><span class="line">        return str(self._value)</span><br><span class="line"></span><br><span class="line">    def __eq__(self, other):</span><br><span class="line">        &quot;&quot;&quot;Returns True if self equals other</span><br><span class="line">        or False otherwise.&quot;&quot;&quot;</span><br><span class="line">        if self is other:</span><br><span class="line">            return True</span><br><span class="line">        if type(self) != type(other):</span><br><span class="line">            return False</span><br><span class="line">        return self._value == other._value</span><br></pre></td></tr></table></figure>

<p>Counter 是object的一个子类。<br>类变量instances记录了创建的Counter对象的数目。除了最初在通过赋值引入类变量的时候之外，在其他时候，类变量必须有一个类名作为其前缀。<br>定义实例的语法与定义函数的语法是相同的。然而有一个额外的self参数，它总是出现在参数列表的开始处。在一个方法定义的上下文中，self引用的是在其上运行该方法的对象。<br>实例化方法<strong>init</strong>也叫作构造方法，当创建Counter的实例的时候，会自动运行其构造方法。该方法初始化了实例变量，并且更新了类变量。<br>修改器（mutator）方法通过修改对象的实例变量，来修改或改变对象的内部状态。访问器（accessor)方法直接查看或使用对象的实例变量的值，而不会修改它们。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/meshgrid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/meshgrid/" itemprop="url">np.meshgrid</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="生成网格点坐标"><a href="#生成网格点坐标" class="headerlink" title="生成网格点坐标"></a>生成网格点坐标</h3><p>plt.plot() 可以接受矩阵作为坐标信息，两个矩阵维度相同，根据对应关系来生成点。此时，matplotlib会将提供横坐标矩阵中的每一列对应的点当作同一条线。</p>
<p>‘’’<br> plt.plot(x,y,<br>          marker=’.’,#点的形状<br>          markersize=10, #点的大小<br>          linestyle=’-.’) #线形为点划线<br>‘’’</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:18:52+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaohui Bai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BaiZhaohui" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:isolatedislet@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaohui Bai</span>

  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

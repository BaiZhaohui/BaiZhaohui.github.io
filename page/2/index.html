<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Mist">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Mist">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mist">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Mist</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mist</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/直击招聘1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/直击招聘1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="STL：标准模板库"><a href="#STL：标准模板库" class="headerlink" title="STL：标准模板库"></a>STL：标准模板库</h1><p>STL中主要包含：container容器、algorithm算法、iterator迭代器。容器用于存放数据对象（元素），算法用于操作容器中的数据对象。尽管各种容器的内部结构各异，但是其外部常常给人的感觉都是相似的，即将对容器数据的操作设计称通用算法，也就是将算法和容器分离开来。算法和容器的中介就是迭代器。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h4><ul>
<li>vector（向量）：连续存储元素</li>
<li>list（链表）：由结点组成的双向链表，每个节点包含一个元素</li>
<li>deque（双端队列）：连续存储的指向不同元素的指针所组成的数组。<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4></li>
<li>set（集合）/multiset（多重集合）：由结点组成的红黑树，每个结点都包含一个元素。在set中没有相同关键字的元素，而multiset中允许存在两个相同的关键字的元素。</li>
<li>map（映射）/multimap（多重映射）：由（关键字，值）对组成的集合。在map中没有关键字相同的元素，而multimap中允许存在两个关键字相同的元素。<h4 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h4></li>
<li>stack（栈）：先进后出的序列</li>
<li>queue（队列）：先进先出的序列</li>
<li>priority_queue（优先队列）：元素的出队次序由指定的某种谓词决定的一种队列<h4 id="哈希容器"><a href="#哈希容器" class="headerlink" title="哈希容器"></a>哈希容器</h4></li>
<li>hash_map（hash_multimap,hash_set,hash_multiset）：哈希表</li>
<li>unordered_map：无序哈希表，替代hash_map</li>
</ul>
<h3 id="1-Vector（向量容器）"><a href="#1-Vector（向量容器）" class="headerlink" title="1.Vector（向量容器）"></a>1.Vector（向量容器）</h3><p>vector相当于动态数组，存储具有相同类型的一组元素，可以从尾部快速插入与删除元素，快速随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入和删除位置后的所有元素。如果出事分配的内存空间不够，当超过空间大小的时候，会重新分配更大的空间（通常按两倍大小扩展），此时需要进行大量的元素复制，增加了性能开销。<br>定义vector的几种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;<span class="comment">//定义元素为int的向量v1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>); <span class="comment">// 指定向量v2的初始大小为10个int元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1.23</span>); <span class="comment">//指定向量v3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4(a,a+<span class="number">5</span>);<span class="comment">// 用数组a[0...4]共5个元素初始化v4</span></span><br></pre></td></tr></table></figure>

<p>主要成员函数：</p>
<ul>
<li>max_size()：vector中能保存的最大元素个数。</li>
<li>size()： 当前vector中实际元素个数</li>
<li>[]：返回指定下标的元素，表明vector的元素可以随机访问</li>
<li>reserve(n)：为vector容器预分配n个元素的存储空间</li>
<li>capacity()：返回当前vector在重新分配内存前所能容纳的元素个数</li>
<li>resize(n)：调整vector容器的大小，使其能容纳n个元素。</li>
<li>empty()：判断vector是否为空。</li>
<li>at()：返回指定位置的元素。</li>
<li>front()：获取vector中第1个元素</li>
<li>back()：获取vector中最后一个元素</li>
<li>assign()：给vector中元素赋值</li>
<li>insert()：参数：位置迭代器及要插入元素，将待插入元素插入迭代器指定元素之前。</li>
<li>push_back()：在vector尾部添加一个元素。</li>
<li>pop_back()：删除vector的尾部元素。</li>
<li>erase()：删除某个iterator或者iterator区间指定的元素。</li>
<li>clear()：删除vector中所有元素。</li>
<li>begin()：用于正向迭代，返回vector中第一个元素的位置。</li>
<li>end()：用于正向迭代，返回vector中最后一个元素后面的一个位置。</li>
<li>rbegin()：用于反向迭代，返回最后一个元素的位置。</li>
<li>rend()：用于反向迭代，返回第一个元素前面一个位置。</li>
</ul>
<p><strong>注意</strong>：resize()和reserve()说明如下。<br>    1.reserve()是为容器预留空间，但不是真正创建元素对象，在创建元素对象之前不能引用容器内的元素，因此当加入新的元素时需要用push_back()/insert()函数。<br>    2.resize()是改变容器的大小，并创建对象，因此在调用这个函数后就可以引用容器内的对象了，故加入新的元素时用operator[]操作符或者用迭代器来引用元素对象。<br>    3.reserve()函数需要一个参数指出要预留的容器的大小；resize()函数可以有两个参数，第1个参数是容器的新的大小，第2个参数是要加入容器的新元素，如果这个参数省略，那么就调用元素对象的默认构造函数。<br>    4.采用reserve()成员函数为vector预先分配需要的内存空间可以提高执行效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(a, a + <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">////正向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it,it1;</span><br><span class="line">	<span class="keyword">for</span> (it = vec.begin(); it != vec.end(); ++it)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit;</span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找某个元素</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">	it1 = find(vec.begin(),vec.end(),x);</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找到元素"</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; *it1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未找到元素"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递减排序</span></span><br><span class="line">	sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果反向迭代，迭代器的创建使用<code>vector&lt;int&gt;::reverse_iterator rit;</code>来创建，而且在遍历的时候，如果起始以vec.rbegin()开始，以vec.rend()结束的话，rit还是以增的方式进行变化，而不是减，虽然是反向遍历。</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find() 为输入迭代器所定义的范围内查找单个对象的算法，可以在前两个参数指定的范围内，查找与第三个参数相等的第一个对象。它会返回一个指向被找到对象的迭代器，如果没有找到对象，会返回这个序列的结束迭代器。<br>其调用形式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（start,end,value）</span><br></pre></td></tr></table></figure>

<p>容器的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a.begin(),a.end(),value）</span><br></pre></td></tr></table></figure>

<p>数组的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a,a+length,val）</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>所有的sort算法的参数都需要输入一个范围，[begin, end)。这里使用的迭代器(iterator)都需是随机迭代器(RadomAccessIterator), 也就是说可以随机访问的迭代器（partition 和stable_partition 除外）。可以自定义比较函数作为参数传入。</p>
<h3 id="2-deque（双端队列容器）"><a href="#2-deque（双端队列容器）" class="headerlink" title="2.deque（双端队列容器）"></a>2.deque（双端队列容器）</h3><p>它是一个双端队列类模板。双端队列容器可以从前面或者后面快速插入与删除元素，并且可以快速随机访问元素，但是在中间插入和删除元素较慢。deque容器采用多个连续的存储块，即由一段一段的定量连续空间构成，随时可以增加一段新的空间并连接起来，因此deque没有capacity的概念。deque通过一个中央管理器来管理这些空间并隐藏deque的这些底层细节，让用户感觉在使用一个整体连续对象，并且提供了随机存取的接口。deque的空间的重新分配比vector快，在重新分配空间后原有的元素不需要全部复制。实际上，deque是对vector和list优/缺点的结合，它是处于两者之间的一种容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq1; <span class="comment">//定义元素为int的双端队列dq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq2(<span class="number">10</span>);<span class="comment">//指定双端队列dq2的初始大小为10个int 元素</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt;dq3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq4(dq2.begin(),dq2.end());<span class="comment">//用dq2的所有元素初始化dq4</span></span><br></pre></td></tr></table></figure>

<p>deque主要的成员函数：</p>
<ul>
<li>size()</li>
<li>[]</li>
<li>empty()</li>
<li>at()</li>
<li>front()</li>
<li>back()</li>
<li>push_front()</li>
<li>push_back()</li>
<li>pop_front()</li>
<li>pop_back()</li>
<li>erase()：删除指定位置或者指定区间的元素</li>
<li>clear()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispdq</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;dq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = dq.begin(); it != dq.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">	dq.push_front(<span class="number">1</span>);</span><br><span class="line">	dq.push_back(<span class="number">2</span>);</span><br><span class="line">	dq.push_front(<span class="number">3</span>);</span><br><span class="line">	dq.push_back(<span class="number">4</span>);</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	dq.pop_front();</span><br><span class="line">	dq.pop_back();</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-list（链表容器）"><a href="#3-list（链表容器）" class="headerlink" title="3.list（链表容器）"></a>3.list（链表容器）</h3><p>它是一个双链表类模板，可以从任何地方快速插入与删除。它的每个元素间用指针链接。与vector相比，list不支持随机访问（没有提供operator[]运算符和at()成员函数），为了访问链表容器中特定的元素，必须从第1个位置（表头）开始，随着指针从一个元素到下一个元素，直到找到满足条件的元素。<br>list中插入元素的速度比vector中快。由于list对每个元素单独分配空间，所以不存在空间不够、重新分配空间的情况。<br>定义list对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l2(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line">lsit&lt;<span class="keyword">int</span>&gt;l4(a,a+<span class="number">5</span>);<span class="comment">//用数组a[0...4]共5个元素初始化l4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>的主要成员函数：</span><br><span class="line">- size()</span><br><span class="line">- empty()</span><br><span class="line">- push_back()</span><br><span class="line">- pop_back()</span><br><span class="line">- push_front()</span><br><span class="line">- pop_front()</span><br><span class="line">- insert(pos,num)</span><br><span class="line">- insert(pos,n,num)：在pos位置插入n个元素num</span><br><span class="line">- insert(pos,beg,end)：在pos位置插入区间为[beg,end]的元素</span><br><span class="line">- remove()：删除<span class="built_in">list</span>中所有指定值的元素</span><br><span class="line">- remove_if(cmp)：删除条件满足的元素</span><br><span class="line">- erase()：从<span class="built_in">list</span>中删除一个或者几个元素</span><br><span class="line">- clear()</span><br><span class="line">- unique()：删除相邻的重复元素</span><br><span class="line">- reverse()：反转链表</span><br><span class="line">- sort()：对<span class="built_in">list</span>容器中的元素排序</span><br><span class="line">- c1.merge(c2)：合并两个有序的链表并使之有序，重新放到c1中，且释放c2。</span><br><span class="line">- c1.merge(c2,comp)，合并两个有序链表，并使之按照自定义 规则排序之后重新放到c1，且释放c2。</span><br><span class="line">- c1.splice(c1.beg,c2)：将c2连接在c1的beg位置，并释放c2</span><br><span class="line">- begin()</span><br><span class="line">- end()：用于正向迭代，返回<span class="built_in">list</span>中最后一个元素后面的一个位置</span><br><span class="line">- rbegin()</span><br><span class="line">- rend()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + n);</span><br><span class="line">	<span class="comment">//mylist.remove(3);</span></span><br><span class="line">	mylist.remove_if(cmp);</span><br><span class="line">	mylist.unique();</span><br><span class="line">	Disp(mylist);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于STL算法中的排序算法sort()只能用于顺序容器，不能用于list容器，所以list提供了自己的sort成员函数。<br>在使用list.sort()时，默认情况下使用底层元素类型的小于运算符按递增方式排序，如果按递减排序，需使用预定义的类模板greater，它调用底层元素类型的大于运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + <span class="number">6</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">mylist.sort();</span><br><span class="line">Disp(mylist);</span><br><span class="line">mylist.sort(greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">Disp(mylist);</span><br></pre></td></tr></table></figure>


  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myClass(<span class="keyword">int</span> m) :n(m)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> myClass &amp;s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (n &gt; s.getn());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Displist</span><span class="params">(<span class="built_in">list</span>&lt;myClass&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;getn();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myClass obj1(3), obj2(5), obj3(2);</span><br><span class="line">	myClass obj4(7), obj5(4), obj6(1),obj7(6);</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt; mylist1, mylist2;</span><br><span class="line">	mylist1.push_back(obj1);</span><br><span class="line">	mylist1.push_back(obj2);</span><br><span class="line">	mylist1.push_back(obj3);</span><br><span class="line">	mylist2.push_back(obj4);</span><br><span class="line">	mylist2.push_back(obj5);</span><br><span class="line">	mylist2.push_back(obj6);</span><br><span class="line">	mylist2.push_back(obj7);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	mylist1.sort();</span><br><span class="line">	mylist2.sort();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1合并到mylist2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	mylist2.merge(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-set（集合容器）-multiset（多重集合容器）"><a href="#4-set（集合容器）-multiset（多重集合容器）" class="headerlink" title="4.set（集合容器）/multiset（多重集合容器）"></a>4.set（集合容器）/multiset（多重集合容器）</h3><p>vector,dque,list均属于顺序容器，这类容器通过元素在容器中的位置来顺序存储和访问元素；而set/multiset、map/multimap属于关联容器，这类容器中的每个元素都有一个key（关键字），通过key来存储和读取元素。关联容器不提供顺序容器中的front()、push_front()、back()、push_back()以及pop_back()操作。<br>set的底层使用一种平衡二叉树（即红黑树）实现，在插入、删除时仅需要操作结点指针即可完成，不涉及内存移动和复制，所以效率比较高。默认情况下会对元素按关键字自动进行升序排列，所以查找速度比较快，同时支持交、差、并等集合运算。由于set中没有相同关键字的元素，在向set中插入元素时，如果已经存在，则不插入。multiset中允许存在两个相同关键字的元素，删除multiset中值等于elem的所有元素，若删除成功，返回删除个数，否则返回0。<br>set/multiset成员函数：</p>
<ul>
<li>max_size()</li>
<li>size()</li>
<li>empty()</li>
<li>insert()</li>
<li>erase()</li>
<li>clear()</li>
<li>count(k)：返回容器中关键字k出现的次数</li>
<li>find(k):如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值</li>
<li>upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素</li>
<li>lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispset</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;myset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myset.begin(); it != myset.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set1, set2, set3;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	set1.insert(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> b[]&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>]);</span><br><span class="line">	set2.insert(b, b + m);</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set1: "</span>;</span><br><span class="line">	Dispset(set1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set2: "</span>;</span><br><span class="line">	Dispset(set2);</span><br><span class="line">	insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; insert_it(set3, set3.begin());</span><br><span class="line">	set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"并集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"交集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"差集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-map（映射容器）-multimap（多重映射容器）"><a href="#5-map（映射容器）-multimap（多重映射容器）" class="headerlink" title="5.map（映射容器）/multimap（多重映射容器）"></a>5.map（映射容器）/multimap（多重映射容器）</h3><p>它们是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。set/multiset中的key和value是key类型的，而map中的key和value是一个pair类结构（二元组）中的两个分量。<br>pair类结构用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较的比较运算符模板函数。例如定义了一个对象p1表示一个平面坐标点并输入坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;p1;<span class="comment">//定义pair对象p1</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p1.first&gt;&gt;p1.second;<span class="comment">//输入p1的坐标</span></span><br></pre></td></tr></table></figure>

<p>map/multimap 中所有key-value对按key的升序排列，以平衡二叉树（红黑树）的形式存储，可以根据key快速找到与之对应的value，利用key类型的&lt;运算符比较大小，对于非内置类型的元素，需要自己定义或者重载&lt;运算符。map中不允许关键字重复出现，存在[ ]运算符；而multimap中允许关键字重复出现，但没有[ ]运算符。<br>map/multimap的主要成员函数：</p>
<ul>
<li>max_size</li>
<li>size()</li>
<li>empty()</li>
<li>map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字则以key为关键字插入一个元素（不适合multimap）。</li>
<li>insert(elem)：插入一个元素elem并返回该元素的位置。</li>
<li>clear()</li>
<li>find()</li>
<li>count()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
</ul>
<p>map中改变元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap; <span class="comment">//定义map对象mymap</span></span><br><span class="line">mymap[<span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">//或者mymap.insert(pair&lt;char,int&gt;('a',1));</span></span><br></pre></td></tr></table></figure>

<p>获得map中一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = mymap[<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispmap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;mymap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mymap.begin(); it != mymap.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;first&lt;&lt;<span class="string">" "</span> &lt;&lt; it-&gt;second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymap;</span><br><span class="line">	mymap.insert(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'a'</span>, <span class="number">1</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">'b'</span>, <span class="number">2</span>));</span><br><span class="line">	mymap[<span class="string">'c'</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap: "</span>;</span><br><span class="line">	Dispmap(mymap);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-stack（栈容器）"><a href="#6-stack（栈容器）" class="headerlink" title="6.stack（栈容器）"></a>6.stack（栈容器）</h3><p>stack、queue和priority_queue都是适配器容器，适配器容器是基于其他某种底层容器实现的。<br>如默认的stack和queue都基于deque容器实现，而priority_queue则在vector容器上实现，也可以指定其他底层容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; myst; <span class="comment">//第二个参数指定底层容器为vector</span></span><br></pre></td></tr></table></figure>

<p>显示指定适配器容器的底层容器时必须满足一定的约束条件，因为适配器容器都根据底层容器来定义自己的操作。如stack关联的底层容器可以是任何一种顺序容器类型，因此stack可以建立在vector、list、deque容器之上（一般用vector和deque实现比list实现的性能好）。queue要求其底层容器必须支持push_front运算，因此只能建立在list和deque容器上，而不能建立在vector容器上。priority_queue要求提供随机访问功能，因此可建立在vector或deque容器上，但不能建立在list容器上。<br>可以看出适配器容器并没有提供与元素保存的保存形式有关的真正的数据结构实现，所以适配器容器不支持迭代器。<br>从一般算法角度看，stack就是一个栈类模板。栈具有先进后出的特点，只有一个出口，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>push()：元素进栈</li>
<li>top()：返回栈顶元素</li>
<li>pop()</li>
</ul>
<h3 id="7-queue（队列容器）"><a href="#7-queue（队列容器）" class="headerlink" title="7.queue（队列容器）"></a>7.queue（队列容器）</h3><p>它是一个队列类模板。先进先出，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>front()：返回队头元素</li>
<li>back()：返回队尾元素</li>
<li>push()：元素进队</li>
<li>pop()</li>
</ul>
<h3 id="8-priority-queue（优先队列容器）"><a href="#8-priority-queue（优先队列容器）" class="headerlink" title="8.priority_queue（优先队列容器）"></a>8.priority_queue（优先队列容器）</h3><p>它是一个优先队列类模板，它是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列中最高优先级的元素。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>top()</li>
<li>push()</li>
<li>pop()<br>优先队列中优先级的高低由队列中数据元素的关系函数（比较运算符）确定，可以使用默认，也可以重载自己编写的关系函数。</li>
</ul>
<p>1.对于C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，值越大优先级越高，可以改为以greater<t>作为关系函数，这样值越大优先级越低。</t></t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//优先队列pq1默认使用vector作为容器</span></span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq2(a, a + n);</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，但需要重载该运算符，也可以自定义相应的关系函数。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Stud(<span class="keyword">int</span> n, <span class="built_in">string</span> na) <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		no = n;</span><br><span class="line">		name = na;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&lt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &lt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&gt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &gt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  结构体的关系函数改写operator()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Studcmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Stud &amp;s1, <span class="keyword">const</span> Stud &amp;s2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s1.name &gt; s2.name;<span class="comment">//name越小优先级越高</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stud a[]&#123; Stud(<span class="number">1</span>,<span class="string">"Marry"</span>),Stud(<span class="number">3</span>,<span class="string">"John"</span>),Stud(<span class="number">2</span>,<span class="string">"Smith"</span>) &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq1.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq1.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud,<span class="built_in">vector</span>&lt;Stud&gt;,greater&lt;Stud&gt;&gt; pq2(a,a+n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq2.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq2.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	priority_queue&lt;Stud, <span class="built_in">vector</span>&lt;Stud&gt;, Studcmp&gt; pq3(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq3: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq3.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq3.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq3.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq3.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-hash-map（哈希表容器）"><a href="#9-hash-map（哈希表容器）" class="headerlink" title="9.hash_map（哈希表容器）"></a>9.hash_map（哈希表容器）</h3><p>它使用hash表的数据结构，插入的元素关键字不允许重复（重复关键字的元素不会被插入）。hash_map 的所有元素都是pair，第 1 个元素为关键字（key），不能修改，第2个元素为值（value），可被修改。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>find(const key_type&amp; k)： 查找指定关键字k的元素</li>
<li>void insert(first,last)</li>
<li>erase(iterator pos)：删除迭代器pos指定位置的元素</li>
<li>erase(const key_type&amp; k)：删除容器中等于关键字k的元素。</li>
<li>clear()：删除容器中的所有元素。</li>
</ul>
<h3 id="10-unordered-map（无序哈希表容器）"><a href="#10-unordered-map（无序哈希表容器）" class="headerlink" title="10.unordered_map（无序哈希表容器）"></a>10.unordered_map（无序哈希表容器）</h3><p>unordered_map 也是一个哈希表容器，属于C++11特性。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>hash_function()：获取存储的哈希函数对象</li>
<li>operator[]：查找与指定关键字匹配的元素。当成功时返回对应元素的迭代器指针。</li>
<li>count()</li>
<li>insert()</li>
<li>erase()</li>
<li>begin()</li>
<li>end()</li>
</ul>
<h3 id="map、hash-map、unordered-map"><a href="#map、hash-map、unordered-map" class="headerlink" title="map、hash_map、unordered_map"></a>map、hash_map、unordered_map</h3><p>1.一般情况下，unordered_map 比hash_map插入、删除操作的速度更快，查找效率相近。<br>2.map、unordered_map用法类似，只是map中的元素是有序存储的，而unordered_map无序存储，它的查找速度更快，但是占用的内存空间也更大。<br>3.非频繁的查询或者考虑有序性时采用map比较稳定；频繁查询或者不需要考虑有序性时采用unordered_map更好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/直击招聘2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/直击招聘2/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="迭代器和迭代器适配器"><a href="#迭代器和迭代器适配器" class="headerlink" title="迭代器和迭代器适配器"></a>迭代器和迭代器适配器</h1><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h3><ul>
<li>InputIterator，可读，不可写，只支持自增运算</li>
<li>OutputIterator，写，不能读，只支持自增运算</li>
<li>ForwardIterator，可读可写，只支持自增运算</li>
<li>BidirectionalIterator（双向迭代器），可读可写，支持自增和自减运算。</li>
<li>RandomAccessIterator（随机访问迭代器），可读可写，支持完整的迭代器算术运算</li>
<li>advance(it,n)函数，用于将迭代器it前进n步，相当于it=it+n</li>
</ul>
<h3 id="2-迭代器适配器"><a href="#2-迭代器适配器" class="headerlink" title="2.迭代器适配器"></a>2.迭代器适配器</h3><p>普通适配器是指容器适配器，迭代器适配器与容器适配器类似，只是底层不是一个容器，而是附属容器的那个迭代器，因此结果不再是容器适配器，而是迭代器适配器。<br>迭代器适配器分为插入迭代器、反向迭代器和流迭代器几种类型。<br>1.插入迭代器<br>        常作为参数向算法（如copy()）说明向哪个容器及其位置插入数据，而插入数据操作主要有insert(),push_back()和push_front（），对应的迭代器为insert_iterator、front_insert_iterator和back_insert_iterator。</p>
<pre><code>insert_iterator 也称为inserters，用来将”赋值新值“操作转换为”插入新值“操作。通过这种迭代器，算法可以插入（insert）行为而非覆盖（overwrite）行为。</code></pre> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Displist</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;firstlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = firstlist.begin(); it != firstlist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; firstlist(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> b[]&#123; <span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; secondlist(b, b + m);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	it = firstlist.begin();</span><br><span class="line">	advance(it, <span class="number">3</span>);</span><br><span class="line">	insert_iterator&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; insert_it(firstlist, it);</span><br><span class="line">	copy(secondlist.begin(), secondlist.end(), insert_it);<span class="comment">//将secondlist元素复制到insert_it处</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"firstlist: "</span>; </span><br><span class="line">	Displist(firstlist);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"secondlist: "</span>;</span><br><span class="line">	Displist(secondlist);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序使用insert_iterator迭代器inset_it将secondlist的所有元素插入到firstlist中第4个元素开始的地方。</p>
<p>2.反向迭代器<br>        反向迭代器重新定义递增运算和递减运算，使其行为与正向迭代器正好倒置。<br>3.流迭代器<br>        流迭代器是一种迭代器适配器，通过它可以把stream当成算法的原点和终点。<br>        一个istream迭代器可以用来从输入流中读元素，而一个ostream迭代器可以用来对输出流写入元素。<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;T&gt; 标识符(istream &amp;);</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; ins(<span class="built_in">cin</span>); <span class="comment">//istream迭代器ins从键盘获取一个int整数序列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// istream迭代器ins从abc.txt文件中获取一个int整数序列</span></span><br><span class="line"><span class="function">istream <span class="title">infile</span><span class="params">(<span class="string">"abc.txt"</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; ins(infile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream_iterator&lt;T&gt;标识符(ostream &amp;);</span><br><span class="line">ostream_iterator&lt;T&gt; 标识符(ostream &amp;,<span class="keyword">char</span> *delimiter);</span><br><span class="line">其中delimiter是一个C风格字符串，它被输出到每个元素的后面</span><br><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; outs(<span class="built_in">cout</span>,<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ostream <span class="title">outfile</span><span class="params">(<span class="string">"abc.txt"</span>)</span></span>;</span><br><span class="line">ostream_iterator &lt;<span class="keyword">int</span>&gt; outs(outfile,<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/STL/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="STL：标准模板库"><a href="#STL：标准模板库" class="headerlink" title="STL：标准模板库"></a>STL：标准模板库</h1><p>STL中主要包含：container容器、algorithm算法、iterator迭代器。容器用于存放数据对象（元素），算法用于操作容器中的数据对象。尽管各种容器的内部结构各异，但是其外部常常给人的感觉都是相似的，即将对容器数据的操作设计称通用算法，也就是将算法和容器分离开来。算法和容器的中介就是迭代器。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h4><ul>
<li>vector（向量）：连续存储元素</li>
<li>list（链表）：由结点组成的双向链表，每个节点包含一个元素</li>
<li>deque（双端队列）：连续存储的指向不同元素的指针所组成的数组。<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4></li>
<li>set（集合）/multiset（多重集合）：由结点组成的红黑树，每个结点都包含一个元素。在set中没有相同关键字的元素，而multiset中允许存在两个相同的关键字的元素。</li>
<li>map（映射）/multimap（多重映射）：由（关键字，值）对组成的集合。在map中没有关键字相同的元素，而multimap中允许存在两个关键字相同的元素。<h4 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h4></li>
<li>stack（栈）：先进后出的序列</li>
<li>queue（队列）：先进先出的序列</li>
<li>priority_queue（优先队列）：元素的出队次序由指定的某种谓词决定的一种队列<h4 id="哈希容器"><a href="#哈希容器" class="headerlink" title="哈希容器"></a>哈希容器</h4></li>
<li>hash_map（hash_multimap,hash_set,hash_multiset）：哈希表</li>
<li>unordered_map：无序哈希表，替代hash_map</li>
</ul>
<h3 id="1-Vector（向量容器）"><a href="#1-Vector（向量容器）" class="headerlink" title="1.Vector（向量容器）"></a>1.Vector（向量容器）</h3><p>vector相当于动态数组，存储具有相同类型的一组元素，可以从尾部快速插入与删除元素，快速随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入和删除位置后的所有元素。如果出事分配的内存空间不够，当超过空间大小的时候，会重新分配更大的空间（通常按两倍大小扩展），此时需要进行大量的元素复制，增加了性能开销。<br>定义vector的几种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;<span class="comment">//定义元素为int的向量v1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>); <span class="comment">// 指定向量v2的初始大小为10个int元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1.23</span>); <span class="comment">//指定向量v3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4(a,a+<span class="number">5</span>);<span class="comment">// 用数组a[0...4]共5个元素初始化v4</span></span><br></pre></td></tr></table></figure>

<p>主要成员函数：</p>
<ul>
<li>max_size()：vector中能保存的最大元素个数。</li>
<li>size()： 当前vector中实际元素个数</li>
<li>[]：返回指定下标的元素，表明vector的元素可以随机访问</li>
<li>reserve(n)：为vector容器预分配n个元素的存储空间</li>
<li>capacity()：返回当前vector在重新分配内存前所能容纳的元素个数</li>
<li>resize(n)：调整vector容器的大小，使其能容纳n个元素。</li>
<li>empty()：判断vector是否为空。</li>
<li>at()：返回指定位置的元素。</li>
<li>front()：获取vector中第1个元素</li>
<li>back()：获取vector中最后一个元素</li>
<li>assign()：给vector中元素赋值</li>
<li>insert()：参数：位置迭代器及要插入元素，将待插入元素插入迭代器指定元素之前。</li>
<li>push_back()：在vector尾部添加一个元素。</li>
<li>pop_back()：删除vector的尾部元素。</li>
<li>erase()：删除某个iterator或者iterator区间指定的元素。</li>
<li>clear()：删除vector中所有元素。</li>
<li>begin()：用于正向迭代，返回vector中第一个元素的位置。</li>
<li>end()：用于正向迭代，返回vector中最后一个元素后面的一个位置。</li>
<li>rbegin()：用于反向迭代，返回最后一个元素的位置。</li>
<li>rend()：用于反向迭代，返回第一个元素前面一个位置。</li>
</ul>
<p><strong>注意</strong>：resize()和reserve()说明如下。<br>    1.reserve()是为容器预留空间，但不是真正创建元素对象，在创建元素对象之前不能引用容器内的元素，因此当加入新的元素时需要用push_back()/insert()函数。<br>    2.resize()是改变容器的大小，并创建对象，因此在调用这个函数后就可以引用容器内的对象了，故加入新的元素时用operator[]操作符或者用迭代器来引用元素对象。<br>    3.reserve()函数需要一个参数指出要预留的容器的大小；resize()函数可以有两个参数，第1个参数是容器的新的大小，第2个参数是要加入容器的新元素，如果这个参数省略，那么就调用元素对象的默认构造函数。<br>    4.采用reserve()成员函数为vector预先分配需要的内存空间可以提高执行效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(a, a + <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">////正向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it,it1;</span><br><span class="line">	<span class="keyword">for</span> (it = vec.begin(); it != vec.end(); ++it)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit;</span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找某个元素</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">	it1 = find(vec.begin(),vec.end(),x);</span><br><span class="line">	<span class="keyword">if</span> (it1 != vec.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找到元素"</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; *it1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未找到元素"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递减排序</span></span><br><span class="line">	sort(vec.begin(), vec.end(), cmp);</span><br><span class="line">	<span class="comment">//反向遍历</span></span><br><span class="line">	<span class="keyword">for</span> (rit = vec.rbegin(); rit != vec.rend(); ++rit)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果反向迭代，迭代器的创建使用<code>vector&lt;int&gt;::reverse_iterator rit;</code>来创建，而且在遍历的时候，如果起始以vec.rbegin()开始，以vec.rend()结束的话，rit还是以增的方式进行变化，而不是减，虽然是反向遍历。</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find() 为输入迭代器所定义的范围内查找单个对象的算法，可以在前两个参数指定的范围内，查找与第三个参数相等的第一个对象。它会返回一个指向被找到对象的迭代器，如果没有找到对象，会返回这个序列的结束迭代器。<br>其调用形式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（start,end,value）</span><br></pre></td></tr></table></figure>

<p>容器的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a.begin(),a.end(),value）</span><br></pre></td></tr></table></figure>

<p>数组的表示方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find（a,a+length,val）</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>所有的sort算法的参数都需要输入一个范围，[begin, end)。这里使用的迭代器(iterator)都需是随机迭代器(RadomAccessIterator), 也就是说可以随机访问的迭代器（partition 和stable_partition 除外）。可以自定义比较函数作为参数传入。</p>
<h3 id="2-deque（双端队列容器）"><a href="#2-deque（双端队列容器）" class="headerlink" title="2.deque（双端队列容器）"></a>2.deque（双端队列容器）</h3><p>它是一个双端队列类模板。双端队列容器可以从前面或者后面快速插入与删除元素，并且可以快速随机访问元素，但是在中间插入和删除元素较慢。deque容器采用多个连续的存储块，即由一段一段的定量连续空间构成，随时可以增加一段新的空间并连接起来，因此deque没有capacity的概念。deque通过一个中央管理器来管理这些空间并隐藏deque的这些底层细节，让用户感觉在使用一个整体连续对象，并且提供了随机存取的接口。deque的空间的重新分配比vector快，在重新分配空间后原有的元素不需要全部复制。实际上，deque是对vector和list优/缺点的结合，它是处于两者之间的一种容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq1; <span class="comment">//定义元素为int的双端队列dq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq2(<span class="number">10</span>);<span class="comment">//指定双端队列dq2的初始大小为10个int 元素</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt;dq3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;dq4(dq2.begin(),dq2.end());<span class="comment">//用dq2的所有元素初始化dq4</span></span><br></pre></td></tr></table></figure>

<p>deque主要的成员函数：</p>
<ul>
<li>size()</li>
<li>[]</li>
<li>empty()</li>
<li>at()</li>
<li>front()</li>
<li>back()</li>
<li>push_front()</li>
<li>push_back()</li>
<li>pop_front()</li>
<li>pop_back()</li>
<li>erase()：删除指定位置或者指定区间的元素</li>
<li>clear()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispdq</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;dq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = dq.begin(); it != dq.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">	dq.push_front(<span class="number">1</span>);</span><br><span class="line">	dq.push_back(<span class="number">2</span>);</span><br><span class="line">	dq.push_front(<span class="number">3</span>);</span><br><span class="line">	dq.push_back(<span class="number">4</span>);</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	dq.pop_front();</span><br><span class="line">	dq.pop_back();</span><br><span class="line">	Dispdq(dq);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-list（链表容器）"><a href="#3-list（链表容器）" class="headerlink" title="3.list（链表容器）"></a>3.list（链表容器）</h3><p>它是一个双链表类模板，可以从任何地方快速插入与删除。它的每个元素间用指针链接。与vector相比，list不支持随机访问（没有提供operator[]运算符和at()成员函数），为了访问链表容器中特定的元素，必须从第1个位置（表头）开始，随着指针从一个元素到下一个元素，直到找到满足条件的元素。<br>list中插入元素的速度比vector中快。由于list对每个元素单独分配空间，所以不存在空间不够、重新分配空间的情况。<br>定义list对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l2(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l3(<span class="number">10</span>,<span class="number">1.23</span>);<span class="comment">//指定dq3的10个初始元素的初值为1.23</span></span><br><span class="line">lsit&lt;<span class="keyword">int</span>&gt;l4(a,a+<span class="number">5</span>);<span class="comment">//用数组a[0...4]共5个元素初始化l4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>的主要成员函数：</span><br><span class="line">- size()</span><br><span class="line">- empty()</span><br><span class="line">- push_back()</span><br><span class="line">- pop_back()</span><br><span class="line">- push_front()</span><br><span class="line">- pop_front()</span><br><span class="line">- insert(pos,num)</span><br><span class="line">- insert(pos,n,num)：在pos位置插入n个元素num</span><br><span class="line">- insert(pos,beg,end)：在pos位置插入区间为[beg,end]的元素</span><br><span class="line">- remove()：删除<span class="built_in">list</span>中所有指定值的元素</span><br><span class="line">- remove_if(cmp)：删除条件满足的元素</span><br><span class="line">- erase()：从<span class="built_in">list</span>中删除一个或者几个元素</span><br><span class="line">- clear()</span><br><span class="line">- unique()：删除相邻的重复元素</span><br><span class="line">- reverse()：反转链表</span><br><span class="line">- sort()：对<span class="built_in">list</span>容器中的元素排序</span><br><span class="line">- c1.merge(c2)：合并两个有序的链表并使之有序，重新放到c1中，且释放c2。</span><br><span class="line">- c1.merge(c2,comp)，合并两个有序链表，并使之按照自定义 规则排序之后重新放到c1，且释放c2。</span><br><span class="line">- c1.splice(c1.beg,c2)：将c2连接在c1的beg位置，并释放c2</span><br><span class="line">- begin()</span><br><span class="line">- end()：用于正向迭代，返回<span class="built_in">list</span>中最后一个元素后面的一个位置</span><br><span class="line">- rbegin()</span><br><span class="line">- rend()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disp</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + n);</span><br><span class="line">	<span class="comment">//mylist.remove(3);</span></span><br><span class="line">	mylist.remove_if(cmp);</span><br><span class="line">	mylist.unique();</span><br><span class="line">	Disp(mylist);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于STL算法中的排序算法sort()只能用于顺序容器，不能用于list容器，所以list提供了自己的sort成员函数。<br>在使用list.sort()时，默认情况下使用底层元素类型的小于运算符按递增方式排序，如果按递减排序，需使用预定义的类模板greater，它调用底层元素类型的大于运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;mylist(a, a + <span class="number">6</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">mylist.sort();</span><br><span class="line">Disp(mylist);</span><br><span class="line">mylist.sort(greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">Disp(mylist);</span><br></pre></td></tr></table></figure>


  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myClass(<span class="keyword">int</span> m) :n(m)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> myClass &amp;s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (n &gt; s.getn());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Displist</span><span class="params">(<span class="built_in">list</span>&lt;myClass&gt; &amp;mylist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;getn();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myClass obj1(3), obj2(5), obj3(2);</span><br><span class="line">	myClass obj4(7), obj5(4), obj6(1),obj7(6);</span><br><span class="line">	<span class="built_in">list</span>&lt;myClass&gt; mylist1, mylist2;</span><br><span class="line">	mylist1.push_back(obj1);</span><br><span class="line">	mylist1.push_back(obj2);</span><br><span class="line">	mylist1.push_back(obj3);</span><br><span class="line">	mylist2.push_back(obj4);</span><br><span class="line">	mylist2.push_back(obj5);</span><br><span class="line">	mylist2.push_back(obj6);</span><br><span class="line">	mylist2.push_back(obj7);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	mylist1.sort();</span><br><span class="line">	mylist2.sort();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1: "</span>;</span><br><span class="line">	Displist(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1合并到mylist2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	mylist2.merge(mylist1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2: "</span>;</span><br><span class="line">	Displist(mylist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-set（集合容器）-multiset（多重集合容器）"><a href="#4-set（集合容器）-multiset（多重集合容器）" class="headerlink" title="4.set（集合容器）/multiset（多重集合容器）"></a>4.set（集合容器）/multiset（多重集合容器）</h3><p>vector,dque,list均属于顺序容器，这类容器通过元素在容器中的位置来顺序存储和访问元素；而set/multiset、map/multimap属于关联容器，这类容器中的每个元素都有一个key（关键字），通过key来存储和读取元素。关联容器不提供顺序容器中的front()、push_front()、back()、push_back()以及pop_back()操作。<br>set的底层使用一种平衡二叉树（即红黑树）实现，在插入、删除时仅需要操作结点指针即可完成，不涉及内存移动和复制，所以效率比较高。默认情况下会对元素按关键字自动进行升序排列，所以查找速度比较快，同时支持交、差、并等集合运算。由于set中没有相同关键字的元素，在向set中插入元素时，如果已经存在，则不插入。multiset中允许存在两个相同关键字的元素，删除multiset中值等于elem的所有元素，若删除成功，返回删除个数，否则返回0。<br>set/multiset成员函数：</p>
<ul>
<li>max_size()</li>
<li>size()</li>
<li>empty()</li>
<li>insert()</li>
<li>erase()</li>
<li>clear()</li>
<li>count(k)：返回容器中关键字k出现的次数</li>
<li>find(k):如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值</li>
<li>upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素</li>
<li>lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispset</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;myset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myset.begin(); it != myset.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set1, set2, set3;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	set1.insert(a, a + n);</span><br><span class="line">	<span class="keyword">int</span> b[]&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(b[<span class="number">0</span>]);</span><br><span class="line">	set2.insert(b, b + m);</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set1: "</span>;</span><br><span class="line">	Dispset(set1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"set2: "</span>;</span><br><span class="line">	Dispset(set2);</span><br><span class="line">	insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; insert_it(set3, set3.begin());</span><br><span class="line">	set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"并集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"交集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	set3.clear();</span><br><span class="line">	set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), insert_it);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"差集:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Dispset(set3);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-map（映射容器）-multimap（多重映射容器）"><a href="#5-map（映射容器）-multimap（多重映射容器）" class="headerlink" title="5.map（映射容器）/multimap（多重映射容器）"></a>5.map（映射容器）/multimap（多重映射容器）</h3><p>它们是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。set/multiset中的key和value是key类型的，而map中的key和value是一个pair类结构（二元组）中的两个分量。<br>pair类结构用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较的比较运算符模板函数。例如定义了一个对象p1表示一个平面坐标点并输入坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;p1;<span class="comment">//定义pair对象p1</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p1.first&gt;&gt;p1.second;<span class="comment">//输入p1的坐标</span></span><br></pre></td></tr></table></figure>

<p>map/multimap 中所有key-value对按key的升序排列，以平衡二叉树（红黑树）的形式存储，可以根据key快速找到与之对应的value，利用key类型的&lt;运算符比较大小，对于非内置类型的元素，需要自己定义或者重载&lt;运算符。map中不允许关键字重复出现，存在[ ]运算符；而multimap中允许关键字重复出现，但没有[ ]运算符。<br>map/multimap的主要成员函数：</p>
<ul>
<li>max_size</li>
<li>size()</li>
<li>empty()</li>
<li>map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字则以key为关键字插入一个元素（不适合multimap）。</li>
<li>insert(elem)：插入一个元素elem并返回该元素的位置。</li>
<li>clear()</li>
<li>find()</li>
<li>count()</li>
<li>begin()</li>
<li>end()</li>
<li>rbegin()</li>
<li>rend()</li>
</ul>
<p>map中改变元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap; <span class="comment">//定义map对象mymap</span></span><br><span class="line">mymap[<span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">//或者mymap.insert(pair&lt;char,int&gt;('a',1));</span></span><br></pre></td></tr></table></figure>

<p>获得map中一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = mymap[<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dispmap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;mymap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mymap.begin(); it != mymap.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;first&lt;&lt;<span class="string">" "</span> &lt;&lt; it-&gt;second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymap;</span><br><span class="line">	mymap.insert(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'a'</span>, <span class="number">1</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">'b'</span>, <span class="number">2</span>));</span><br><span class="line">	mymap[<span class="string">'c'</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mymap: "</span>;</span><br><span class="line">	Dispmap(mymap);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-stack（栈容器）"><a href="#6-stack（栈容器）" class="headerlink" title="6.stack（栈容器）"></a>6.stack（栈容器）</h3><p>stack、queue和priority_queue都是适配器容器，适配器容器是基于其他某种底层容器实现的。<br>如默认的stack和queue都基于deque容器实现，而priority_queue则在vector容器上实现，也可以指定其他底层容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; myst; <span class="comment">//第二个参数指定底层容器为vector</span></span><br></pre></td></tr></table></figure>

<p>显示指定适配器容器的底层容器时必须满足一定的约束条件，因为适配器容器都根据底层容器来定义自己的操作。如stack关联的底层容器可以是任何一种顺序容器类型，因此stack可以建立在vector、list、deque容器之上（一般用vector和deque实现比list实现的性能好）。queue要求其底层容器必须支持push_front运算，因此只能建立在list和deque容器上，而不能建立在vector容器上。priority_queue要求提供随机访问功能，因此可建立在vector或deque容器上，但不能建立在list容器上。<br>可以看出适配器容器并没有提供与元素保存的保存形式有关的真正的数据结构实现，所以适配器容器不支持迭代器。<br>从一般算法角度看，stack就是一个栈类模板。栈具有先进后出的特点，只有一个出口，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>push()：元素进栈</li>
<li>top()：返回栈顶元素</li>
<li>pop()</li>
</ul>
<h3 id="7-queue（队列容器）"><a href="#7-queue（队列容器）" class="headerlink" title="7.queue（队列容器）"></a>7.queue（队列容器）</h3><p>它是一个队列类模板。先进先出，不允许顺序遍历。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>front()：返回队头元素</li>
<li>back()：返回队尾元素</li>
<li>push()：元素进队</li>
<li>pop()</li>
</ul>
<h3 id="8-priority-queue（优先队列容器）"><a href="#8-priority-queue（优先队列容器）" class="headerlink" title="8.priority_queue（优先队列容器）"></a>8.priority_queue（优先队列容器）</h3><p>它是一个优先队列类模板，它是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列中最高优先级的元素。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>top()</li>
<li>push()</li>
<li>pop()<br>优先队列中优先级的高低由队列中数据元素的关系函数（比较运算符）确定，可以使用默认，也可以重载自己编写的关系函数。</li>
</ul>
<p>1.对于C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，值越大优先级越高，可以改为以greater<t>作为关系函数，这样值越大优先级越低。</t></t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]&#123; <span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//优先队列pq1默认使用vector作为容器</span></span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq2(a, a + n);</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非C/C++内置数据类型，默认以less<t>（小于关系函数）作为关系函数，但需要重载该运算符，也可以自定义相应的关系函数。</t></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Stud(<span class="keyword">int</span> n, <span class="built_in">string</span> na) <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		no = n;</span><br><span class="line">		name = na;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&lt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &lt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Stud &amp;s) <span class="keyword">const</span> <span class="comment">//重载&gt;关系函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> no &gt; s.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  结构体的关系函数改写operator()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Studcmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Stud &amp;s1, <span class="keyword">const</span> Stud &amp;s2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s1.name &gt; s2.name;<span class="comment">//name越小优先级越高</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stud a[]&#123; Stud(<span class="number">1</span>,<span class="string">"Marry"</span>),Stud(<span class="number">3</span>,<span class="string">"John"</span>),Stud(<span class="number">2</span>,<span class="string">"Smith"</span>) &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud&gt; pq1(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq1: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq1.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq1.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//使用Stud的&lt;关系函数定义pq1</span></span><br><span class="line">	priority_queue&lt;Stud,<span class="built_in">vector</span>&lt;Stud&gt;,greater&lt;Stud&gt;&gt; pq2(a,a+n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq2.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq2.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	priority_queue&lt;Stud, <span class="built_in">vector</span>&lt;Stud&gt;, Studcmp&gt; pq3(a, a + n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pq3: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!pq3.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pq3.top().no &lt;&lt; <span class="string">","</span> &lt;&lt; pq3.top().name &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">		pq3.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-hash-map（哈希表容器）"><a href="#9-hash-map（哈希表容器）" class="headerlink" title="9.hash_map（哈希表容器）"></a>9.hash_map（哈希表容器）</h3><p>它使用hash表的数据结构，插入的元素关键字不允许重复（重复关键字的元素不会被插入）。hash_map 的所有元素都是pair，第 1 个元素为关键字（key），不能修改，第2个元素为值（value），可被修改。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>find(const key_type&amp; k)： 查找指定关键字k的元素</li>
<li>void insert(first,last)</li>
<li>erase(iterator pos)：删除迭代器pos指定位置的元素</li>
<li>erase(const key_type&amp; k)：删除容器中等于关键字k的元素。</li>
<li>clear()：删除容器中的所有元素。</li>
</ul>
<h3 id="10-unordered-map（无序哈希表容器）"><a href="#10-unordered-map（无序哈希表容器）" class="headerlink" title="10.unordered_map（无序哈希表容器）"></a>10.unordered_map（无序哈希表容器）</h3><p>unordered_map 也是一个哈希表容器，属于C++11特性。<br>主要成员函数：</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>hash_function()：获取存储的哈希函数对象</li>
<li>operator[]：查找与指定关键字匹配的元素。当成功时返回对应元素的迭代器指针。</li>
<li>count()</li>
<li>insert()</li>
<li>erase()</li>
<li>begin()</li>
<li>end()</li>
</ul>
<h3 id="map、hash-map、unordered-map"><a href="#map、hash-map、unordered-map" class="headerlink" title="map、hash_map、unordered_map"></a>map、hash_map、unordered_map</h3><p>1.一般情况下，unordered_map 比hash_map插入、删除操作的速度更快，查找效率相近。<br>2.map、unordered_map用法类似，只是map中的元素是有序存储的，而unordered_map无序存储，它的查找速度更快，但是占用的内存空间也更大。<br>3.非频繁的查询或者考虑有序性时采用map比较稳定；频繁查询或者不需要考虑有序性时采用unordered_map更好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/C++基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/C++基础/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>titile: C++ 编程基础</p>
<p>layout: post</p>
<p>main 并非程序语言定义的关键词。但是，执行C++程序的编译系统时，会假设程序中定义有main()函数。如果没有定义，程序将无法执行。<br>数据的输入输出并非C++程序语言本身定义的一部分，而是由C++的一套面向对象类体系（classess hierarchy）提供支持，并作为C++标准程序库（standard library）的一员。</p>
<p>class 的定义通常分为两部分，写于不同的文件。其中之一是“头文件（head file）”，用来声明该 class 所提供的各种操作行为（operations）。另一个文件，程序代码文件（program text），则包含这些操作行为的实现内容（implementation）。</p>
<p>想要使用class ，则必须先在程序中包含其头文件。表头文件可以让程序知道class的定义。<br>iostream 为C++的标准”输入/输出程序库“，其中包含了相关的整套 classes，用以支持对终端机和文件的输入与输出。</p>
<p>string class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> user_name</span><br></pre></td></tr></table></figure>

<p>如此一来便定义了一个名为user_name的对象，它隶属于string class。这样的定义称为“声明语句（declaration statement）”。使用这一语句的时候，必须包含 string class 的头文件，让程序知道 string class 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> string</span></span><br></pre></td></tr></table></figure>

<p>定义新的classes时，应该为每一个class提供它们自己的output运算符。这样可以让classes用户得以像面对内建类型一样地以相同方式输出对象内容。</p>
<p>类型决定了对象所能含有的数值范围，同时也决定了对象应该占用多少内存空间。</p>
<p>另一种初始化语法：“构造函数语法（constructor syntax）”： int num(0);<br>如果对象需要多个初始值，等号赋值的方式就没办法完成任务了。如标准程序库中的复数（complex number）类，它就需要两个初始值，一为实部，一为虚部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; purei(<span class="number">0</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>出现在complex之后的尖括号，表示complex是一个template class（模板类）。 template class 允许我们在“不必指明 data members 之类型”的情况下定义class。<br>举个例子，复数内包含两个member data object。其一表示复数的实数部分，其二表示虚数部分。两者都需要以浮点数来表现，但我们应该采用哪种浮点数类别呢？C++有三种浮点数类别：float，double，long double。template class 机制使程序员得以直到使用 template class 时才决定真正的数据型别。程序员可以先安插一个代名，稍后才绑定至实际的数据型别。上例便是将 complex 类的成员绑定至 double 型别。<br>当“内建数据型别”与“程序员自行定义之class型别”具备不同的初始化语法时，我们无法撰写出一个 template，使它同时支持“内建型别”与“class 型别”，让语法统一，可以简化template的设计。</p>
<p>被定义为 const 的对象在获得初值后，无法再有任何变动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> line_size = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = line_size;</span><br></pre></td></tr></table></figure>

<p>如果测试条件属于整数型别，可用switch来替换if语句。</p>
<p>可利用continue语句来终止循环的现行迭代（current iteration）。</p>
<p>array的尺度必须是个常量表达式（constant expression），也就是一个不需要在执行期间计算其值的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seq_size = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> pell_seq[seq_size];</span><br></pre></td></tr></table></figure>

<p>vector 是个 class template，故必须在类名称之后的尖括号里指定其元素型别，其尺度则写在小括号中；此处所给予的尺度并不一定是常量表达式<br>定义vector object 必须包含vector头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pell_seq(seq_size);</span><br></pre></td></tr></table></figure>

<p>for (init-statement; condition; expression)<br>        statement</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">srand(seq_cnt)</span><br><span class="line">seq_index = rand() % seq_cnt</span><br><span class="line">current_vec = seq_addrs[ seq_index ];</span><br></pre></td></tr></table></figure>

<p>init-statement 会在循环开始前被执行一次。condition在每次循环迭代之前计算出来；expression会在循环每次迭代结束之后被计算。</p>
<p>array 与 vector 的差异：vector 可以知道自己的大小。</p>
<p>指针为程序引入了一层间接性，可以操控指针（代表某特定内存地址），而不再直接操控对象。<br>使用指针时，必须在提领它之前先确定它的确指向某对象。<br>一个未指向任何对象的指针，其内容地址为0。有时候我们称之为null指针。任何指针都可以被初始化，或是令其值为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化每个指针，使它们不指向任何对象</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> *pd = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> *ps = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>为了防止对null指针进行提领操作，我们可以检验该指针所含有的地址是否为0。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( pi &amp;&amp; *pi !=<span class="number">1024</span>)</span><br><span class="line">      *pi = <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pi &amp;&amp;...)</span><br><span class="line">只有在pi含有一个非零值时，其核定结果方才为<span class="literal">true</span>。如果核定结果为<span class="literal">false</span>，那么AND运算符就不会评估其第二表达式。</span><br></pre></td></tr></table></figure>

<p>欲检验某指针是否为null，我们通常使用逻辑运算符NOT：<br>if (!pi) //当 pi 之值为0，此表达式为true</p>
<p>指针符合以下形式：<br>type_of_object_pointed_to * name_of_pointer_object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">srand(seq_cnt);</span><br><span class="line">seq_index = rand() % seq_cnt;</span><br><span class="line">current_vec  = seq_addrs[seq_index];</span><br></pre></td></tr></table></figure>

<p>rand() 和 srand() 都是标准程序库提供的所谓伪随机数（pseudo-random number)产生器。srand()的参数是所谓随机数产生器种子（seed）。每次调用rand()，都会返回一个介于 0 和“ int 所能表示之最大整数”间的一个整数。</p>
<p>使用class object 的指针，和使用内建型别的指针略有不同。这是因为class object 链接到一组我们可以调用（invoke）的操作行为（operations）。  </p>
<p>指针选择行为操作使用 arrow 成员选择运算符 ! pv -&gt; empty()</p>
<p>由于指针可能并未指向任何对象，所以在调用empty()之前，应该先检验pv是否为非零值：<br>pv &amp;&amp; ! pv-&gt;empty()</p>
<p>若需要使用下标运算符，必须先提领pv。由于下标运算符的优先级较高，因此，pv提领操作的两边必须加上小括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pv &amp;&amp; ! pv-&gt;empty() &amp;&amp; ((*pv)[<span class="number">1</span>] == <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>欲对文件进行读写操作，得包含fstream头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>为了开启一个可供输出的文件，我们定义一个ofstream（供输出用的file stream）对象，并将文件名传入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以输出模式开启 seq_data.txt</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"seq_data.txt"</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>如果指定的文件并不存在，便会有一个文件被产生出来，并开启作为输出之后。如果指定的文件已经存在，这个文件会被开启作为输出之用，而文件中原已存在的数据会被丢弃。使用追加模式（append mode）开启文件，可以将新数据追加到原有数据的后面，原有数据不会丢弃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以追加模式（append mode）开启seq_data.txt</span></span><br><span class="line"><span class="comment">// 新数据会被追加到文件尾端</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"seq_data.txt"</span>,ios_base::app)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文件有可能开启失败。在进行写入操作之前，我们必须确定文件的确开启成功。最简单的办法便是检查class object 的真伪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 outfile 的计算结果为 false，表示此文件并未开启成功。</span></span><br><span class="line"><span class="keyword">if</span> (!outfile)</span><br></pre></td></tr></table></figure>

<p>如果文件未能成功开启，ofstream对象会被计算为false。本例中我们将信息写入cerr，告知用户此状况。cerr代表标准错误输出设备（standard error）。和cout一样，cerr将其输出结果导至用户的终端机。两者的唯一差别是，cerr的输出结果并无缓冲（buffered）情形——它会立即显示于用户终端机上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!outfile)</span><br><span class="line">      <span class="comment">// 因为某种原因，文件无法开启</span></span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Oops! Unable to save session data!\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     <span class="comment">// ok: outfile 开启成功，接下来将数据写入</span></span><br><span class="line">     oufile &lt;&lt; usr_name &lt;&lt; ‘ ’</span><br><span class="line">     &lt;&lt; num_tries&lt;&lt; <span class="string">' '</span></span><br><span class="line">     &lt;&lt; num_right &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>如果文件开启顺利，我们便将输出信息导至该文件，就像将信息写入cout及cerr这两个ostream对象一样。本例之中，我们将3个数值写入outfile，并以空格符区分后两个数值。endl 是事先定义好的所谓操控器（manipulator），由iostream library 提供。<br>操控器不会将数据写到iostream，而不会从中读取数据，其作用是在iostream上执行某些操作。endl会插入一个换行符，并清除缓冲区（output buffer）的内容。此外还有更多的操控器，如 hex(以16进制显示整数)、oct（以8进制显示整数）、setprecision(n)（设定浮点数显示精度为n）。</p>
<p>如果要开启一个可供读取的文件，可以定义一个ifstream（ input file stream）对象，并将文件名传入。如果文件未能开启，ifstream对象会被核定为false。如果成功，该文件的写入位置会被设定在起始处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以读取模式 （input mode）开启infile</span></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"seq_data.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> num_tries = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num_cor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (! infile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 由于某种原因，文件无法开启。。。</span></span><br><span class="line">    <span class="comment">// 我们将假设这是一位新用户。。。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ok ，读取这个文件的每一行</span></span><br><span class="line">    <span class="comment">// 检查这个用户曾经是否玩过这个程序</span></span><br><span class="line">    <span class="comment">// 每一行的检查格式是：</span></span><br><span class="line">            name num_tries num_correct</span><br><span class="line">    <span class="comment">// nt :猜过的总次数（num_tries)</span></span><br><span class="line">    <span class="comment">// nc:猜对的总次数（num_correct)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> nt;</span><br><span class="line">    <span class="keyword">int</span> nc;</span><br><span class="line">          <span class="keyword">while</span>(infile&gt;&gt;name)</span><br><span class="line">          &#123;</span><br><span class="line">          infile &gt;&gt; nt &gt;&gt;nc ;</span><br><span class="line">                <span class="keyword">if</span> (name == usr_name)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">//找到他了</span></span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">" Welcome back, "</span>&lt;&lt; usr_name</span><br><span class="line">                        &lt;&lt; <span class="string">" \n Your current score is  "</span>&lt;&lt; nc</span><br><span class="line">                        &lt;&lt; <span class="string">"out of "</span>&lt;&lt;nt&lt;&lt;<span class="string">"\n Good Luck!\n"</span>;</span><br><span class="line">                        num_tries = nt;</span><br><span class="line">                        num_cor = nc;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> while 循环的每次迭代都会读取文件的下一行内容。这样的操作会持续到文件尾端才结束。<br> <code>infile&gt;&gt;name</code>,这个语句的返回值即是从infile 读到的class object。一旦读到文件尾端，读入的class object 会被核定为false。因此我们可以在while循环的条件表达式中，以此作为结束条件：<br> <code>while(infile&gt;&gt;name)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile&gt;&gt;nt&gt;&gt;nc</span><br></pre></td></tr></table></figure>

<p>会先将用户猜过的总次数读到nt之中，再将用户猜对的总次数读到nc之中。</p>
<p>如果想要同时读写同一个文件，需要定义一个fstream对象，为了以追加模式（append mode）开启，我们得传入第二参数值 ios_base :: in | ios_base :: app :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"seq_data.txt"</span>,ios_base::in | ios_base::app)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (! iofile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 由于某些原因，文件无法开启……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开始读取之前，将文件重新定位至起始处</span></span><br><span class="line">    iofile.seekg(<span class="number">0</span>):</span><br><span class="line">    <span class="comment">// 其它部分都和先前讨论的相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以附加模式开启文件时，文件位置会位于尾端。如果我们没有先重新定位，就试着读取文件内容，那么立刻会遇到“读到文件尾”的状况。seekg()可将文件位置重新定位至文件的起始处。由于此文件是以追加模式开启，因此，任何写入操作都会将数据附加于文件最末端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/OpenCV-Chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/OpenCV-Chapter1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图像编程入门"><a href="#图像编程入门" class="headerlink" title="图像编程入门"></a>图像编程入门</h1><p>这样生成的图像由无符号字节（unsigned byte，C++中为unsigned char）构成，在OpenCV中用常量CV_8U 表示。另外，即使图像是作为灰度图像保存的，有时仍需要在读入时把它转换成三通道彩色图像。要实现这个功能，可把imread 函数的第二个参数设置为正数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取图像，并将其转换为三通道彩色图像</span></span><br><span class="line">image= cv::imread(<span class="string">"puppy.bmp"</span>, CV::IMREAD_COLOR);</span><br></pre></td></tr></table></figure>

<p>这样创建的图像中，每个像素有3个字节，OpenCV中用CV_8UC3表示。如果输入的图像是灰度图像，则三个通道的值相同。</p>
<p>如果要在读入的图像时采用文件本身的格式，只需把第二个参数设置为负数。</p>
<p>可用channels方法检查图像的通道数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This image has "</span> &lt;&lt; image.channels() &lt;&lt; <span class="string">" channel(s)."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>请注意，当用imread 打开路径指定不完整的图像时（前面例子的做法），imread 会自动采用默认目录。如果从控制台运行程序，默认目录显然就是当前控制台的目录；但是如果直接在IDE中运行程序，默认目录通常就是项目文件所在的目录。因此，要确保图像文件在正确的目录下。</p>
<p>当你用imshow 显示由整数（CV_16U 表示16 位无符号整数，CV_32S 表示32 位有符号整数）构成的图像时，图像每个像素的值会被除以256，以便能够在256 级灰度中显示。同样，在显示由浮点数构成的图像时，值的范围会被假设为0.0（显示黑色）~1.0（显示白色）。超出这个范围的值会显示为白色（大于1.0 的值）或黑色（小于0.0 的值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::flip(image,image,<span class="number">1</span>); <span class="comment">// 就地处理</span></span><br></pre></td></tr></table></figure>

<h3 id="关于Mat"><a href="#关于Mat" class="headerlink" title="关于Mat"></a>关于Mat</h3><p>cv::Mat 有两个必不可少的组成部分：一个头部和一个数据块。<br>头部包含了矩阵的所有相关信息（大小、通道数量、数据类型等），数据块包含了图像中所有像素的值。头部有一个指向数据块的指针，即data 属性。<br>cv::Mat 有一个很重要的属性，即只有在明确要求时，内存块才会被复制。实际上，大多数操作仅仅复制了cv::Mat 的头部，因此多个对象会指向同一个数据块。这种内存管理模式可以提高应用程序的运行效率，避免内存泄漏，但是我们必须了解它带来的后果。<br>新创建的cv::Mat 对象默认大小为0，但也可以指定一个初始大小，例如：<br>// 创建一个240 行×320 列的新图像<br>cv::Mat image1(240,320,CV_8U,100);</p>
<p>我们需要指定每个矩阵元素的类型，这里用CV_8U 表示每个像素对应1 字节（灰度图像），用字母U 表示无符号；你也可用字母S 表示有符号。对于彩色图像，你应该用三通道类型（CV_8UC3），也可以定义16 位和32 位的整数（有符号或无符号），例如CV_16SC3。我们甚至可以使用32 位和64 位的浮点数（例如CV_32F）。</p>
<p>图像（或矩阵）的每个元素都可以包含多个值（例如彩色图像中的三个通道），因此OpenCV引入了一个简单的数据结构cv::Scalar，用于在调用函数时传递像素值。该结构通常包含一个或三个值。如果要创建一个彩色图像并用红色像素初始化，可用如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个红色图像</span></span><br><span class="line"><span class="comment">// 通道次序是BGR</span></span><br><span class="line">cv::Mat(<span class="number">240</span>,<span class="number">320</span>,CV_8UC3,cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>))</span><br><span class="line"><span class="comment">//初始化灰度图像</span></span><br><span class="line">cv::<span class="function">Mat <span class="title">image2</span><span class="params">(<span class="number">240</span>,<span class="number">320</span>,CV_8UC3,cv::Scalar(<span class="number">100</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以随时用create 方法分配或重新分配图像的数据块。如果图像已被分配，其原来的内容会先被释放。出于对性能的考虑，如果新的尺寸和类型与原来的相同，就不会重新分配内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新分配一个新图像</span></span><br><span class="line"><span class="comment">//（仅在大小或类型不同时）</span></span><br><span class="line">image1.create(<span class="number">200</span>,<span class="number">200</span>,CV_8U);</span><br></pre></td></tr></table></figure>

<p>一旦没有了指向cv::Mat 对象的引用，分配的内存就会被自动释放。这一点非常方便，因为它避免了C++动态内存分配中经常发生的内存泄漏问题。这是OpenCV（从第2 版开始引入）中的一个关键机制，它的实现方法是通过cv::Mat 实现计数引用和浅复制。因此，当在两幅图像之间赋值时，图像数据（即像素）并不会被复制，此时两幅图像都指向同一个内存块。这同样适用于图像间的值传递或值返回。由于维护了一个引用计数器，因此只有当图像的所有引用都将释放或赋值给另一幅图像时，内存才会被释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有图像都指向同一个数据块</span></span><br><span class="line">cv::<span class="function">Mat <span class="title">image4</span><span class="params">(image3)</span></span>;</span><br><span class="line">image1= image3;</span><br></pre></td></tr></table></figure>

<p>对上面图像中的任何一个进行转换都会影响到其他图像。如果要对图像内容做一个深复制，你可以使用copyTo 方法，目标图像将会调用create 方法。另一个生成图像副本的方法是clone，即创建一个完全相同的新图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些图像是原始图像的新副本</span></span><br><span class="line">image3.copyTo(image2);</span><br><span class="line">cv::Mat image5= image3.clone();</span><br></pre></td></tr></table></figure>

<p>如果需要把一幅图像复制到另一幅图像中，且两者的数据类型不一定相同，那就要使用convertTo方法了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换成浮点型图像[0,1]</span></span><br><span class="line">image1.convertTo(image2,CV_32F,<span class="number">1</span>/<span class="number">255.0</span>,<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">//本例中的原始图像被复制进了一幅浮点型图像。这一方法包含两个可选参数：缩放比例和偏移量。需要注意的是，这两幅图像的通道数量必须相同。</span></span><br></pre></td></tr></table></figure>

<p>cv::Mat 对象的分配模型还能让程序员安全地编写返回一幅图像的函数（或类方法）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="function">Mat <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建图像</span></span><br><span class="line">cv::<span class="function">Mat <span class="title">ima</span><span class="params">(<span class="number">240</span>,<span class="number">320</span>,CV_8U,cv::Scalar(<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="comment">// 返回图像</span></span><br><span class="line"><span class="keyword">return</span> ima;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以从main 函数中调用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个灰度图像</span></span><br><span class="line">cv::Mat gray= function();</span><br></pre></td></tr></table></figure>

<p>运行这条语句后，就可以用变量gray 操作这个由function 函数创建的图像，而不需要额外分配内存了。正如前面解释的，从cv::Mat 实例到灰度图像实际上只是进行了一次浅复制。当局部变量ima 超出作用范围后，ima 会被释放。但是从相关引用计数器可以看出，另一个实例（即变量gray）引用了ima 内部的图像数据，因此ima 的内存块不会被释放。<br>请注意，在使用类的时候要特别小心，不要返回图像的类属性。下面的实现方法很容易引发错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="comment">// 图像属性</span></span><br><span class="line">cv::Mat ima;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 在构造函数中创建一幅灰度图像</span></span><br><span class="line">Test() : ima(<span class="number">240</span>,<span class="number">320</span>,CV_8U,cv::Scalar(<span class="number">100</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// 用这种方法回送一个类属性，这是一种不好的做法</span></span><br><span class="line">cv::<span class="function">Mat <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ima; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果某个函数调用了这个类的method，就会对图像属性进行一次浅复制。副本一旦被修改，class 属性也会被“偷偷地”修改，这会影响这个类的后续行为（反之亦然）。这违反了面向对象编程中重要的封装性原理。为了避免这种类型的错误，你需要将其改成返回属性的一个副本。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ol>
<li>输入和输出数组<br>在OpenCV 的文档中，很多方法和函数都使用cv::InputArray 类型作为输入参数。cv::InputArray 类型是一个简单的代理类，用来概括OpenCV 中数组的概念，避免同一个方法或函数因为使用了不同类型的输入参数而有多个版本。也就是说，你可以在参数中使用cv::Mat对象或者其他的兼容类型。因为它是一个输入数组，所以你必须确保函数不会修改这个数据结构。有趣的是，cv::InputArray 也能使用常见的std::vector 类来构造；也就是说，用这种方式构造的对象可以作为OpenCV 方法和函数的输入参数（但千万不要在自定义类和函数中使用这个类）。其他兼容的类型有cv::Scalar 和cv::Vec，后者将在下一章介绍。此外还有一个代理类cv::OutputArray，用来指定某些方法或函数的返回数组。</li>
<li>处理小矩阵<br>使用模板类cv::Matx和它的子类。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 3×3 双精度型矩阵</span></span><br><span class="line">cv::<span class="function">Matx33d <span class="title">matrix</span><span class="params">(<span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">3.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3×1 矩阵（即向量）</span></span><br><span class="line">cv::<span class="function">Matx31d <span class="title">vector</span><span class="params">(<span class="number">5.0</span>, <span class="number">1.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 相乘</span></span><br><span class="line">cv::Matx31d result = matrix*<span class="built_in">vector</span>;</span><br><span class="line"><span class="comment">//这些矩阵可以进行常见的数学运算。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="定义ROI"><a href="#定义ROI" class="headerlink" title="定义ROI"></a>定义ROI</h3><p>ROI 实际上就是一个cv::Mat 对象，它与它的父图像指向同一个数据缓冲区，并且在头部指明了ROI 的坐标。接着，可以用下面的方法插入标志：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在图像的右下角定义一个ROI</span></span><br><span class="line">cv::<span class="function">Mat <span class="title">imageROI</span><span class="params">(image,</span></span></span><br><span class="line"><span class="function"><span class="params">      cv::Rect(image.cols-logo.cols, <span class="comment">// ROI 坐标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  image.rows-logo.rows,</span></span></span><br><span class="line"><span class="function"><span class="params">                  logo.cols,logo.rows))</span></span>; <span class="comment">// ROI 大小</span></span><br><span class="line"><span class="comment">// 插入标志</span></span><br><span class="line">logo.copyTo(imageROI);</span><br></pre></td></tr></table></figure>

<p>这里的image 是目标图像，logo 是标志图像（相对较小）。<br>ROI 还可以用行和列的值域来描述。值域是一个从开始索引到结束索引的连续序列（不含开始值和结束值），可以用cv::Range 结构来表示这个概念。因此，一个ROI 可以用两个值域来定义。本例中的ROI 也可以定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageROI = image(cv::Range(image.rows - logo.rows,image.rows),</span><br><span class="line">                              cv::Range(image.cols - logo.cols,image.cols));</span><br></pre></td></tr></table></figure>

<p>cv::Mat 的operator()函数返回另一个cv::Mat 实例，可供后续使用。由于图像和ROI共享了同一块图像数据，因此ROI 的任何转变都会影响原始图像的相关区域。在定义ROI 时，数据并没有被复制，因此它的执行时间是固定的，不受ROI 尺寸的影响。要定义由图像中的一些行组成的ROI，可用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI= image.rowRange(start,end);</span><br></pre></td></tr></table></figure>

<p>与之类似，要定义由图像中一些列组成的ROI，可用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat imageROI= image.colRange(start,end);</span><br></pre></td></tr></table></figure>

<h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><p><strong>使用图像掩码</strong><br>函数或方法通常对图像中所有的像素进行操作，通过定义掩码可以限制这些函数或方法的作用范围。<br>掩码是一个8位图像，如果掩码中某个位置的值不为0，在这个位置上的操作就会起作用；如果掩码中某些像素位置的值为0，那么对图像中相应位置的操作将不起作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::namedWindow(<span class="string">"Image"</span>);</span><br><span class="line">	cv::Mat image = cv::imread(<span class="string">"E:\\image\\test\\5.jpg"</span>);</span><br><span class="line">	cv::Mat logo = cv::imread(<span class="string">"E:\\image\\images\\smalllogo.png"</span>);</span><br><span class="line">	<span class="comment">//定义ROI，在image的右下角</span></span><br><span class="line">	cv::<span class="function">Mat <span class="title">imageROI</span><span class="params">(image,</span></span></span><br><span class="line"><span class="function"><span class="params">		cv::Rect(image.cols - logo.cols,</span></span></span><br><span class="line"><span class="function"><span class="params">			image.rows - logo.rows,</span></span></span><br><span class="line"><span class="function"><span class="params">			logo.cols, logo.rows))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入logo</span></span><br><span class="line">	logo.copyTo(imageROI);</span><br><span class="line">	cv::imshow(<span class="string">"Image"</span>, image);</span><br><span class="line">	cv::waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//重新载入image</span></span><br><span class="line">	image = cv::imread(<span class="string">"E:\\image\\test\\5.jpg"</span>);</span><br><span class="line">	<span class="comment">//定义ROI，在image的右下角</span></span><br><span class="line">	imageROI = image(cv::Rect(image.cols - logo.cols, image.rows - logo.rows, logo.cols, logo.rows));</span><br><span class="line">	<span class="comment">//或者用值域</span></span><br><span class="line">	<span class="comment">//imageROI = image(cv::Range(image.cols - logo.col, image.cols),cv::Range(image.rows - logo.rows, image.rows));</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将logo用作掩码——必须为灰度图像</span></span><br><span class="line">	cv::<span class="function">Mat <span class="title">mask</span><span class="params">(logo)</span></span>;</span><br><span class="line">	<span class="comment">//插入标志，只复制掩码不为0 的位置</span></span><br><span class="line">	logo.copyTo(imageROI, mask);</span><br><span class="line">	cv::imshow(<span class="string">"Image"</span>, image);</span><br><span class="line">	cv::waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/林轩田-基石-Lecture1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/林轩田-基石-Lecture1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>学习是指通过观察积累经验来获取技能。<br>即 观察-&gt;学习-&gt;技能</p>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>机器学习是指机器从数据中通过积累、计算获得技能。</p>
<h4 id="技能statistics-many-useful-tools-for-ML"><a href="#技能statistics-many-useful-tools-for-ML" class="headerlink" title="技能statistics : many useful tools for ML"></a>技能statistics : many useful tools for ML</h4><p>技能：使得某项指标得到提升的能力。</p>
<h4 id="什么时候使用机器学习？"><a href="#什么时候使用机器学习？" class="headerlink" title="什么时候使用机器学习？"></a>什么时候使用机器学习？</h4><p>例子：定义一棵树。对于大家来说，看到一棵树一定能认出来它是一棵树，为什么？因为我们见过太多的树，并且掌握了树的特征，有枝干，有叶子，叶子通常是绿色的……，但是如果通过特定的规则去定义什么是树就比较难了，而这个时候使用机器学习来判断是不是一棵树就相对简单。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>无法人工编程的系统（如在火星上导航）</li>
<li>无法清晰地定义解决方案（语音，图像辨识）</li>
<li>需要快速响应，而人类无法达到的时候</li>
<li>面向大规模用户（如根据个人喜好来做推荐的系统）</li>
</ul>
<h4 id="机器学习的关键要素"><a href="#机器学习的关键要素" class="headerlink" title="机器学习的关键要素"></a>机器学习的关键要素</h4><ol>
<li>存在可学习的潜在模式，所以某个”表现指标“可以得到提升。</li>
<li>但是没有简单的编码定义</li>
<li>大量数据</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>unknow pattern to be learned &lt;=&gt; target function<br>hypothesis &lt;=&gt; skill</p>
<p>假设空间里包含的假设有好有坏（相对于目标函数），由算法来挑选最好的假设。<br><code>learning model = A and H</code></p>
<h4 id="机器学习进一步定义"><a href="#机器学习进一步定义" class="headerlink" title="机器学习进一步定义"></a>机器学习进一步定义</h4><p>机器学习：使用数据来计算与目标f最接近的假设g<br>即 数据-&gt;（A on H）-&gt; g: x-&gt;y<br>A 为算法，H 为假设空间，g 为假设空间中的某一假设</p>
<h4 id="数据挖掘（Data-Mining）"><a href="#数据挖掘（Data-Mining）" class="headerlink" title="数据挖掘（Data Mining）"></a>数据挖掘（Data Mining）</h4><p>use (huge) data to find property that is interesting</p>
<ul>
<li><p>如果”有趣的信息“与”接近目标的假设“一样，则DM=ML。</p>
</li>
<li><p>如果”有趣的信息“与”接近目标的假设“相关，则DM可以帮助ML，反之亦然。</p>
</li>
<li><p>传统的DM还关注在大规模数据集（库）进行有效计算，实际中ML、DM密不可分，很难区分。</p>
</li>
</ul>
<h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><p>compute something that shows intelligent behavior</p>
<p>g ~= f is something that shows intelligent behavior</p>
<p>ML can realize AI,among other routes<br>即ML是实现AI的一种方法</p>
<h4 id="Statistics-统计"><a href="#Statistics-统计" class="headerlink" title="Statistics 统计"></a>Statistics 统计</h4><p>use data to make inference about an unknown process<br>使用数据来做推论<br>g is an inference outcome; f is a something unknown —- statistics can be used to achieve ML</p>
<p>f 未知，可以将 g 当作推论，故统计可以用来实现机器学习</p>
<p>traditional statistics also focus on provable results with math assumptions,and less about computation</p>
<p>传统统计学也关注数学假设的可证明结果，而不是计算</p>
<p>statistics : many useful tools for ML</p>
<h4 id="Components-of-Machine-Learning"><a href="#Components-of-Machine-Learning" class="headerlink" title="Components of Machine Learning"></a>Components of Machine Learning</h4><p>A takes D and H to get g.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Keras FAQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Keras FAQ/" itemprop="url">Keras FAQ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="What-does-“sample”-“batch”-“epoch”-mean"><a href="#What-does-“sample”-“batch”-“epoch”-mean" class="headerlink" title="What does “sample”, “batch”, “epoch” mean?"></a>What does “sample”, “batch”, “epoch” mean?</h3><ul>
<li><h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h4><ul>
<li>样本，数据集中的一个元素，一条数据</li>
<li>例1：在卷积神经网络中，一张图片是一个样本</li>
<li>例2：在语音识别模型中，一段音频是一个样本</li>
</ul>
</li>
<li><h4 id="Batch："><a href="#Batch：" class="headerlink" title="Batch："></a>Batch：</h4><ul>
<li>批，含有N个样本的结合。批中每个样本都是独立并行处理的。训练期间，一个batch的结果只会用来更新一次模型。</li>
<li>一个<strong>batch</strong>的样本通常比单个输入更接近于总体输入数据的分布，batch越大就越近似。但是，使用batch将花费更长的时间来处理，并且仍然只更新模型一次。在推理时（evaluate/predict），建议在条件允许的情况下选择一个尽可能大的batch，（因为较大的batch通常评估/预测的速度会更快）。</li>
</ul>
</li>
<li><h4 id="Epoch："><a href="#Epoch：" class="headerlink" title="Epoch："></a>Epoch：</h4><ul>
<li>轮次，通常定义为“在整个数据集上的一轮迭代”，用于训练的不同阶段，有利于记录和定期评估。</li>
<li>当在Keras模型的<code>fit</code>方法中使用 <code>validation_data</code>或<code>validation_split</code>时，评估将在每个epoch结束时运行。</li>
<li>在Keras中，可以添加专门的用于在epoch结束时运行的<font color="#FF0000"> callbacks 回调</font>。例如学习率变化和模型检查点（保存）。</li>
</ul>
</li>
</ul>
<h3 id="How-can-I-save-a-Keras-model-（如何保存Keras模型？）"><a href="#How-can-I-save-a-Keras-model-（如何保存Keras模型？）" class="headerlink" title="How can I save a Keras model?（如何保存Keras模型？）"></a>How can I save a Keras model?（如何保存Keras模型？）</h3><h4 id="保存-加载整个模型（结构-权重-优化器状态）"><a href="#保存-加载整个模型（结构-权重-优化器状态）" class="headerlink" title="保存/加载整个模型（结构+权重+优化器状态）"></a>保存/加载整个模型（结构+权重+优化器状态）</h4><p><em>不推荐使用pickle或者cPickle来保存Keras模型。</em></p>
<p>可以使用<code>model.save(filepath)</code>将Keras模型保存到单个HDF5文件中，该文件将包含：</p>
<ul>
<li>模型的结构，允许重新创建模型</li>
<li>模型的权重</li>
<li>训练配置项（损失函数，优化器）</li>
<li>优化器状态，允许准确地从你上次结束的地方继续训练。</li>
</ul>
<p>可以使用<code>keras.model.load_model(filepath)</code>重新实例化模型。<code>load_model</code>还将负责使用保存的训练配置项来编译模型（除非模型从未编译过）。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import load_model</span><br><span class="line">model.save(&quot;my_model.h5&apos;) # creates a HDF5 file &apos;my_model.h5&apos;</span><br><span class="line">del model # deletes the existing model</span><br><span class="line"></span><br><span class="line"># returns a compiled model</span><br><span class="line"># identical to the previous one</span><br><span class="line">model = load_model(&apos;my_model.h5&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="只保存-加载模型的结构"><a href="#只保存-加载模型的结构" class="headerlink" title="只保存/加载模型的结构"></a>只保存/加载模型的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># save as JSON</span><br><span class="line">json_string = model.to_json()</span><br><span class="line"></span><br><span class="line"># save as YAML</span><br><span class="line">yaml_string = model.to_yaml()</span><br></pre></td></tr></table></figure>

<p>生成的JSON/YAML文件是人类可读的，且可根据需要手动进行修改。</p>
<p>可从这些数据建立一个新模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># model reconstruction from JSON:</span><br><span class="line">from keras.models import model_from_json</span><br><span class="line">model = model_from_json(json_string)</span><br><span class="line"></span><br><span class="line"># model reconstruction from YAML:</span><br><span class="line">from keras.models import model_from_yaml</span><br><span class="line">model = mode_from_yaml(yaml_string)</span><br></pre></td></tr></table></figure>

<h4 id="只保存-加载模型的权重"><a href="#只保存-加载模型的权重" class="headerlink" title="只保存/加载模型的权重"></a>只保存/加载模型的权重</h4><p><code>model.save_weights(&#39;my_model_weights.h5)</code><br>假设你有用于实例化模型的代码，则可以将保存的权重加载到具有相同结构的模型中。<br><code>model.load_weights(&#39;my_model_weights.h5&#39;)</code><br>如果你需要将权重加载到不同的结构（有一些共同层）的模型中，例如微调或迁移学习，则可以按层的名字来加载权重：<br><code>model.load_weights(&#39;my_model_weights.h5,by_name=True)</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Assuming the original model looks like this:</span><br><span class="line">    model = Sequential()</span><br><span class="line">    model.add(Dense(2,input_dim=3,name=&apos;dense_1&apos;))</span><br><span class="line">    model.add(Dense(3,name=&apos;dense_2&apos;))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># new model</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(2,input_dim=3,name=&apos;dense_1&apos;)) # will be loaded</span><br><span class="line">model.add(Dense(10,name=&apos;new_dense&apos;)) # will not be loaded</span><br><span class="line"></span><br><span class="line"># load weights from first model; will only affect the first layer,dense_1.</span><br><span class="line">model.load_weights(fname,by_name=True)</span><br></pre></td></tr></table></figure>

<h4 id="操作已保存的模型中的自定义层（或其他自定义对象）"><a href="#操作已保存的模型中的自定义层（或其他自定义对象）" class="headerlink" title="操作已保存的模型中的自定义层（或其他自定义对象）"></a>操作已保存的模型中的自定义层（或其他自定义对象）</h4><p>如果要加载的模型中包含自定义层或其他自定义类或函数，则可以通过<code>custom_object</code>参数将它们传递给加载机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import load_model</span><br><span class="line"># Assuming your model includes instance of an &quot;AttentionLayer&quot; class</span><br><span class="line">model = load_model(&apos;my_model.h5&apos;,custom_objects=&#123;&apos;AttenstionLayer`:AttentionLayer&#125;));</span><br></pre></td></tr></table></figure>

<p>或者可以使用<font color="red">自定义对象作用域：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from kreas.utils import CustomObjectScope</span><br><span class="line">with CustomObjectScope(&#123;&apos;AttentionLayer&apos;:AttentionLayer&#125;):</span><br><span class="line">    model = load_model(&apos;my_model.h5&apos;)</span><br></pre></td></tr></table></figure>

<p>自定义对象的处理与<code>load_model</code>,<code>model_from_json</code>,<code>model_from_yaml</code>的工作方式相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import model_from_json</span><br><span class="line">model = model_from_json(json_string,custom_objects=&#123;&apos;AttentionLayer&apos;:AttentionLayer&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Why-is-the-training-loss-much-higher-than-the-testing-loss-为什么训练误差比测试误差高很多？"><a href="#Why-is-the-training-loss-much-higher-than-the-testing-loss-为什么训练误差比测试误差高很多？" class="headerlink" title="Why is the training loss much higher than the testing loss?(为什么训练误差比测试误差高很多？)"></a>Why is the training loss much higher than the testing loss?(为什么训练误差比测试误差高很多？)</h3><p>Keras模型有训练和测试两种模式。正则化机制，如 Dropout 和 L1/L2 权重正则化，在测试时是关闭的。<br>此外，训练损失是每批训练数据的平均损失。因为模型是随着时间变化的，所以一个epoch中的第一批数据的损失通常比最后一批的损失要高。测试误差是模型在一个epoch训练完成后计算的，因而误差较小。</p>
<h3 id="How-can-I-obtain-the-output-of-an-intermediate-layer-如何获取中间层的输出？"><a href="#How-can-I-obtain-the-output-of-an-intermediate-layer-如何获取中间层的输出？" class="headerlink" title="How can I obtain the output of an intermediate layer?(如何获取中间层的输出？)"></a>How can I obtain the output of an intermediate layer?(如何获取中间层的输出？)</h3><p>一种简单的方法是创建一个新的<code>Model</code>（模型）来输出感兴趣的层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Model</span><br><span class="line">model = ... # create the original model</span><br><span class="line">layer_name = &apos;my_layer&apos;</span><br><span class="line">intermediate_layer_model = Model(inputs=model.input,</span><br><span class="line">                                 output=model.get_layer(layer_name).output)</span><br><span class="line">intermediate_output=intermediate_layer_model.predict(data)</span><br></pre></td></tr></table></figure>

<p>或者创建一个Keras函数，该函数在给定输入的情况下返回某个层的输出，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from keras import backend as K</span><br><span class="line"></span><br><span class="line"># with a Sequential model</span><br><span class="line">get_3rd_layer_output = K.function([model.layers[0].input],</span><br><span class="line">                                  [model.layers[3].output])</span><br><span class="line">layer_output = get_3rd_layer_output([x])[0]</span><br></pre></td></tr></table></figure>

<p>或者，可以直接建立一个Theano或TensorFlow函数。<br>注意，如果你的模型在训练和测试阶段有不同的行为（例如，使用 <code>Dropout</code>, <code>BatchNormalization</code> 等），则需要将学习阶段标志传递给你的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_3rd_layer_output = K.function([model.layers[0].input, K.learning_phase()],</span><br><span class="line">                                  [model.layers[3].output])</span><br><span class="line"># output in test mode = 0  测试模式 = 0 时的输出</span><br><span class="line">layer_output = get_3rd_layer_output([x,0])[0]</span><br><span class="line"></span><br><span class="line"># output in train mode = 1</span><br><span class="line">layer_output = get_3rd_layer_output([x,1])[0]</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-Keras-with-datasets-that-don’t-fit-in-memory-（如何用-Keras-处理超过内存的数据集？）"><a href="#How-can-I-use-Keras-with-datasets-that-don’t-fit-in-memory-（如何用-Keras-处理超过内存的数据集？）" class="headerlink" title="How can I use Keras with datasets that don’t fit in memory? （如何用 Keras 处理超过内存的数据集？）"></a>How can I use Keras with datasets that don’t fit in memory? （如何用 Keras 处理超过内存的数据集？）</h3><p>可以使用 <code>model.train_on_batch(x，y)</code> 和 <code>model.test_on_batch(x，y)</code> 进行批量训练与测试。</p>
<p>或者，你可以编写一个生成批处理训练数据的生成器，然后使用 <code>model.fit_generator(data_generator，steps_per_epoch，epochs)</code> 方法。</p>
<h3 id="How-can-I-interrupt-training-when-the-validation-loss-isn’t-decreasing-anymore-在验证集的误差不再下降时，如何中断训练？"><a href="#How-can-I-interrupt-training-when-the-validation-loss-isn’t-decreasing-anymore-在验证集的误差不再下降时，如何中断训练？" class="headerlink" title="How can I interrupt training when the validation loss isn’t decreasing anymore? 在验证集的误差不再下降时，如何中断训练？"></a>How can I interrupt training when the validation loss isn’t decreasing anymore? 在验证集的误差不再下降时，如何中断训练？</h3><p>可以使用<code>EarlyStopping</code>回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.callbacks import EarlyStopping</span><br><span class="line">early_stopping = EarlyStopping(monitor=&apos;val_loss&apos;,patience=2)</span><br><span class="line">model.fit(x,y,validation_split=0.2,callbacks=[early_stopping])</span><br></pre></td></tr></table></figure>

<h3 id="How-is-the-validation-split-computed-验证集划分是如何计算的？"><a href="#How-is-the-validation-split-computed-验证集划分是如何计算的？" class="headerlink" title="How is the validation split computed?(验证集划分是如何计算的？)"></a>How is the validation split computed?(验证集划分是如何计算的？)</h3><p>如果您将 <code>model.fit</code> 中的 <code>validation_split</code> 参数设置为 0.1，那么使用的验证数据将是最后 10％ 的数据。如果设置为 0.25，就是最后 25% 的数据。注意，在提取分割验证集之前，数据不会被混洗，因此验证集仅仅是传递的输入中最后一个 x％ 的样本。</p>
<p>所有 epoch 都使用相同的验证集（在同一个 <code>fit</code> 中调用）。</p>
<h3 id="Is-the-data-shuffled-during-training-在训练过程中数据是否会混洗？"><a href="#Is-the-data-shuffled-during-training-在训练过程中数据是否会混洗？" class="headerlink" title="Is the data shuffled during training? (在训练过程中数据是否会混洗？)"></a>Is the data shuffled during training? (在训练过程中数据是否会混洗？)</h3><p>是的，如果 <code>model.fit</code>中的 <code>shuffle</code>参数设置为 <code>True</code>（默认值），则训练数据将在每个 epoch 混洗。<br>验证集永远不会混洗。</p>
<h3 id="How-can-I-record-the-training-validation-loss-accuracy-at-each-epoch-如何在每个-epoch-后记录训练集和验证集的误差和准确率？"><a href="#How-can-I-record-the-training-validation-loss-accuracy-at-each-epoch-如何在每个-epoch-后记录训练集和验证集的误差和准确率？" class="headerlink" title="How can I record the training / validation loss / accuracy at each epoch?(如何在每个 epoch 后记录训练集和验证集的误差和准确率？)"></a>How can I record the training / validation loss / accuracy at each epoch?(如何在每个 epoch 后记录训练集和验证集的误差和准确率？)</h3><p><code>model.fit</code> 方法返回一个 <code>History</code> 回调，它具有包含连续误差的列表和其他度量的 <code>history</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hist = model.fit(x,y,validation_split=0.2)</span><br><span class="line">print(hist.history)</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-“freeze”-Keras-layers-如何「冻结」网络层？"><a href="#How-can-I-“freeze”-Keras-layers-如何「冻结」网络层？" class="headerlink" title="How can I “freeze” Keras layers? (如何「冻结」网络层？)"></a>How can I “freeze” Keras layers? (如何「冻结」网络层？)</h3><p>「冻结」一个层意味着将其排除在训练之外，即其权重将永远不会更新。这在微调模型或使用固定的词向量进行文本输入中很有用。<br>您可以将 <code>trainable</code> 参数（布尔值）传递给一个层的构造器，以将该层设置为不可训练的：</p>
<p><code>frozen_layer = Dense(32,trainable=False)</code></p>
<p>另外，可以在实例化之后将网络层的 <code>trainable</code> 属性设置为 <code>True</code> 或 <code>False</code>。为了使之生效，在修改 <code>trainable</code> 属性之后，需要在模型上调用 <code>compile()</code>。这是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = Input(shape=(32,))</span><br><span class="line">layer = Dense(32)</span><br><span class="line">layer.trainable = Flase</span><br><span class="line">y = layer(x)</span><br><span class="line"></span><br><span class="line">frozen_model = Model(x,y)</span><br><span class="line"># 在下面的模型中，训练期间不会更新层的权重</span><br><span class="line">frozen_model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;mse&apos;)</span><br><span class="line"></span><br><span class="line">layer.trainable = True</span><br><span class="line">trainable_model = Model(x,y)</span><br><span class="line"># 使用这个模型，训练期间 `layer` 的权重将被更新</span><br><span class="line"># (这也会影响上面的模型，因为它使用了同一个网络层实例)</span><br><span class="line">trainable_model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;mse&apos;)</span><br><span class="line"></span><br><span class="line">frozen_model.fit(data,labels)  # 这不会更新 `layer` 的权重</span><br><span class="line">trainable_model.fit(data,labels) # 这会更新 &apos;layer&apos; 的权重</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-stateful-RNNs-如何使用有状态-RNN-stateful-RNNs"><a href="#How-can-I-use-stateful-RNNs-如何使用有状态-RNN-stateful-RNNs" class="headerlink" title="How can I use stateful RNNs? (如何使用有状态 RNN (stateful RNNs)?)"></a>How can I use stateful RNNs? (如何使用有状态 RNN (stateful RNNs)?)</h3><p>使 RNN 具有状态意味着每批样本的状态将被重新用作下一批样本的初始状态。<br>当使用有状态 RNN 时，假定：</p>
<ul>
<li>所有的批次都有相同数量的样本</li>
<li>如果 <code>x1</code> 和 <code>x2</code> 是连续批次的样本，则 <code>x2[i]</code> 是 <code>x1[i]</code> 的后续序列，对于每个 <code>i</code>。</li>
</ul>
<p>要在 RNN 中使用状态，你需要:</p>
<ul>
<li>通过将 <code>batch_size</code> 参数传递给模型的第一层来显式指定你正在使用的批大小。例如，对于 10 个时间步长的 32 样本的 batch，每个时间步长具有 16 个特征，<code>batch_size = 32</code>。</li>
<li>在 RNN 层中设置 <code>stateful = True</code>。</li>
<li>在调用 <code>fit()</code> 时指定 <code>shuffle = False</code>。</li>
</ul>
<p>重置累积状态：</p>
<ul>
<li>使用 <code>model.reset_states()</code> 来重置模型中所有层的状态</li>
<li>使用 <code>layer.reset_states()</code> 来重置指定有状态 RNN 层的状态</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x # 输入数据，(32,21,16)</span><br><span class="line"># 将步长为10的序列输入到模型中</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(32,input_shape=(10,16),batch_size=32,stateful=True))</span><br><span class="line">model.add(Dense(16,activation=&apos;softmax&apos;))</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;categorical_crossentropy&apos;)</span><br><span class="line"></span><br><span class="line"># 训练网络，根据给定的前 10 个时间步，来预测第 11 个时间步：</span><br><span class="line">model.train_on_batch(x[:,:10,:],np.reshape(x[:,10,:],(32,16)))</span><br><span class="line"></span><br><span class="line"># 网络的状态已经改变。我们可以提供后续序列：</span><br><span class="line">model.train_on_batch(x[:, 10:20, :], np.reshape(x[:, 20, :], (32, 16)))</span><br><span class="line"></span><br><span class="line"># 重置 LSTM 层的状态：</span><br><span class="line">model.reset_states()</span><br><span class="line"></span><br><span class="line"># 另一种重置方法：</span><br><span class="line">model.layers[0].reset_states()</span><br></pre></td></tr></table></figure>

<p>请注意，<code>predict</code>, <code>fit</code>, <code>train_on_batch</code>, <code>predict_classes</code> 等方法全部都会更新模型中有状态层的状态。这使你不仅可以进行有状态的训练，还可以进行有状态的预测。</p>
<h3 id="How-can-I-remove-a-layer-from-a-Sequential-model-如何从-Sequential-模型中移除一个层？"><a href="#How-can-I-remove-a-layer-from-a-Sequential-model-如何从-Sequential-模型中移除一个层？" class="headerlink" title="How can I remove a layer from a Sequential model? (如何从 Sequential 模型中移除一个层？)"></a>How can I remove a layer from a Sequential model? (如何从 Sequential 模型中移除一个层？)</h3><p>可以通过调用<code>.pop()</code>来删除 <code>Sequential</code>模型中最后添加的层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(32,activation=&apos;relu&apos;,input_dim=784))</span><br><span class="line">model.add(Dense(32,activation=&apos;relu&apos;))</span><br><span class="line">print(len(model.layers)) # &quot;2&quot;</span><br><span class="line"></span><br><span class="line">model.pop()</span><br><span class="line">print(len(model.layers)) #&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-pre-trained-models-in-Keras-如何在-Keras-中使用预训练的模型？"><a href="#How-can-I-use-pre-trained-models-in-Keras-如何在-Keras-中使用预训练的模型？" class="headerlink" title="How can I use pre-trained models in Keras? (如何在 Keras 中使用预训练的模型？)"></a>How can I use pre-trained models in Keras? (如何在 Keras 中使用预训练的模型？)</h3><p>Keras提供了以下图像分类模型的代码和预训练的权重：</p>
<ul>
<li>Xception</li>
<li>VGG16</li>
<li>VGG19</li>
<li>ResNet50</li>
<li>Inception v3</li>
<li>Inception-ResNet v2</li>
<li>MobileNet v1</li>
<li>DenseNet</li>
<li>NASNet</li>
<li>MobileNet v2<br>可以使用<code>keras.applications</code>将它们导入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from keras.applications.xception import Xception</span><br><span class="line">from keras.applications.vgg16 import VGG16</span><br><span class="line">from keras.applications.vgg19 import VGG19</span><br><span class="line">from keras.applications.resnet import ResNet50</span><br><span class="line">from keras.applications.resnet import ResNet101</span><br><span class="line">from keras.applications.resnet import ResNet152</span><br><span class="line">from keras.applications.resnet_v2 import ResNet50V2</span><br><span class="line">from keras.applications.resnet_v2 import ResNet101V2</span><br><span class="line">from keras.applications.resnet_v2 import ResNet152V2</span><br><span class="line">from keras.applications.resnext import ResNeXt50</span><br><span class="line">from keras.applications.resnext import ResNeXt101</span><br><span class="line">from keras.applications.inception_v3 import InceptionV3</span><br><span class="line">from keras.applications.inception_resnet_v2 import InceptionResNetV2</span><br><span class="line">from keras.applications.mobilenet import MobileNet</span><br><span class="line">from keras.applications.mobilenet_v2 import MobileNetV2</span><br><span class="line">from keras.applications.densenet import DenseNet121</span><br><span class="line">from keras.applications.densenet import DenseNet169</span><br><span class="line">from keras.applications.densenet import DenseNet201</span><br><span class="line">from keras.applications.nasnet import NASNetLarge</span><br><span class="line">from keras.applications.nasnet import NASNetMobile</span><br><span class="line"></span><br><span class="line">model = VGG16(weights=&apos;imagenet&apos;, include_top=True)</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-use-HDF5-inputs-with-Keras-如何在-Keras-中使用-HDF5-输入？"><a href="#How-can-I-use-HDF5-inputs-with-Keras-如何在-Keras-中使用-HDF5-输入？" class="headerlink" title="How can I use HDF5 inputs with Keras? (如何在 Keras 中使用 HDF5 输入？)"></a>How can I use HDF5 inputs with Keras? (如何在 Keras 中使用 HDF5 输入？)</h3><p>可以使用 <code>keras.utils.io_utils</code> 中的<code>HDF5Matrix</code> 类。有关详细信息，请参阅 HDF5Matrix文档。<br>也可以直接使用 HDF5 数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import h5py</span><br><span class="line">with h5py.File(&apos;input/file.hdf5&apos;,&apos;r&apos;) as f:</span><br><span class="line">      x_data = f[&apos;x_data&apos;]</span><br><span class="line">      model.predict(x_data)</span><br></pre></td></tr></table></figure>

<h3 id="Where-is-the-Keras-configuration-file-stored-Keras-配置文件保存在哪里？"><a href="#Where-is-the-Keras-configuration-file-stored-Keras-配置文件保存在哪里？" class="headerlink" title="Where is the Keras configuration file stored? (Keras 配置文件保存在哪里？)"></a>Where is the Keras configuration file stored? (Keras 配置文件保存在哪里？)</h3><p>所有 Keras 数据存储的默认目录是：<br><code>$HOME/.keras/</code><br>注意，Windows 用户应该将 <code>$HOME</code> 替换为<code>%USERPROFILE%</code>。如果 Keras 无法创建上述目录（例如，由于权限问题），则使用<code>/tmp/.keras/</code>作为备份。<br>Keras配置文件是存储在 <code>$HOME/.keras/keras.json</code> 中的 JSON 文件。默认的配置文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;image_data_format&quot;: &quot;channels_last&quot;,</span><br><span class="line">    &quot;epsilon&quot;: 1e-07,</span><br><span class="line">    &quot;floatx&quot;: &quot;float32&quot;,</span><br><span class="line">    &quot;backend&quot;: &quot;tensorflow&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它包含以下字段：</p>
<p>图像处理层和实用程序所使用的默认值图像数据格式（<code>channels_last</code> 或 <code>channels_first</code>）。<br>用于防止在某些操作中被零除的 <code>epsilon</code> 模糊因子。<br>默认浮点数据类型。<br>默认后端。详见 backend 文档。<br>同样，缓存的数据集文件（如使用 <code>get_file()</code>下载的文件）默认存储在<code>$HOME/.keras/datasets/</code> 中。</p>
<h3 id="How-can-I-obtain-reproducible-results-using-Keras-during-development-如何在-Keras-开发过程中获取可复现的结果？"><a href="#How-can-I-obtain-reproducible-results-using-Keras-during-development-如何在-Keras-开发过程中获取可复现的结果？" class="headerlink" title="How can I obtain reproducible results using Keras during development? (如何在 Keras 开发过程中获取可复现的结果？)"></a>How can I obtain reproducible results using Keras during development? (如何在 Keras 开发过程中获取可复现的结果？)</h3><p>在模型的开发过程中，能够在一次次的运行中获得可复现的结果，以确定性能的变化是来自模型还是数据集的变化，或者仅仅是一些新的随机样本点带来的结果，有时候是很有用处的。</p>
<p>首先，你需要在程序启动之前将 <code>PYTHONHASHSEED</code> 环境变量设置为 0（不在程序本身内）。对于 Python 3.2.3 以上版本，它对于某些基于散列的操作具有可重现的行为是必要的（例如，集合和字典的 item 顺序，请参阅 Python 文档和 issue #2280 获取更多详细信息）。设置环境变量的一种方法是，在这样启动 python 时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat test_hash.py</span><br><span class="line">print(hash(&quot;keras&quot;))</span><br><span class="line">$ python3 test_hash.py                  # 无法复现的 hash (Python 3.2.3+)</span><br><span class="line">-8127205062320133199</span><br><span class="line">$ python3 test_hash.py                  # 无法复现的 hash (Python 3.2.3+)</span><br><span class="line">3204480642156461591</span><br><span class="line">$ PYTHONHASHSEED=0 python3 test_hash.py # 可复现的 hash</span><br><span class="line">4883664951434749476</span><br><span class="line">$ PYTHONHASHSEED=0 python3 test_hash.py # 可复现的 hash</span><br><span class="line">4883664951434749476</span><br></pre></td></tr></table></figure>

<p>此外，当使用 TensorFlow 后端并在 GPU 上运行时，某些操作具有非确定性输出，特别是<code>tf.reduce_sum()</code>。这是因为 GPU 并行运行许多操作，因此并不总能保证执行顺序。由于浮点数的精度有限，即使添加几个数字，也可能会产生略有不同的结果，具体取决于添加它们的顺序。你可以尝试避免某些非确定性操作，但有些操作可能是由 TensorFlow 在计算梯度时自动创建的，因此在 CPU 上运行代码要简单得多。为此，你可以将<code>CUDA_VISIBLE_DEVICES</code>环境变量设置为空字符串，例如：<br><code>$ CUDA_VISIBLE_DEVICES=&quot;&quot; PYTHONHASHSEED=0 python your_program.py</code></p>
<p>下面的代码片段提供了一个如何获得可复现结果的例子 - 针对 Python 3 环境的 TensorFlow 后端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import random as rn</span><br><span class="line"># 以下是 Numpy 在一个明确的初始状态生成固定随机数字所必需的。</span><br><span class="line">np.random.seed(42)</span><br><span class="line"># 强制 TensorFlow 使用单线程。</span><br><span class="line"># 多线程是结果不可复现的一个潜在因素。</span><br><span class="line"># 更多详情，见: https://stackoverflow.com/questions/42022950/</span><br><span class="line">session_conf = tf.ConfigProto(intra_op_parallelism_threads=1,</span><br><span class="line">                                              inter_op_parallelism_threads=1)</span><br><span class="line">from keras import backend as K</span><br><span class="line"># `tf.set_random_seed()` 将会以 TensorFlow 为后端，</span><br><span class="line"># 在一个明确的初始状态下生成固定随机数字。</span><br><span class="line"># 更多详情，见: https://www.tensorflow.org/api_docs/python/tf/set_random_seed</span><br><span class="line">tf.set_random_seed(1234)</span><br><span class="line">sess = tf.Session(graph=tf.get_default_graph(),config=session_conf)</span><br><span class="line">K.set_session(sess)</span><br><span class="line"># Rest of code follows ...</span><br></pre></td></tr></table></figure>

<h3 id="How-can-I-install-HDF5-or-h5py-to-save-my-models-in-Keras-如何在-Keras-中安装-HDF5-或-h5py-来保存我的模型？"><a href="#How-can-I-install-HDF5-or-h5py-to-save-my-models-in-Keras-如何在-Keras-中安装-HDF5-或-h5py-来保存我的模型？" class="headerlink" title="How can I install HDF5 or h5py to save my models in Keras? (如何在 Keras 中安装 HDF5 或 h5py 来保存我的模型？)"></a>How can I install HDF5 or h5py to save my models in Keras? (如何在 Keras 中安装 HDF5 或 h5py 来保存我的模型？)</h3><p>为了将你的 Keras 模型保存为 HDF5 文件，例如通过<code>keras.callbacks.ModelCheckpoint</code>，Keras 使用了 h5py Python 包。h5py 是 Keras 的依赖项，应默认被安装。在基于 Debian 的发行版本上，你需要再额外安装 <code>libhdf5</code>：</p>
<p><code>sudo apt-get install libhdf5-serial-dev</code><br>如果你不确定是否安装了 h5py，则可以打开 Python shell 并通过下面的命令加载模块<br><code>import h5py</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/小球回弹/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/小球回弹/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="小球回弹"><a href="#小球回弹" class="headerlink" title="小球回弹"></a>小球回弹</h3><p>小球回弹，“弹跳性”系数为0.6，根据用户的输入高度和回弹次数来输出小球运动的总距离。<br>思路：<br>若小球没有回弹，则小球运动的总距离即为初始高度。有回弹的话，小球每次回弹以后，高度变为上一次高度与“弹跳性”系数的乘积，小球每次回弹运动的距离为当前高度与回弹高度的和。<br>待改进：<br>首先即想到了递归，但是想不明白，日后再改！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def ball(height, num):</span><br><span class="line">    # backDis = height * 0.6</span><br><span class="line">    # totalDis = height + backDis</span><br><span class="line">    totalDis = 0</span><br><span class="line">    if num == 0:</span><br><span class="line">        return height</span><br><span class="line">    else:</span><br><span class="line">        for i in range(1, num+1):</span><br><span class="line">            backDis = height * 0.6</span><br><span class="line">            thisDis = height + backDis</span><br><span class="line">            height = backDis</span><br><span class="line">            totalDis += thisDis</span><br><span class="line"></span><br><span class="line">    return totalDis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    height = int(input(&quot;请输入高度：&quot;))</span><br><span class="line">    num = int(input(&quot;请输入回弹次数：&quot;))</span><br><span class="line">    print(ball(height, num))</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Python数据结构第一章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Python数据结构第一章/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Python-数据结构第一章"><a href="#Python-数据结构第一章" class="headerlink" title="Python 数据结构第一章"></a>Python 数据结构第一章</h2><h3 id="编写新的函数"><a href="#编写新的函数" class="headerlink" title="编写新的函数"></a>编写新的函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数头下方使用带有”””的字符串，这是一个文档字符串（docstring）。就像是函数中的注释，用户输入help(函数名)的时候，将显示这个字符串。<br>当一个函数不包含return语句时，它在执行完最后一条语句时，会自动地返回一个None值。<br>在模块中，可以按照任意顺序来定义函数，只要函数在被编译之前，不会真正地去执行函数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first() # Raises a NameError(function undefined yet)</span><br><span class="line"></span><br><span class="line">def first():</span><br><span class="line">      second()  # Not an error, because not actually</span><br><span class="line">def second():</span><br><span class="line">      print(&quot;Calling second.&quot;)</span><br><span class="line">first() # Here is where the call should go.</span><br></pre></td></tr></table></figure>

<p>这个例子中，second函数似乎在定义它之前就调用了，但实际上知道调用函数first的时候，才真正调用了second，而这个时候，这两个函数都定义过了。<br>可以使用<parameter name> = <default value>的形式，带上为参数指定的默认值，从而将参数指定为可选的。在参数列表中，必需的参数（不带默认值的参数）必须要放在可选的参数之前。</default></parameter></p>
<h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><p>递归函数必须至少包含一条选择语句。这条语句检查base case，来判断是停止还是继续递归。<br>迭代算法转换为一个递归函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def displayRange(lower,upper):</span><br><span class="line">      &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;</span><br><span class="line">      while lower &lt;= upper:</span><br><span class="line">              print(lower)</span><br><span class="line">              lower = lower + 1</span><br></pre></td></tr></table></figure>

<p>如何转换？注意两点：</p>
<ul>
<li>当 lower  &lt;= upper 的时候，循环体继续执行：</li>
<li>当函数执行的时候，lower增加1，但是upper不变。<br>  等价的递归函数可以执行类似的基本操作，但是，用一条if语句替代了循环，用函数的递归替代了复制语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def displayRange(lower,upper):</span><br><span class="line">    &quot;&quot;&quot;Outputs the numbers from lower to upper.&quot;&quot;&quot;</span><br><span class="line">    if lower &lt;= upper:</span><br><span class="line">        print(lower)</span><br><span class="line">        displayRange(lower+1,upper)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>大多数递归函数都至少接受一个参数。这个数据值测试结束递归过程的基本条件。在每一个递归步骤之前，也会以某种方式修改这个值。每次对数据值的修改，都应该会产生一个新的数据值，以允许函数最终达到基本条件。上面例子中，在每一次递归调用之前，将参数lower的值增加1，以使得其最终能够超过参数upper的值。<br>例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ourSum(lower,upper):</span><br><span class="line">      &quot;&quot;&quot;Return the sum of the numbers from lower thru upper.&quot;&quot;&quot;</span><br><span class="line">      if lower &gt; upper:</span><br><span class="line">          return 0</span><br><span class="line">      else:</span><br><span class="line">          return lower + ourSum(lower+1, upper)</span><br></pre></td></tr></table></figure>

<p>跟踪其调用情况来更好地理解递归的工作方式：添加一个参数表示缩进的边距，并且添加输出语句来跟踪每次调用的时候两个参数的值和返回的值。每次调用的第一条语句会计算缩进的边距，然后在输出两个参数的时候使用它。在每次调用返回之前，也会使用该缩进把计算所得到的值输出出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def ourSum(lower,upper,margin=0):</span><br><span class="line">    &quot;&quot;&quot;Returns the sum of the numbers from lower to upper,</span><br><span class="line">    and outputs a trace of the arguments and return values</span><br><span class="line">    on each call.&quot;&quot;&quot;</span><br><span class="line">    blanks = &quot; &quot; * margin</span><br><span class="line">    print(blanks,lower,upper)</span><br><span class="line">    if lower &gt; upper:</span><br><span class="line">        print(blanks, 0)</span><br><span class="line">    else:</span><br><span class="line">        result = lower + ourSum(lower + 1,upper, margin + 4)</span><br><span class="line">        print(blanks, result)</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h4 id="嵌套的函数定义"><a href="#嵌套的函数定义" class="headerlink" title="嵌套的函数定义"></a>嵌套的函数定义</h4><p>可以在一个函数的语句序列之中，嵌套其他函数的定义。考虑递归函数factorial的如下两个定义，第一个定义使用了一个嵌套的辅助函数，来用必需的参数执行递归。第二个定义给定了第二个参数一个默认值，从而简化了设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># First definition</span><br><span class="line">def factorial(n):</span><br><span class="line">    &quot;&quot;&quot;Returns the factorial of n.&quot;&quot;&quot;</span><br><span class="line">    def recurse(n, product):</span><br><span class="line">        if n == 1:return product</span><br><span class="line">        else: return recurse(n-1, n * product)</span><br><span class="line">    recurse(n,1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Second definition</span><br><span class="line">def factorial(n,product = 1):</span><br><span class="line">    &quot;&quot;&quot;Returns the factorial of n.&quot;&quot;&quot;</span><br><span class="line">    if n == 1 : return product</span><br><span class="line">    else: return factorial(n - 1 ,n *product)</span><br></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>Python 函数都是第一类的数据对象。这意味着，可将函数赋值给变量，保存到数据结构中，作为参数传递给其他函数，以及当作其他函数的值返回。<br>高阶函数（high-order function）：接受另一个函数作为参数，并且以某种方式应用该函数。<br>Python包含了内建的高阶函数，如map和filter，它们对于处理可迭代的对象很有用。<br>map 函数接受一个函数和一个可迭代对象作为参数，并且返回另一个可迭代对象。后者是对第一个可迭代对象中的每一项应用参数函数而得到的另一个可迭代对象。简而言之，map实际上将一个可迭代对象中的每一项都转换了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建了包含字符串的可迭代对象</span><br><span class="line">map(str, oldList)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据上面的对象创建了一个新的列表</span><br><span class="line">newList = list(map(str,oldList))</span><br></pre></td></tr></table></figure>

<p>若想要从考试分数的一个列表中删除所有的0分，如下循环可以完成这个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">newList = []</span><br><span class="line">for number in oldList:</span><br><span class="line">    if number &gt; 0:</span><br><span class="line">        newList.append(number)</span><br></pre></td></tr></table></figure>

<p>或者可以使用filter函数，该函数接受一个布尔函数和一个可迭代对象作为参数。filter函数返回一个可迭代的对象，其中每一项都传递给这个布尔函数。如果该函数返回True，这一项保留在返回的可迭代对象中；否则的话，删除该项。简而言之，实际上filter函数让接受的这个可迭代对象的每一项都通过一个测试。</p>
<p>因此，假设已经有了这个布尔函数：isPositive,如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建了一个可迭代对象，其中包含了非零的得分</span><br><span class="line">filter(isPositive, oldList)</span><br><span class="line"># 根据该对象创建了一个新的列表</span><br><span class="line">newList = list(filter(isPositive,oldList))</span><br></pre></td></tr></table></figure>

<h4 id="使用lambda表达式创建匿名函数"><a href="#使用lambda表达式创建匿名函数" class="headerlink" title="使用lambda表达式创建匿名函数"></a>使用lambda表达式创建匿名函数</h4><p>可以临时性地创建一个匿名函数以传递给 map 或 filter，从而避免定义像 isPositive 这样的一次性的辅助函数。<br>lambda表达式形式： <code>lambda &lt;argument list&gt; : &lt;expression&gt;</code><br>注意，这个表达式不能像其他的Python函数那样包含一个语句序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个匿名的布尔函数来从分数的列表删除0分。</span><br><span class="line">newList = list(filter(lambda number : number &gt; 0,oldList))</span><br></pre></td></tr></table></figure>

<p>另一个高阶函数functools.reduce，通过应用带有两个参数的函数来将一个可迭代对象的项转换为单个的值，而该函数的两个参数是下一项和前一次应用该函数的结果。<br>因此，前面展示的计算一个数列的乘积的for循环，也可以写成如下的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个匿名的布尔函数来从分数的列表删除0分。</span><br><span class="line">newList = list(filter(lambda number : number &gt; 0,oldList))</span><br></pre></td></tr></table></figure>

<p>另一个高阶函数functools.reduce，通过应用带有两个参数的函数来将一个可迭代对象的项转换为单个的值，而该函数的两个参数是下一项和前一次应用该函数的结果。<br>因此，前面展示的计算一个数列的乘积的for循环，也可以写成如下的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">product = functools.reduce(lambda x, y : x*y, range(1,11))</span><br></pre></td></tr></table></figure>

<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>当 Python 虚拟机在程序执行的过程中遇到一个语义错误的时候，它抛出一个异常，停止程序并且给出一条错误消息。<br>Python 包含了一条try-except语句，它允许程序捕获异常并执行相应的恢复操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">except &lt;exception type&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br></pre></td></tr></table></figure>

<p>当运行这条语句的时候，try 子句中的语句将会执行。如果这些语句中的一条引发异常，执行将会立即传递到 except 子句。如果所引发的异常的类型和这条子句中的异常类型一致，将会执行其语句。否则，将执行传递到try-except语句的调用者，并且进一步沿着调用链向上传递，直到异常成功地得到处理，或者程序停止并产生一条错误消息。如果 try 子句中的语句没有引发异常，就会跳过except子句，并且执行继续直到try-except语句的末尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Author: Ken Lambert</span><br><span class="line">Demonstrates a function that traps number format errors during input.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def safeIntegerInput(prompt):</span><br><span class="line">    &quot;&quot;&quot;Prompts the user for an integer and returns the</span><br><span class="line">    integer if it is well-formed.Otherwise, prints an </span><br><span class="line">    error message and repeats this process.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    inputString = input(inputString)</span><br><span class="line">    try:</span><br><span class="line">        number = int(inputString)</span><br><span class="line">        return number</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&quot;Error in number format: &quot;inputString)</span><br><span class="line">        return safeIntegerInput(prompt)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    age = safeIntegerInput(&quot;Enter your age: &quot;)</span><br><span class="line">    print(&quot;Your age is &quot;, age)</span><br></pre></td></tr></table></figure>

<h4 id="文件及其操作"><a href="#文件及其操作" class="headerlink" title="文件及其操作"></a>文件及其操作</h4><h5 id="文本文件的输出"><a href="#文本文件的输出" class="headerlink" title="文本文件的输出"></a>文本文件的输出</h5><p>根据文本文件的格式和数据的用途，可以将文本文件中的数据看做是字符、单词、数字或者文本行。当把这些数据当作整数或浮点数的时候，必须用空白符（空格、制表符和换行符）将其分隔开。<br>文本文件的所有数据输出或数据输入都必须是字符串。<br>可以使用文件对象将数据输出到文本文件中。Python中的open函数接受文件的路径名称和模式字符串作为参数，它打开到磁盘上的文件的一个连接，并且返回文件对象。模式字符串’r’表示输入文件，’w’表示输出文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在文件名为&quot;myfile.txt&quot;的文件上打开一个文件对象以进行输出。</span><br><span class="line">f = open(&quot;myfile.txt&quot;,&apos;w&apos;)</span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，会使用给定的路径名称来创建它。如果文件已经存在，Python会打开它。当数据写入到文件并且文件关闭的时候，文件中之前存在的任何数据都会被擦除。<br>使用write方法和文件对象，将字符串数据写入（或输入）到一个文件之中。write方接受单个的字符串参数。如果想要输出文本并且以换行来结束，必须在字符串中包含转义字符’\n’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在文件名为&quot;myfile.txt&quot;的文件上打开一个文件对象以进行输出。</span><br><span class="line">f = open(&quot;myfile.txt&quot;,&apos;w&apos;)</span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，会使用给定的路径名称来创建它。如果文件已经存在，Python会打开它。当数据写入到文件并且文件关闭的时候，文件中之前存在的任何数据都会被擦除。<br>使用write方法和文件对象，将字符串数据写入（或输入）到一个文件之中。write方接受单个的字符串参数。如果想要输出文本并且以换行来结束，必须在字符串中包含转义字符’\n’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将两行文本写入到了文件中</span><br><span class="line">f.write(&quot;First line.\nSecond line.\n&quot;)</span><br><span class="line"># 当所有的输出完成后，应该使用close方法来关闭文件，如果没有成功地关闭输出的文件，将会导致数据丢失。</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="将数字写入到一个文本文件"><a href="#将数字写入到一个文本文件" class="headerlink" title="将数字写入到一个文本文件"></a>将数字写入到一个文本文件</h5><p>文件方法write接受字符串参数。因此，其他类型的数据，如整数或浮点数，必须先转换成为字符串，然后才能写入到输出文件中。在Python中大多数数据类型的值都可以使用str函数来转换字符串。然后，使用空格或换行作为分隔字符，将所得到的字符串写入到文件中。</p>
<h5 id="将数字写入到一个文本文件-1"><a href="#将数字写入到一个文本文件-1" class="headerlink" title="将数字写入到一个文本文件"></a>将数字写入到一个文本文件</h5><p>文件方法write接受字符串参数。因此，其他类型的数据，如整数或浮点数，必须先转换成为字符串，然后才能写入到输出文件中。在Python中大多数数据类型的值都可以使用str函数来转换字符串。然后，使用空格或换行作为分隔字符，将所得到的字符串写入到文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import random </span><br><span class="line">f = open(&quot;integers.txt&quot;,&apos;w&apos;)</span><br><span class="line">for count in range(500):</span><br><span class="line">    number = random.randint(1,500)</span><br><span class="line">    f.write(str(number) + &quot;\n&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="从文本文件读取文本"><a href="#从文本文件读取文本" class="headerlink" title="从文本文件读取文本"></a>从文本文件读取文本</h5><p>打开一个文件进行输入的方式，和打开一个文件进行输出的方式相同。唯一的变化在于模式字符串。在打开文件进行输入的情况下，使用’r’字符串。最简单的方法是使用文件方法read来将整个文件的内容作为一个单独的字符串输入。如果文件包含了多行文本的话，换行字符将会嵌入到这个字符串中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&quot;myfile.txt&quot;,&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; text = f.read()</span><br></pre></td></tr></table></figure>

<p>在输入完成后，再次调用read将会返回一个空的字符串，表明已经到达了文件的末尾。要重复输入，必须再次打开文件。这样的话就不需要关闭该文件了。<br>使用for循环可以让程序每次只读取和处理一行文本。for循环将一个文件对象当作是文本行的一个序列。在每次通过循环的时候，循环变量都跳到序列中的下一行文本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;integers.txt&apos;,&apos;r&apos;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<p>readline 方法只读取一行的输入并且返回该字符串，包括换行符。如果readline遇到了文件的末尾，它会返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;integers.txt&apos;,&apos;r&apos;)</span><br><span class="line">while True:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    if line == &quot;&quot;:</span><br><span class="line">        break</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<h5 id="从文件读取数字"><a href="#从文件读取数字" class="headerlink" title="从文件读取数字"></a>从文件读取数字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ingeger.txt 是用换行符隔开的随机数</span><br><span class="line">f = open(&quot;integers.txt&quot;,&apos;r&apos;)</span><br><span class="line">sum = 0</span><br><span class="line">for line in f:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    number = int(line)</span><br><span class="line">    sum += number</span><br><span class="line">print(&quot;The sum is: &quot;,sum)</span><br></pre></td></tr></table></figure>

<p>从用空格隔开的文本文件中获取数字，则要稍微难一点。一种处理方法是，在一个for循环中读取行，但每一行可能包含空格隔开的几个整数。可以使用字符串方法split来获取表示这些整数的字符串的一个列表，然后使用另一个for循环来处理这个列表中的每一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;integers.txt&quot;,&apos;r&apos;)</span><br><span class="line">sum = 0</span><br><span class="line">for line in f:</span><br><span class="line">    wordlist = line.split()</span><br><span class="line">    for word in wordlist:</span><br><span class="line">          number = int(word)</span><br><span class="line">          sum += number</span><br><span class="line">print(&quot;The sum is :&quot;,sum)</span><br></pre></td></tr></table></figure>

<p>现在文本不必再剔除换行符了，因为split会自动地负责此项工作。</p>
<h5 id="用pickle读写对象"><a href="#用pickle读写对象" class="headerlink" title="用pickle读写对象"></a>用pickle读写对象</h5><p>我们可以将任何对象转换为文本进行存储，但是将复杂的对象映射为文本再映射回来，这个过程很烦，并且会为维护带来难度。Python有个模块，允许程序员使用一个叫做封装（pickling）的工具来保存和加载对象。这个术语源自于把黄瓜变成腌菜以便再罐子里储存的过程。然而，在计算对象的时候，我们还会把腌菜变回为黄瓜。任何对象都可以被封装（pickled），然后再将其保存到文件中，然后，随着你将其从文件中加载到程序中，对它们进行“拆封（unpickled)”。Python自动负责所有的转换细节。<br>首先导入一个pickle模块。使用”rb”和”wb”标志（用于字节流）来打开文件以进行输入和输出，并且以常用的方式来关闭文件。要保存对象，就使用pickle.dump函数。它的第一个参数是要”转储“或者说要存储到文件中的对象，其第二个参数是一个文件对象。<br>例如，可以使用pickle模块将一个名为lyst列表中的对象保存到一个名为item.dat的文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">lyst = [60, &quot;A string object&quot;, 1977]</span><br><span class="line">fileObj = open(&quot;items.dat&quot;,&quot;wb&quot;)</span><br><span class="line">for item in lyst:</span><br><span class="line">        pickle.dump(item,fileObj)</span><br><span class="line">fileObj.close()</span><br></pre></td></tr></table></figure>

<p>这个示例中，也可以将整个列表写入到一个文件中，而不是将其每个对象写入到文件中。<br>可以使用pickle.load函数，将封装的对象从一个文件加载到一个程序中。如果到达了文件的末尾，这个函数会引发一个异常。这使得输入过程复杂化了，因为在引发异常之前，没有明确的方法来检查是否达到了文件末尾。但是使用try-except语句解决这一问题。<br>现在，可构建一个输入文件循环来持续地加载对象，直到达到文件的末尾，此时引发一个EOFError。随后，except子句将会关闭文件并且退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#从item.dat文件中将对象加载到一个新的、名为lyst的列表中：</span><br><span class="line">import pickle</span><br><span class="line">lyst = list()</span><br><span class="line">fileObj = open(&quot;items.dat&quot;,&quot;rb&quot;)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        item = pickle.load(fileObj)</span><br><span class="line">        lyst.append(item)</span><br><span class="line">    except EOFError:</span><br><span class="line">        fileObj.close()</span><br><span class="line">        break</span><br><span class="line">print(lyst)</span><br></pre></td></tr></table></figure>

<h5 id="创建新的类"><a href="#创建新的类" class="headerlink" title="创建新的类"></a>创建新的类</h5><p>类描述了数据和一组相关对象方法。类提供了一个蓝图，可以用来创建对象以及在这些对象上调用方法的时候所执行的代码。Python中所有的数据类型都是类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#定义Python类</span><br><span class="line">calss &lt;class name&gt;(&lt;prarent class name&gt;):</span><br><span class="line">    &lt;class variable assignments&gt;</span><br><span class="line">    &lt;instance method definitions&gt;</span><br></pre></td></tr></table></figure>

<p>按照惯例，类名是要大写的。类定义的代码通常放在模块中，该模块的文件名和类名一样，但是是小写的。相关的类也可以出现在同一个模块中。<br>父类名是可选的，在这种情况下，会假设它是object。所有的Python类都位于层级中，object在这个层级的根部，有几个方法如<strong>str</strong>和<strong>eq</strong>均定义于object中，并且是所有的子类都会自动继承的。<br>实例方法在类的对象之上运行，它们包含了访问或修改实例变量的代码。实例变量引用了单个对象所拥有的存储。<br>类变量引用了类的所有对象共同拥有的存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Counter(object):</span><br><span class="line">    &quot;&quot;&quot;Models a counter&quot;&quot;&quot;</span><br><span class="line">    # Class variable</span><br><span class="line">    instances = 0</span><br><span class="line"></span><br><span class="line">    # Constructor</span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot; Set up the counter.&quot;&quot;&quot;</span><br><span class="line">        Counter.instances += 1</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    # Mutator methods</span><br><span class="line">    def reset(self):</span><br><span class="line">        &quot;&quot;&quot;Sets the counter to 0.&quot;&quot;&quot;</span><br><span class="line">        self._value = 0</span><br><span class="line"></span><br><span class="line">    def increment(self, amount=1):</span><br><span class="line">        &quot;&quot;&quot; Add amount to the counter.&quot;&quot;&quot;</span><br><span class="line">        self._value += amount</span><br><span class="line"></span><br><span class="line">    def decrement(self, amount=1):</span><br><span class="line">        &quot;&quot;&quot; Subtracts amount from the counter.&quot;&quot;&quot;</span><br><span class="line">        self._value -= amount</span><br><span class="line"></span><br><span class="line">    # Acessor methods</span><br><span class="line">    def getValue(self):</span><br><span class="line">        &quot;&quot;&quot;Returns the counter&apos;s value.&quot;&quot;&quot;</span><br><span class="line">        return self._value</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        &quot;&quot;&quot;Returns the string representation of the counter.&quot;&quot;&quot;</span><br><span class="line">        return str(self._value)</span><br><span class="line"></span><br><span class="line">    def __eq__(self, other):</span><br><span class="line">        &quot;&quot;&quot;Returns True if self equals other</span><br><span class="line">        or False otherwise.&quot;&quot;&quot;</span><br><span class="line">        if self is other:</span><br><span class="line">            return True</span><br><span class="line">        if type(self) != type(other):</span><br><span class="line">            return False</span><br><span class="line">        return self._value == other._value</span><br></pre></td></tr></table></figure>

<p>Counter 是object的一个子类。<br>类变量instances记录了创建的Counter对象的数目。除了最初在通过赋值引入类变量的时候之外，在其他时候，类变量必须有一个类名作为其前缀。<br>定义实例的语法与定义函数的语法是相同的。然而有一个额外的self参数，它总是出现在参数列表的开始处。在一个方法定义的上下文中，self引用的是在其上运行该方法的对象。<br>实例化方法<strong>init</strong>也叫作构造方法，当创建Counter的实例的时候，会自动运行其构造方法。该方法初始化了实例变量，并且更新了类变量。<br>修改器（mutator）方法通过修改对象的实例变量，来修改或改变对象的内部状态。访问器（accessor)方法直接查看或使用对象的实例变量的值，而不会修改它们。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div>
    
 </div>
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Keras functional API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhaohui Bai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mist">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Keras functional API/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T23:21:03+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Keras-functional-API"><a href="#Keras-functional-API" class="headerlink" title="Keras functional API"></a>Keras functional API</h3><h5 id="Keras-functional-API-是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。"><a href="#Keras-functional-API-是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。" class="headerlink" title="Keras functional API 是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。"></a>Keras functional API 是一种用来定义复杂模型（如多输出模型、有向无环图或具有共享层的模型）的方法。</h5><h4 id="例1：全连接网络"><a href="#例1：全连接网络" class="headerlink" title="例1：全连接网络"></a>例1：全连接网络</h4><p>其实对于实现全连接网络，<code>Sequential</code>模型是更好的选择。</p>
<ul>
<li>层的实例可以被调用（on a tensor)，并且返回一个tensor</li>
<li>使用输入输出张量来定义<code>Model</code></li>
<li>这种模型可以像<code>Sequential</code>模型一样训练。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Input,Dense</span><br><span class="line">from keras.models import Model</span><br><span class="line"># This returns a tensor</span><br><span class="line">inputs = Input(shape=(784,))</span><br><span class="line"></span><br><span class="line"># a layer instance is callable on a tensor, and returns a tensor</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(inputs)</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line">predictions = Dense(10,activation=&apos;softmax&apos;)(x)</span><br><span class="line"></span><br><span class="line"># This creates a model that includes</span><br><span class="line"># the Input layer and three Dense layers</span><br><span class="line">model = Model(inputs=inputs,outputs=predictions)</span><br><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,</span><br><span class="line">              loss=&apos;categorical_crossentropy&apos;,</span><br><span class="line">              metrics=[&apos;accuracy&apos;])</span><br><span class="line">model.fit(data,labels) # starts training</span><br></pre></td></tr></table></figure>

<h4 id="所有模型都可以像层一样调用"><a href="#所有模型都可以像层一样调用" class="headerlink" title="所有模型都可以像层一样调用"></a>所有模型都可以像层一样调用</h4><h5 id="使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。"><a href="#使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。" class="headerlink" title="使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。"></a>使用功能API，可以轻松地重用经过训练的模型：您可以通过在张量上调用任何模型来将其视为一个层。请注意，通过调用模型，您不仅可以重用模型的体系结构，还可以重用其权重。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Input(shape=(784,))</span><br><span class="line"># This works, and returns the 10-way softmax we defined above.</span><br><span class="line">y = model(x)</span><br></pre></td></tr></table></figure>

<h5 id="这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。"><a href="#这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。" class="headerlink" title="这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。"></a>这可以允许快速创建可以处理输入序列的模型。您可以将图像分类模型转换为视频分类模型，只需一行。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import TimeDistributed</span><br><span class="line"># Input tensor for sequences of 20 timesteps</span><br><span class="line"># each containing a 784-dimensional vector</span><br><span class="line">input_sequences =Input(shape=(20,784))</span><br><span class="line"></span><br><span class="line"># This applies our previous model to every timestep in the input sequences.</span><br><span class="line"># the output of the previous model was a 10-way softmax</span><br><span class="line"># so the output of the layer below will be a sequence of 20 vectors of size 10.</span><br><span class="line">processed_sequences = TimeDistributed(model)(input_sequences)</span><br></pre></td></tr></table></figure>

<h4 id="多输入和多输出模型"><a href="#多输入和多输出模型" class="headerlink" title="多输入和多输出模型"></a>多输入和多输出模型</h4><h5 id="functional-API-使操作大量交织在一起的数据流变得容易。"><a href="#functional-API-使操作大量交织在一起的数据流变得容易。" class="headerlink" title="functional API 使操作大量交织在一起的数据流变得容易。"></a>functional API 使操作大量交织在一起的数据流变得容易。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from keras.layres import Input,Embedding,LSTM,Dense</span><br><span class="line">from keras.models import Model</span><br><span class="line"></span><br><span class="line"># Headline input: meant to receive sequences of 100 integersm,between 1 and 10000.</span><br><span class="line"># Note that we can name any layer by passing it a &quot;name&quot; argument.</span><br><span class="line">main_input = Input(shape=(100,),dtype=&apos;int32&apos;,name=&apos;main_input&apos;)</span><br><span class="line"></span><br><span class="line"># This embedding layer will encode the input sequence</span><br><span class="line"># into a sequence of dense 512-dimensional vectors.</span><br><span class="line">x = Embedding(output_dim=512,input_dim=10000,input_length=100)(main_input)</span><br><span class="line"></span><br><span class="line"># A LSTM will transform the vector sequence into a single vector,</span><br><span class="line"># containing information about the entire sequence</span><br><span class="line">lstm_out = LSTM(32)(x)</span><br><span class="line">auxiliary_output = Dense(1,activation=&apos;sigmoid&apos;,name=&apos;aux_output&apos;)(lstm_out)</span><br><span class="line"></span><br><span class="line">auxiliary_input = Input(shape=(5,),name=&apos;aux_input&apos;)</span><br><span class="line">x = keras.layers.concatenate([lstm_out,auxiliary_input])</span><br><span class="line"></span><br><span class="line"># We stack a deep densely-connected network on top</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line">x = Dense(64,activation=&apos;relu&apos;)(x)</span><br><span class="line"></span><br><span class="line"># And finally we add the main logistic regression layer</span><br><span class="line">main_output = Dense(1,activation=&apos;sigmoid&apos;,name=&apos;main_output&apos;)(x)</span><br></pre></td></tr></table></figure>

<h5 id="这定义了一个具有两个输入和两个输出的模型："><a href="#这定义了一个具有两个输入和两个输出的模型：" class="headerlink" title="这定义了一个具有两个输入和两个输出的模型："></a>这定义了一个具有两个输入和两个输出的模型：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Model(inputs=[main_input,auxiliary_input],outputs=[main_output,auxiliary_output])</span><br></pre></td></tr></table></figure>

<h5 id="我们编译模型并为辅助损失分配0-2的权重。要为不同的输出指定不同的loss-weights或loss，可以使用列表或字典。这里我们传递一个损失作为loss参数，因此所有输出都将使用相同的损失。"><a href="#我们编译模型并为辅助损失分配0-2的权重。要为不同的输出指定不同的loss-weights或loss，可以使用列表或字典。这里我们传递一个损失作为loss参数，因此所有输出都将使用相同的损失。" class="headerlink" title="我们编译模型并为辅助损失分配0.2的权重。要为不同的输出指定不同的loss_weights或loss，可以使用列表或字典。这里我们传递一个损失作为loss参数，因此所有输出都将使用相同的损失。"></a>我们编译模型并为辅助损失分配0.2的权重。要为不同的输出指定不同的loss_weights或loss，可以使用列表或字典。这里我们传递一个损失作为<code>loss参数</code>，因此所有输出都将使用相同的损失。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,loss=&apos;binary_crossentropy&apos;,</span><br><span class="line">              loss_weights=[1.,0.2])</span><br></pre></td></tr></table></figure>

<h5 id="我们可以通过传递输入数组和目标数组的列表来训练模型："><a href="#我们可以通过传递输入数组和目标数组的列表来训练模型：" class="headerlink" title="我们可以通过传递输入数组和目标数组的列表来训练模型："></a>我们可以通过传递输入数组和目标数组的列表来训练模型：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.fit([heading_data,additional_data],[labels,labels],</span><br><span class="line">          epochs=50,batch_size=32)</span><br></pre></td></tr></table></figure>

<h5 id="由于我们的输入和输出被命名（我们传递了一个“name”参数），我们也可以通过以下方式编译模型："><a href="#由于我们的输入和输出被命名（我们传递了一个“name”参数），我们也可以通过以下方式编译模型：" class="headerlink" title="由于我们的输入和输出被命名（我们传递了一个“name”参数），我们也可以通过以下方式编译模型："></a>由于我们的输入和输出被命名（我们传递了一个“<code>name</code>”参数），我们也可以通过以下方式编译模型：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,</span><br><span class="line">              loss=&#123;&apos;main_output&apos;:&apos;binary_crossentropy&apos;,&apos;aux_output&apos;:&apos;binary_crossentropy&apos;&#125;,</span><br><span class="line">              loss_weight=&#123;&apos;main_output&apos;:1.,&apos;aux_output&apos;:0.2&#125;)</span><br><span class="line">              </span><br><span class="line"># And trained it via:</span><br><span class="line">model.fit(&#123;&apos;main_input&apos;:headline_data,&apos;aux_output&apos;:additional_data&#125;,</span><br><span class="line">          &#123;&apos;main_output&apos;:labels,&apos;aux_ouput&apos;:labels&#125;,</span><br><span class="line">          epochs=50,batch_size=32)</span><br></pre></td></tr></table></figure>

<h5 id="共享层"><a href="#共享层" class="headerlink" title="共享层"></a>共享层</h5><p>使用函数API的另一个好处是模型可以使用共享层。<br>例子：<br>建立一个模型来判断两条推特是不是同一个用户所发。（可以通过比较推文的相似性来确定）<br>将两条推文编码成两个向量并连接，添加逻辑回归层，这将输出两条推文来自同一用户的概率。使用来自同一用户的两条推文（正），不是同一用户所发的两条推文（负）来训练模型。<br>由于问题是对称的，编码第一条推文的机制（包括权重等）将被重用来编码第二条推文。这里使用LSTM层来编码推文。<br>使用函数式 API 来构建模型。首先我们将一条推特转换为一个尺寸为 (280, 256) 的矩阵，即每条推特 280 字符，每个字符为 256 维的 one-hot 编码向量 （取 256 个常用字符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import keras</span><br><span class="line">from keras.layers import Input,LSTM,Dense</span><br><span class="line">from keras.models import Model</span><br><span class="line"></span><br><span class="line">tweet_a = Input(shape=(280,256)</span><br><span class="line">tweet_b = Input(shape=(280,256)</span><br></pre></td></tr></table></figure>

<p>要在不同的输入上共享同一个层，只需实例化该层一次，然后根据需要传入你想要的输入即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># This layer can take as input a matrix</span><br><span class="line"># and will return a vector of size 64</span><br><span class="line">shared_lstm = LSTM(64)</span><br><span class="line"></span><br><span class="line"># When we reuse the same layer instance</span><br><span class="line"># multiple times,the weights of layer</span><br><span class="line"># are also being reused</span><br><span class="line"># (it is effectively *the same* layer)</span><br><span class="line">encoded_a = shared_lstm(tweet_a)</span><br><span class="line">encoded_b = shared_lstm(tweet_b)</span><br><span class="line"></span><br><span class="line"># We can then concatenate the two vectors:</span><br><span class="line">merged_vector = keras.layers.concatenate([encoded_a,encoded_b]),axis=-1)</span><br><span class="line"></span><br><span class="line"># And add a logistic regression on top</span><br><span class="line">predictions = Dense(1,activation=&apos;sigmoid&apos;)(merged_vector)</span><br><span class="line"></span><br><span class="line"># We defined a trainable model linking the</span><br><span class="line"># tweet inputs to the predictions</span><br><span class="line"># 定义一个连接推特输入和预测的可训练的模型</span><br><span class="line">model = Model(inputs=[tweet_a,tweet_b],outputs=predictions)</span><br><span class="line">model.compile(optimizer=&apos;rmsprop&apos;,</span><br><span class="line">              loss=&apos;binary_crossentropy&apos;,</span><br><span class="line">              metrics=[&apos;accuracy&apos;])</span><br><span class="line">model.fit([data_a,data_b],labels,epochs=10)</span><br></pre></td></tr></table></figure>

<h5 id="如何读取共享层的输出或输出尺寸"><a href="#如何读取共享层的输出或输出尺寸" class="headerlink" title="如何读取共享层的输出或输出尺寸?"></a>如何读取共享层的输出或输出尺寸?</h5><h4 id="层节点（The-concept-of-layer-“node”）"><a href="#层节点（The-concept-of-layer-“node”）" class="headerlink" title="层节点（The concept of layer “node”）"></a>层节点（The concept of layer “node”）</h4><p>每当你在某个输入上调用一个层时，都将创建一个新的张量（层的输出），并且为该层添加一个「节点」，将输入张量连接到输出张量。当多次调用同一个图层时，该图层将拥有多个节点索引 (0, 1, 2…)。<br>在之前版本的 Keras 中，可以通过 <code>layer.get_output()</code> 来获得层实例的输出张量，或者通过 <code>layer.output_shape</code> 来获取其输出形状。现在你依然可以这么做（除了 <code>get_output()</code> 已经被 <code>output</code> 属性替代）。但是如果一个层与多个输入连接呢？</p>
<p>只要一个层仅仅连接到一个输入，就不会有困惑，<code>.output</code> 会返回层的唯一输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = Input(shape=(280,256))</span><br><span class="line">lstm = LSTM(32)</span><br><span class="line">encoded_a = lstm(a)</span><br><span class="line">assert lstm.output == encoded_a</span><br></pre></td></tr></table></figure>

<p>但是如果该层有多个输入，那就会出现问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = Input(shape=(280,256))</span><br><span class="line">b = Input(shape=(280,256))</span><br><span class="line"></span><br><span class="line">lstm = LSTM(32)</span><br><span class="line">encoded_a = lstm(a)</span><br><span class="line">encoded_b = lstm(b)</span><br><span class="line"></span><br><span class="line">lstm.output</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; AttributeError: Layer lstm_1 has multiple inbound nodes,</span><br><span class="line">hence the notion of &quot;layer output&quot; is ill-defined.</span><br><span class="line">Use `get_output_at(node_index)` instead.</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert lstm.get_output_at(0) == encoded_a</span><br><span class="line">assert lstm.get_output_at(1) == encoded_b</span><br></pre></td></tr></table></figure>

<p><code>input_shape</code> 和 <code>output_shape</code> 这两个属性也是如此：只要该层只有一个节点，或者只要所有节点具有相同的输入/输出尺寸，那么「层输出/输入尺寸」的概念就被很好地定义，并且将由 <code>layer.output_shape / layer.input_shape</code> 返回。但是比如说，如果将一个 <code>Conv2D</code> 层先应用于尺寸为 <code>(32，32，3)</code> 的输入，再应用于尺寸为 <code>(64, 64, 3)</code> 的输入，那么这个层就会有多个输入/输出尺寸，你将不得不通过指定它们所属节点的索引来获取它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = Input(shape=(32,32,3))</span><br><span class="line">b = Input(shape=(64,64,3))</span><br><span class="line"></span><br><span class="line">conv = Conv2D(16,(3,3),padding=&apos;same&apos;)</span><br><span class="line">conved_a = conv(a)</span><br><span class="line"></span><br><span class="line">#Only one input so far,the following will work:</span><br><span class="line">assert conv.input_shape == (None,32,32,3)</span><br><span class="line"></span><br><span class="line">conved_b = conv(b)</span><br><span class="line"># now the &apos;.input_shape&apos; property wouldn&apos;t work,but this does:</span><br><span class="line">assert conv.get_input_shape_at(0) == (None,32,32,3)</span><br><span class="line">assert conv.get_input_shape_at(1) == (None,64,64,3)</span><br></pre></td></tr></table></figure>

<h4 id="更多的例子"><a href="#更多的例子" class="headerlink" title="更多的例子"></a>更多的例子</h4><h5 id="Inception模型"><a href="#Inception模型" class="headerlink" title="Inception模型"></a>Inception模型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,MaxPooling2D,Input</span><br><span class="line"></span><br><span class="line">input_img = Input(shape=(256,256,3))</span><br><span class="line"></span><br><span class="line">tower_1 = Conv2D(64,(1,1),padding=&apos;same&apos;,activation=&apos;relu&apos;)(input_img)</span><br><span class="line">tower_1 = Conv2D(64,(3,3),padding=&apos;same&apos;,activation=&apos;relu&apos;)(tower_1)</span><br><span class="line"></span><br><span class="line">tower_2 = Conv2D(64,(1,1),padding=&apos;same&apos;,activation=&apos;relu&apos;)(input_img)</span><br><span class="line">tower_2 = Conv2D(64,(5,5),padding=&apos;same&apos;,activation=&apos;relu&apos;)(tower_2)</span><br><span class="line"></span><br><span class="line">tower_3 = MaxPooling2D((3,3),strides=(1,1),padding=&apos;same&apos;)(input_img)</span><br><span class="line">tower_3 = Conv2D(64,(1,1),padding=&apos;same&apos;,activation=&apos;relu&apos;)(tower_3)</span><br><span class="line"></span><br><span class="line">output = keras.layers.concatenate([tower_1,tower_2,tower_3],axis=1)</span><br></pre></td></tr></table></figure>

<h5 id="卷积层上的残差连接"><a href="#卷积层上的残差连接" class="headerlink" title="卷积层上的残差连接"></a>卷积层上的残差连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,Input</span><br><span class="line"># input tensor for a 3-channel 256x256 image</span><br><span class="line">x = Input(shape=(256,256,3))</span><br><span class="line"># 3x3 conv with 3 output channels (same as input channels)</span><br><span class="line">y = Conv2D(3,(3,3),padding=&apos;same&apos;)(x)</span><br><span class="line"># this returns x+y</span><br><span class="line">z = keras.layers.add([x,y])</span><br></pre></td></tr></table></figure>

<h5 id="共享视觉模型"><a href="#共享视觉模型" class="headerlink" title="共享视觉模型"></a>共享视觉模型</h5><p>该模型在两个输入上重复使用同一个图像处理模块，以判断两个 MNIST 数字是否为相同的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,MaxPooling2D,Input,Dense,Flatten</span><br><span class="line">from keras.models import Model</span><br><span class="line"></span><br><span class="line"># First,define the vision modules</span><br><span class="line">digit_input = Input(shape=(27,27,1))</span><br><span class="line">x = Conv2D(64,(3,3))(digit_input)</span><br><span class="line">x = Conv2D(64,(3,3))(x)</span><br><span class="line">x = MaxPooling2D((2,2))(x)</span><br><span class="line">out = Flatten()(x)</span><br><span class="line"></span><br><span class="line">vision_model = Model(digit_input,out)</span><br><span class="line"></span><br><span class="line"># Then define the tell-digits-apart model</span><br><span class="line">digit_a = Input(shape=(27,27,1))</span><br><span class="line">digit_b = Input(shape=(27,27,1))</span><br><span class="line"></span><br><span class="line"># The vision model will be shared,weights and all</span><br><span class="line">out_a = vision_model(digit_a)</span><br><span class="line">out_b = vision_model(digit_b)</span><br><span class="line"></span><br><span class="line">concatenated = keras.layers.concatenate([out_a,out_b])</span><br><span class="line">out = Dense(1,activation=&apos;sigmoid&apos;)(concatenated)</span><br><span class="line"></span><br><span class="line">classification_model = Model([digit_a,digit_b],out)</span><br></pre></td></tr></table></figure>

<h5 id="视觉问答模型"><a href="#视觉问答模型" class="headerlink" title="视觉问答模型"></a>视觉问答模型</h5><p>当被问及关于图片的自然语言问题时，该模型可以选择正确的单词作答。<br>它通过将问题和图像编码成向量，然后连接两者，在上面训练一个逻辑回归，来从词汇表中挑选一个可能的单词作答。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D,MaxPooling2D,Flatten</span><br><span class="line">from keras.layers import Input,LSTM,Embedding,Dense</span><br><span class="line">from keras.models import Model,Sequential</span><br><span class="line"># First,let&apos;s define a vision model using a Sequential model</span><br><span class="line"># This model will encode an image into a vector</span><br><span class="line">vision_model = Sequential()</span><br><span class="line">vision_model.add(Conv2D(64,(3,3),activation=&apos;relu&apos;,padding=&apos;same&apos;,input_shape=(224,224,3)))</span><br><span class="line">vision_model.add(Conv2D(64,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(MaxPooling2D((2,2)))</span><br><span class="line">vision_model.add(Conv2D(128,(3,3),activation=&apos;relu&apos;,padding=&apos;same&apos;))</span><br><span class="line">vision_model.add(Conv2D(128,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(MaxPooling2D((2,2)))</span><br><span class="line">vision_model.add(Conv2D(256,(3,3),activation=&apos;relu&apos;,padding=&apos;same&apos;))</span><br><span class="line">vision_model.add(Conv2D(256,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(Conv2D(256,(3,3),activation=&apos;relu&apos;))</span><br><span class="line">vision_model.add(MaxPooling2D((2,2)))</span><br><span class="line">vision_model.add(Flatten())</span><br><span class="line"></span><br><span class="line"># Now let&apos;s get a tensor with the output of our vision model:</span><br><span class="line">image_input = Input(shape=(224,224,3))</span><br><span class="line">encoded_image = vision_model(image_input)</span><br><span class="line"></span><br><span class="line"># Next,let&apos;s define a language model to encode the question into a vector.</span><br><span class="line"># Each question will be at most 100 word long,</span><br><span class="line"># and we will index words as integers from 1 to 9999</span><br><span class="line">question_input = Input(shape=(100,),dtype=&apos;int32&apos;)</span><br><span class="line">embedded_question = Embedding(input_dim=10000,output_dim=256,input_length=100)(question_input)</span><br><span class="line">encoded_question = LSTM(256)(embedded_question)</span><br><span class="line"></span><br><span class="line"># Let&apos;s concatenate the question vector and the image vector:</span><br><span class="line">merged = keras.layers.concatenate([encoded_question,encoded_image])</span><br><span class="line"></span><br><span class="line"># And let&apos;s train a logistic regression over 1000 words on top:</span><br><span class="line">output = Dense(1000,activation=&apos;softmax&apos;)(merged)</span><br><span class="line"></span><br><span class="line"># This is our final model:</span><br><span class="line">vqa_model = Model(inputs=[image_input,question_input],outputs=output)</span><br><span class="line"># The next stage would be training this model on actual data.</span><br></pre></td></tr></table></figure>

<h5 id="视频问答模型"><a href="#视频问答模型" class="headerlink" title="视频问答模型"></a>视频问答模型</h5><p>现在我们已经训练了图像问答模型，我们可以很快地将它转换为视频问答模型。在适当的训练下，你可以给它展示一小段视频（例如 100 帧的人体动作），然后问它一个关于这段视频的问题（例如，「这个人在做什么运动？」 -&gt; 「足球」）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import TimeDistributed</span><br><span class="line"></span><br><span class="line">video_input = Input(shape=(100, 224, 224, 3))</span><br><span class="line"># 这是基于之前定义的视觉模型（权重被重用）构建的视频编码</span><br><span class="line">encoded_frame_sequence = TimeDistributed(vision_model)(video_input)  # 输出为向量的序列</span><br><span class="line">encoded_video = LSTM(256)(encoded_frame_sequence)  # 输出为一个向量</span><br><span class="line"></span><br><span class="line"># 这是问题编码器的模型级表示，重复使用与之前相同的权重：</span><br><span class="line">question_encoder = Model(inputs=question_input, outputs=encoded_question)</span><br><span class="line"></span><br><span class="line"># 让我们用它来编码这个问题：</span><br><span class="line">video_question_input = Input(shape=(100,), dtype=&apos;int32&apos;)</span><br><span class="line">encoded_video_question = question_encoder(video_question_input)</span><br><span class="line"></span><br><span class="line"># 这就是我们的视频问答模式：</span><br><span class="line">merged = keras.layers.concatenate([encoded_video, encoded_video_question])</span><br><span class="line">output = Dense(1000, activation=&apos;softmax&apos;)(merged)</span><br><span class="line">video_qa_model = Model(inputs=[video_input, video_question_input], outputs=output)</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhaohui Bai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BaiZhaohui" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:isolatedislet@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaohui Bai</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
